/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace OutSystems.PluginAPI.PluginConfiguration.Introspection {
    class PluginMetaParameterExtractor {
        internal enum MetaParamType {
            Parameter,
            UserDefinedParameter,
            UserChosenOptionParameter
        }

        internal class MetaParam {

            public MetaParamType Type { get; set; }
            public string PropName { get; set; }
            public MethodInfo Getter { get; set; }
            public MethodInfo Setter { get; set; }
            public bool Encrypt { get; set; }
            public bool Persist { get; set; }
            public MethodInfo visibilityChecker { get; set; }
            public IUserDefinedPluginConfiguration UserConfigurationParameter { get; set; }
            public Dictionary<string, KeyValuePair<string, string>> HelpInfo { get; set; }
        }


        private readonly IList<MetaParam> parameters;

        public PluginMetaParameterExtractor(Type configurationType) {
            this.parameters = FindParameters(configurationType);
        }

        private IList<MetaParam> FindParameters(Type type) {
            IDictionary<string, MetaParam> results = new Dictionary<string, MetaParam>();
            for (Type t = type; t != null; t = t.BaseType) {
                foreach (PropertyInfo prop in t.GetProperties()) {
                    IPluginConfigurationParameter param = GetConfigurationParameter(prop);
                    if (param != null && !results.ContainsKey(prop.Name)) {
                        results.Add(prop.Name, GetParameterToAdd(type, param, prop));
                    }
                }
            }
            return results.Values.ToList();
        }

        private static IPluginConfigurationParameter GetConfigurationParameter(PropertyInfo prop) {
            var attrs = (IPluginConfigurationParameter[]) prop.GetCustomAttributes(typeof(IPluginConfigurationParameter), false);
            return attrs.Length == 0 ? null : attrs[0];
        }

        private static IHelpLinkForPluginEnumConfiguration[] GetHelpLinksForEnum(PropertyInfo prop) {
            return (IHelpLinkForPluginEnumConfiguration[]) prop.GetCustomAttributes(typeof(IHelpLinkForPluginEnumConfiguration), false);
        }

        private MetaParam GetParameterToAdd(Type type, IPluginConfigurationParameter param, PropertyInfo prop) {
            string propName = prop.Name;
            MethodInfo getter = prop.GetGetMethod();
            MethodInfo setter = prop.GetSetMethod();

            var userDefinedConfigParam = param as IUserDefinedPluginConfiguration;
            if (userDefinedConfigParam != null) {
                MethodInfo visibilityChecker = null;
                if (!string.IsNullOrEmpty(userDefinedConfigParam.VisibilityChecker)) {
                    visibilityChecker = type.GetMethod(userDefinedConfigParam.VisibilityChecker);
                }

                if (prop.PropertyType.IsEnum) {

                    Dictionary<string, KeyValuePair<string, string>> helpInfo = null;

                    foreach (IHelpLinkForPluginEnumConfiguration help in GetHelpLinksForEnum(prop)) {
                        if (helpInfo == null) {
                            helpInfo = new Dictionary<string, KeyValuePair<string, string>>();
                        }
                        helpInfo.Add(help.EnumValue, new KeyValuePair<string, string>(help.Text, help.Url));
                    }
                    return new MetaParam {
                        Type = MetaParamType.UserChosenOptionParameter,
                        PropName = propName,
                        Getter = getter,
                        Setter = setter,
                        Encrypt = userDefinedConfigParam.Encrypt,
                        Persist = userDefinedConfigParam.Persist,
                        visibilityChecker = visibilityChecker,
                        UserConfigurationParameter = userDefinedConfigParam,
                        HelpInfo = helpInfo
                    };
                }

                return new MetaParam {
                    Type = MetaParamType.UserDefinedParameter,
                    PropName = propName,
                    Getter = getter,
                    Setter = setter,
                    Encrypt = userDefinedConfigParam.Encrypt,
                    Persist = userDefinedConfigParam.Persist,
                    visibilityChecker = visibilityChecker,
                    UserConfigurationParameter = userDefinedConfigParam
                };
            }

            return new MetaParam {
                Type = MetaParamType.Parameter,
                PropName = propName,
                Getter = getter,
                Setter = setter,
                Encrypt = param.Encrypt,
                Persist = param.Persist
            };
        }

        public IEnumerable<IPluginParameter> ToParameters(object configuration, IPluginParameterFactory pluginParameterFactory) {
            foreach (MetaParam metaparam in parameters) {
                switch (metaparam.Type) {
                    case MetaParamType.Parameter:
                        yield return pluginParameterFactory.CreatePluginParameter(metaparam.PropName, metaparam.Getter, metaparam.Setter, metaparam.Encrypt, metaparam.Persist, configuration);
                        break;
                    case MetaParamType.UserDefinedParameter:
                        yield return pluginParameterFactory.CreateUserDefinedPluginParameter(metaparam.PropName, metaparam.Getter, metaparam.Setter, metaparam.Encrypt, metaparam.Persist, configuration,
                            metaparam.visibilityChecker, metaparam.UserConfigurationParameter);

                        break;
                    case MetaParamType.UserChosenOptionParameter:
                        yield return pluginParameterFactory.CreateUserChosenOptionPluginParameter(metaparam.PropName, metaparam.Getter, metaparam.Setter, metaparam.Encrypt, metaparam.Persist, configuration,
                            metaparam.visibilityChecker, metaparam.UserConfigurationParameter, metaparam.HelpInfo);

                        break;
                    default:
                        throw new InvalidOperationException("Unexpected parameter type" + metaparam.Type);
                } 
            }
        }
    }
}
