/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Newtonsoft.Json;
using OutSystems.HubEdition.RuntimePlatform;
using OutSystems.RESTService.Behaviors;

namespace OutSystems.RESTService {

    public static class Conversions {

        private const String DateFormat = "yyyy'-'MM'-'dd";
        private const String TimeFormat = "HH':'mm':'ss";
        private const string DateTimeFormat = "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";

        private const String FormatForParseExact = "yyyy-M-d H:m:s";

        public static readonly DateTime NullDateTime = BuiltInFunction.NullDate();

        public static DateTime TextToDate(string text) {
            if (String.IsNullOrEmpty(text)) {
                return NullDateTime;
            }
            DateTime result;
            if (!DateTime.TryParseExact(text + " 00:00:00", FormatForParseExact, CultureInfo.InvariantCulture.DateTimeFormat, DateTimeStyles.None, out result)) {
               throw new FormatException("The value '" + text + "' is not valid for Date.");
            }
            return result;
        }

        public static String DateToText(DateTime date) {
            return date.ToString(DateFormat);
        }

        public static DateTime TextToTime(string text) {
            if (String.IsNullOrEmpty(text)) {
                return NullDateTime;
            }
            DateTime result;
            if (!DateTime.TryParseExact("1900-01-01 " + text, FormatForParseExact, CultureInfo.InvariantCulture.DateTimeFormat, DateTimeStyles.None, out result)) {
               throw new FormatException("The value '" + text + "' is not valid for Time.");
            }
            return result;
        }

        public static String TimeToText(DateTime time) {
            return time.ToString(TimeFormat);
        }

        public static DateTime TextToDateTime(string text, DateTimeFormat dateFormat) {
            if (dateFormat == Behaviors.DateTimeFormat.ISO) {
                if (String.IsNullOrEmpty(text) || (text.Contains("1900-01-01") && text.Contains("00:00:00"))) {
                    return NullDateTime;
                }

                DateTime result;
                if (!DateTime.TryParse(text, CultureInfo.InvariantCulture, DateTimeStyles.AssumeLocal, out result)) {
                    throw new FormatException("The value '" + text + "' is not valid for DateTime.");
                }
                return DateTimeToLocal(result);
            } else {
                if (String.IsNullOrEmpty(text)) {
                    return NullDateTime;
                }

                long secondsSinceEpoch;
                if (!Int64.TryParse(text, out secondsSinceEpoch)) {
                    throw new FormatException("The value '" + text + "' is not valid for Unix DateTime.");
                }

                return new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc).AddSeconds(secondsSinceEpoch).ToLocalTime();
            }
 
        }

        public static Func<String, DateTime> TextToDateTimeDelegate(DateTimeFormat dateFormat) {
            return (s => TextToDateTime(s, dateFormat));
        }

        public static String DateTimeToText(DateTime date) {
            return DateTimeToUniversal(date).ToString(DateTimeFormat, CultureInfo.InvariantCulture);
        }

        public static String DateTimeUnixToText(DateTime date) {
            long secondsSinceEpoch = (long)((DateTimeToUniversal(date)) - (new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc))).TotalSeconds;
            return secondsSinceEpoch.ToString();
        }

        public static String DateTimeToRestType(DateTime date, Behaviors.DateTimeFormat dateFormat) {
            if (dateFormat == Behaviors.DateTimeFormat.Unix) {
                return DateTimeUnixToText(date);
            }
            else {
                return NullDateTime == date ? "1900-01-01T00:00:00" : DateTimeToText(date);
            }
        }

        public static Func<DateTime, String> DateTimeToRestTypeDelegate(DateTimeFormat dateFormat) {
            return (dt => DateTimeToRestType(dt, dateFormat));
        }

        public static DateTime DateTimeToUniversal(DateTime date) {
            if (date.Kind == DateTimeKind.Unspecified) {
                return DateTime.SpecifyKind(date, DateTimeKind.Local).ToUniversalTime();
            } else {
                return date.ToUniversalTime();
            }
        }
        
        public static DateTime DateTimeToLocal(DateTime date) {
            if (date.Kind == DateTimeKind.Unspecified) {
                return DateTime.SpecifyKind(date, DateTimeKind.Local);
            } else {
                return date.ToLocalTime();
            }
        }

        public static String FormatAsString(int value) {
		    return value.ToString();
	    }
	
	    public static String FormatAsString(long value) {
		    return value.ToString();
	    }
	
	    public static String FormatAsString(bool value) {
            return value ? "true" : "false";
	    }

        public static String FormatAsString(decimal value) {
            String text = value.ToString(CultureInfo.InvariantCulture);
            if ((text.IndexOf('.') != -1) || (text.IndexOf('E') != -1) || text.IndexOf('e') != -1) {
                return text;
            } else {
                return text + ".0";
            }
        }
    }

}
