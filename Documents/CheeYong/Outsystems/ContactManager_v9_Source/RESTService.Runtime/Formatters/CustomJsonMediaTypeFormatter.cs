/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Net.Http.Formatting;
using Newtonsoft.Json.Serialization;
using OutSystems.HubEdition.RuntimePlatform.NewRuntime;
using OutSystems.RESTService.Behaviors;
using System.Net.Http.Headers;
using System.Threading.Tasks;
using System.IO;
using System.Net.Http;

namespace OutSystems.RESTService.Formatters {
    public class CustomJsonMediaTypeFormatter : JsonMediaTypeFormatter {

        private static readonly CustomJsonMediaTypeFormatter defaultRestServiceInstance = new CustomJsonMediaTypeFormatter(/*forRestService*/true);
        private static readonly CustomJsonMediaTypeFormatter defaultScreenServiceInstance = new CustomJsonMediaTypeFormatter(/*forRestService*/false);

        public static CustomJsonMediaTypeFormatter GetInstance(IBehaviorsConfiguration config) {
            if (config.IsRESTRequest) {
                return defaultRestServiceInstance;
            } else {
                return defaultScreenServiceInstance;
            }
        }

        private CustomJsonMediaTypeFormatter(bool forRestService) : base() {
            // Currently CustomJsonMediaTypeFormatter does not depend on the behaviors,
            // it could could recieve a IBehaviorsConfiguration as parameter
            SerializerSettings.NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore;
            SerializerSettings.DateParseHandling = Newtonsoft.Json.DateParseHandling.None;
            SupportedMediaTypes.Add(new MediaTypeHeaderValue("application/csp-report"));
            if (forRestService) {
                SerializerSettings.ContractResolver = RestContractResolver.Instance;
            } else {
                SerializerSettings.ContractResolver = ScreenServiceContractResolver.Instance;
            }
        }

        public override bool CanReadType(Type type) {
            if (type == typeof(string)) {
                return false;
            }
            return base.CanReadType(type);
        }

        public override Task<object> ReadFromStreamAsync(Type type, Stream readStream, HttpContent content, IFormatterLogger formatterLogger) {
            // "Messages MUST NOT include both a Content-Length header field and a non-identity transfer-coding. 
            //  If the message does include a non-identity transfer-coding, the Content-Length MUST be ignored."
            // (RFC 2616, Section 4.4)
            // http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html
            // Fix for that the base-implementation defaults to 'default' value if Content-Length is 0.
            if (content.Headers.ContentLength.HasValue && content.Headers.ContentLength == 0) {
                content.Headers.ContentLength = new long?();
            }

            return base.ReadFromStreamAsync(type, readStream, content, formatterLogger);
        }
    }
}
