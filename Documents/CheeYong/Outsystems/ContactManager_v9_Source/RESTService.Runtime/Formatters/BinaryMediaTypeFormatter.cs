/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections.Concurrent;
using System.IO;
using System.Net.Http;
using System.Net.Http.Formatting;
using System.Net.Http.Headers;
using System.Threading.Tasks;
using System.Web;

namespace OutSystems.RESTService.Formatters {

    public class BinaryMediaTypeFormatter : MediaTypeFormatter {

        private static readonly string[] mainMediaTypes = new string[] { "application/octet-stream" };

        public static readonly BinaryMediaTypeFormatter Instance = new BinaryMediaTypeFormatter();

        private readonly ConcurrentDictionary<string, bool> registeredMimeTypes = new ConcurrentDictionary<string, bool>();

        public BinaryMediaTypeFormatter() {
            // Register the main types
            foreach (var type in mainMediaTypes) {
                SupportedMediaTypes.Add(new MediaTypeHeaderValue(type));
                registeredMimeTypes[type] = true;
            }
	    }

	    public override Task<object> ReadFromStreamAsync(Type type, Stream readStream, HttpContent content, IFormatterLogger formatterLogger) {
		    var taskCompletionSource = new TaskCompletionSource<object>();
		    try {
			    var memoryStream = new MemoryStream();
			    readStream.CopyTo(memoryStream);
                taskCompletionSource.SetResult(memoryStream.ToArray());
		    } catch (Exception e) {
			    taskCompletionSource.SetException(e);
		    }
		    return taskCompletionSource.Task;
	    }

	    public override bool CanReadType(Type type) {
            if (type == typeof(byte[])) {
                // #REST-105 (rmf): Register the current request content-type, if not yet registed, so we can handle any content type in ths Binary formatter.
                var mimeType = RestServiceHttpUtils.GetRequestContentType(HttpContext.Current.Request).MediaType;
                if (!registeredMimeTypes.ContainsKey(mimeType)) {
                    SupportedMediaTypes.Add(new MediaTypeHeaderValue(mimeType));
                    registeredMimeTypes[mimeType] = true;
                }
                return true;
            } else {
                return false;
            }
	    }

	    public override bool CanWriteType(Type type) {
		    return false;
	    }
    }

}
