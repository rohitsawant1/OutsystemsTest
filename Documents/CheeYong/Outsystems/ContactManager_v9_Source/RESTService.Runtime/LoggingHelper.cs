/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Web;
using System.Web.Http.Controllers;
using System.Web.Http.Filters;
using OutSystems.HubEdition.RuntimePlatform;
using OutSystems.HubEdition.RuntimePlatform.Log;
using OutSystems.RuntimeCommon;

namespace OutSystems.RESTService {
    public class LoggingHelper {

        private const string RESTContextVariableName = "__RESTExposeContext";
        private const string DefaultEncoding = "utf-8";
        
        public static void SetupLoggingContext(HttpActionContext actionContext, string serviceName, string ssKey) {
            RESTExposeContext restExposeContext = new RESTExposeContext {
                StartTime = DateTime.Now,
                ServiceName = serviceName
            };

            // Try to set any of the RESTContexts
            // The REST Methods should only have one configuration with the following order:
            // 1. Expose REST API Methods
            // 2. Screen Services Actions
            // 3. ServiceAPIMethods
            // If none was set (returned true) then we are not adding this context to the HTTPContext (no logging will be processed)
            if (    TrySetRESTContextForRESTExposeActions(actionContext, ssKey, ref restExposeContext)
                ||  TrySetRESTContextForScreenServicesActions(actionContext, ref restExposeContext)
                ||  TrySetRESTContextForServiceAPIMethods(actionContext, serviceName, ssKey, ref restExposeContext)) {

                HttpContext.Current.Items[RESTContextVariableName] = restExposeContext;
            }
        }

        private static bool TrySetRESTContextForRESTExposeActions(HttpActionContext actionContext, string ssKey, ref RESTExposeContext restExposeContext) {
            RESTExposeActionPropertiesAttribute props = actionContext.ActionDescriptor.GetCustomAttributes<RESTExposeActionPropertiesAttribute>().SingleOrDefault();
            if (props != null) {
                restExposeContext.LogTo = LogTo.RESTExpose;

                var moduleKey = AppInfo.GetAppInfo().eSpaceUID;
                restExposeContext.TraceAll = RESTSettings.GetTraceAllSetting(moduleKey, ssKey).GetValue();
                restExposeContext.TraceErrors = RESTSettings.GetTraceErrorsSetting(moduleKey, ssKey).GetValue();
                restExposeContext.ActionName = props.Name;
                restExposeContext.IsRequestBinary = props.IsRequestBinary;
                restExposeContext.IsResponseBinary = props.IsResponseBinary;
                
                return true;
            }
            return false;
        }

        private static bool TrySetRESTContextForScreenServicesActions(HttpActionContext actionContext, ref RESTExposeContext restExposeContext) {
            RESTScreenServicesActionPropertiesAttribute props = actionContext.ActionDescriptor.GetCustomAttributes<RESTScreenServicesActionPropertiesAttribute>().SingleOrDefault();
            if (props != null) {
                restExposeContext.LogTo = LogTo.ScreenServices;

                restExposeContext.TraceAll = RuntimePlatformSettings.ScreenServices.TraceAll.GetValue();
                restExposeContext.TraceErrors = RuntimePlatformSettings.ScreenServices.TraceErrors.GetValue();
                restExposeContext.ActionName = props.Name;
                restExposeContext.ScreenName = props.Screen;

                return true;
            }
            return false;
        }

        private static bool TrySetRESTContextForServiceAPIMethods(HttpActionContext actionContext, string serviceName, string ssKey, ref RESTExposeContext restExposeContext) {
            RESTServiceAPIMethodPropertiesAttribute props = actionContext.ActionDescriptor.GetCustomAttributes<RESTServiceAPIMethodPropertiesAttribute>().SingleOrDefault();
            if (props != null) {
                restExposeContext.LogTo = LogTo.ServiceAPIs;

                restExposeContext.TraceAll = RuntimePlatformSettings.ServiceAPIs.TraceAll.GetValue();
                restExposeContext.TraceErrors = RuntimePlatformSettings.ServiceAPIs.TraceErrors.GetValue();
                restExposeContext.ServiceAPIMethodName = props.Name;
                restExposeContext.IsRequestBinary = props.IsRequestBinary;
                restExposeContext.IsResponseBinary = props.IsResponseBinary;

                return true;
            }
            return false;
        }

        public static RESTExposeContext GetLoggingContext() {
            return (RESTExposeContext)HttpContext.Current.Items[RESTContextVariableName];
        }

        public static void LogRequest(HttpActionContext actionContext) {
            RESTExposeContext restExposeContext = GetLoggingContext();

            if (restExposeContext != null && (restExposeContext.TraceAll || restExposeContext.TraceErrors)) {
                HttpContext context = HttpContext.Current;
                StringBuilder requestTrace = new StringBuilder();
                requestTrace.AppendLine(context.Request.HttpMethod + " " + context.Request.Url.ToString() + " " + context.Request.ServerVariables["SERVER_PROTOCOL"]);
                WriteRequestHeaders(requestTrace, context);                

                if (actionContext.Request.Content != null) {
                    byte[] content = actionContext.Request.Content.ReadAsByteArrayAsync().Result;
                    if (!restExposeContext.IsRequestBinary) {
                        try {
                            string charset = RestServiceHttpUtils.TryGetRequestEncoding(actionContext.Request, DefaultEncoding);
                            Encoding requestEncoding = Encoding.GetEncoding(charset);
                            requestTrace.AppendLine(requestEncoding.GetString(content));
                        } catch {
                            WriteBinaryData(requestTrace);
                        }
                    } else {
                        WriteBinaryData(requestTrace);
                    }
                }

                restExposeContext.RequestTrace = requestTrace.ToString();
            }
        }

        public static void LogResponse(HttpActionExecutedContext actionExecutedContext, string errorId = null) {
            if (actionExecutedContext == null || actionExecutedContext.Response == null) {
                return;
            }

            AppInfo appInfo = AppInfo.GetAppInfo();
            HttpContext context = appInfo.Context;
            RESTExposeContext restExposeContext = GetLoggingContext();

            if (restExposeContext != null &&
                !restExposeContext.AlreadyLogged &&
                ((!string.IsNullOrEmpty(restExposeContext.ErrorLogId) || (!appInfo.SelectiveLoggingEnabled || appInfo.Properties.AllowLogging)) && restExposeContext.LogRequest)) {

                TimeSpan duration = DateTime.Now.Subtract(restExposeContext.StartTime);
                int eSpaceId = appInfo.eSpaceId;
                int tenantId = appInfo.Tenant?.Id ?? 0;
                string errorIdToLog = errorId ?? restExposeContext.ErrorLogId;
                string source = RuntimePlatformUtils.GetRequestSourceForLogging();
                string id = null;

                if (restExposeContext.LogTo == LogTo.RESTExpose) {
                    id = IntegrationLog.StaticWrite(appInfo, DateTime.Now, (int)duration.TotalMilliseconds, source, null, restExposeContext.ServiceName + "." + restExposeContext.ActionName, "REST (Expose)", errorIdToLog, true);
                } else {
                    HeContext heContext = appInfo.OsContext;
                    string loginId = heContext?.Session?.NewRuntimeLoginInfo?.LoginId ?? string.Empty;
                    int userId = heContext?.Session?.NewRuntimeLoginInfo?.UserId ?? 0;
                    string username = heContext?.Session?.NewRuntimeLoginInfo?.Username ?? string.Empty;

                    if (userId == 0) {
                        userId = restExposeContext.RequesterUserId;
                        username = restExposeContext.RequesterUsername;
                        loginId = restExposeContext.RequesterLoginId;
                    }

                    if (restExposeContext.LogTo == LogTo.ScreenServices) {
                        id = MobileRequestLog.StaticWrite(appInfo, DateTime.Now, restExposeContext.ScreenName, restExposeContext.ActionName, source, (int)duration.TotalMilliseconds, RuntimeEnvironment.MachineName, errorIdToLog, loginId, userId, username);
                    } else if (restExposeContext.LogTo == LogTo.ServiceAPIs) {
                        id = ServiceAPILog.StaticWrite(
                            appInfo: appInfo,
                            sessionInfo: heContext?.Session,
                            instant: DateTime.Now,
                            loginId: loginId,
                            errorId: errorIdToLog,
                            executedBy: RuntimeEnvironment.MachineName,
                            action: restExposeContext.ServiceAPIMethodName,
                            duration: (int)duration.TotalMilliseconds,
                            source: source,
                            endpoint: Path.Combine(appInfo.eSpaceName, "ServiceAPI", restExposeContext.ServiceAPIMethodName),
                            originalRequestKey: restExposeContext.OriginalRequestKey
                        );
                    }
                }

                bool withError = !string.IsNullOrEmpty(errorIdToLog);

                if (actionExecutedContext != null && restExposeContext.RequestTrace != null && (restExposeContext.TraceAll || (restExposeContext.TraceErrors && withError))) {
                    StringBuilder responseTrace = new StringBuilder();
                    responseTrace.AppendLine(context.Request.ServerVariables["SERVER_PROTOCOL"] + " " + ((int)actionExecutedContext.Response.StatusCode).ToString() + " " + actionExecutedContext.Response.ReasonPhrase);
                    WriteResponseHeaders(responseTrace, context, actionExecutedContext);

                    if (actionExecutedContext.Response != null && actionExecutedContext.Response.Content != null) {
                        if (!restExposeContext.IsResponseBinary) {
                            try {
                                byte[] content = actionExecutedContext.Response.Content.ReadAsByteArrayAsync().Result;
                                string charset = RestServiceHttpUtils.TryGetResponseEncoding(actionExecutedContext.Response, DefaultEncoding);
                                Encoding requestEncoding = Encoding.GetEncoding(charset);
                                responseTrace.AppendLine(requestEncoding.GetString(content));
                            } catch {
                                WriteBinaryData(responseTrace);
                            }
                        } else {
                            WriteBinaryData(responseTrace);
                        }
                    }

                    int tenantIdToDetailLog = (appInfo.Tenant != null ? appInfo.Tenant.Id : 0);
                    string detail = $"{restExposeContext.RequestTrace}\n\n{responseTrace.ToString()}";
                    string detailLabel = "HTTP Trace";

                    StaticDetailLog(restExposeContext.LogTo, id, DateTime.Now, tenantIdToDetailLog, string.Empty, detail, detailLabel);
                }

                restExposeContext.AlreadyLogged = true;
            }
        }

        private static void WriteResponseHeaders(StringBuilder trace, HttpContext httpContext, HttpActionExecutedContext actionExecutedContext) {
            // HttpContext headers
            if (HttpRuntime.UsingIntegratedPipeline) {
                foreach (var headerName in httpContext.Response.Headers.AllKeys) {
                    foreach (string headerValue in httpContext.Response.Headers.GetValues(headerName)) {
                        trace.AppendLine($"{ headerName }: { headerValue }");
                    }
                }
            }

            // HttpActionExecutedContext headers
            if (actionExecutedContext.Response != null && actionExecutedContext.Response.Content != null) {
                foreach (var header in actionExecutedContext.Response.Content.Headers) {
                    foreach (string headerValue in header.Value) {
                        trace.AppendLine($"{header.Key}: {headerValue}");
                    }
                }

                foreach (var header in actionExecutedContext.Response.Headers) {
                    foreach (string headerValue in header.Value) {
                        trace.AppendLine($"{header.Key}: {headerValue}");
                    }
                }
            }
        }

        private static void WriteRequestHeaders(StringBuilder trace, HttpContext httpContext) {
            // HttpContext
            foreach (string headerName in httpContext.Request.Headers.Keys) {
                foreach (string headerValue in httpContext.Request.Headers.GetValues(headerName)) {
                    trace.AppendLine($"{ headerName }: { headerValue }");
                }
            }
        }

        private static void WriteBinaryData(StringBuilder requestTrace) {
            requestTrace.AppendLine("<BINARY DATA>");
        }

        private static void StaticDetailLog(LogTo logTo, string id, DateTime instant, int tenant_Id, string message, string detail, string detailLabel) {
            switch (logTo) {
                case LogTo.RESTExpose:
                    IntDetailLog.StaticWrite(id, instant, tenant_Id, message, detail, detailLabel);
                    break;
                case LogTo.ScreenServices:
                    MRDetailLog.StaticWrite(id, instant, tenant_Id, message, detail, detailLabel);
                    break;
                case LogTo.ServiceAPIs:
                    ServiceAPIDetailLog.StaticWrite(id, instant, tenant_Id, message, detail, detailLabel);
                    break;
                default:
                    break;
            }
        }
    }
}
