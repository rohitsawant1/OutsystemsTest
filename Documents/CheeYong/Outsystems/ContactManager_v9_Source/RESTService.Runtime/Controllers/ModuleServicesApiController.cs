/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Linq;
using System.Net;
using System.Text;
using System.Web.Http;
using OutSystems.HubEdition.RuntimePlatform;
using OutSystems.HubEdition.RuntimePlatform.Log;
using OutSystems.HubEdition.RuntimePlatform.NewRuntime.Authentication;
using OutSystems.Internal.Db;
using OutSystems.RuntimeCommon;
using OutSystems.HubEdition.RuntimePlatform.NewRuntime;
using OutSystems.RESTService.ErrorHandling;
using System.IO;
using OutSystems.ObjectKeys;

namespace OutSystems.RESTService.Controllers {
    public abstract partial class ModuleServicesApiController : RestServiceApiController {

        private readonly ApplicationInfoGenerator applicationInfoGenerator = new ApplicationInfoGenerator();
        protected virtual ApplicationInfoGenerator ApplicationInfoGenerator {
            get {
                return applicationInfoGenerator;
            }
        }

        private Payload.ModuleVersionInfo GetModuleVersionInfo() {
            return new Payload.ModuleVersionInfo { VersionToken = RunningInfo.ESpaceVersionToken };
        }

        protected ApplicationInfo GetPayload(PayloadInfo payloadInfo) {
            var manifestContent = GetManifest(payloadInfo.EspaceName);
            var entityModuleNames = GetEntityModuleNames(payloadInfo.EspaceName);
            var moduleDefinitionsContent = GetModuleDefinitions(payloadInfo.EspaceName);

            using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetReadOnlyTransaction()) {
                return ApplicationInfoGenerator.GenerateApplicationInfo(trans, RuntimeSettingsProvider.Instance, manifestContent, entityModuleNames, moduleDefinitionsContent,
                    payloadInfo.EspaceName, payloadInfo.EspaceId, payloadInfo.EspaceVersionId, payloadInfo.EspaceUId, payloadInfo.StaticEntitiesKeys);
            }
        }

        private string GetTextResource(string espaceName, string resourceName, bool enableWarnings) {
            var resourceBinary = RuntimePlatformUtils.TryGetResourceBinary(resourceName);
            if (resourceBinary != null && resourceBinary.Length > 0) {
                return Encoding.UTF8.GetStringWithoutBOM(resourceBinary);
            }

            if (enableWarnings) {
                OSTrace.Warning("Could not get " + resourceName + " file for '{0}'.", espaceName);
            }

            return null;
        }

        protected virtual string GetManifest(string espaceName) {
            return GetTextResource(espaceName, Constants.PrecacheManifestFileName, /*enableWarnings*/true);
        }

        protected virtual string GetModuleDefinitions(string espaceName) {
            return GetTextResource(espaceName, Constants.ModuleDefinitionFileName, /*enableWarnings*/true);
        }

        protected virtual string[] GetEntityModuleNames(string espaceName) {
            var entityModulesContent = GetTextResource(espaceName, Constants.EntityModulesManifestFileName, /*enableWarnings*/false);

            if (entityModulesContent != null) {
                return entityModulesContent.Split(new string[] { Environment.NewLine }, StringSplitOptions.None);
            } else {
                return new string[0];
            }
        }

        private static volatile ApplicationInfo payloadCache = null;
        protected virtual ApplicationInfo GetCachedPayload(AppInfo appInfo) {
            if (payloadCache == null) {
                lock (typeof(ModuleServicesApiController)) {
                    if (payloadCache == null) {
                        var payloadInfo = new PayloadInfo(appInfo.eSpaceId, appInfo.eSpaceVersionId, appInfo.eSpaceUID, appInfo.eSpaceName, appInfo.Properties.ClientSideTracingEnabled, appInfo.GetApplicationDefaultTimeout(), appInfo.StaticEntitiesKeys);
                        payloadCache = GetPayload(payloadInfo);
                    }
                }
            }
            
            UpdateNonCacheablePropeties(payloadCache, appInfo.Properties.ClientSideTracingEnabled, appInfo.GetApplicationDefaultTimeout());
            return payloadCache;
        }

        private void UpdateNonCacheablePropeties(ApplicationInfo payload, bool hasTracingEnabled, int applicationDefaultTimeout) {
            payload.Data.HasTracingEnabled = hasTracingEnabled ? true : (bool?)null;
            payload.Data.ApplicationDefaultTimeout = applicationDefaultTimeout;
        }

        IHttpActionResult GetResponse<TResponseType>(Func<AppInfo, TResponseType> responseGetter) {

            AppInfo appInfo = null;
            HeContext heContext = null;

            try {

                appInfo = AppInfo.GetAppInfo();
                if (!appInfo.IsApplicationEnabled) {
                    return GetErrorResponseResult(ApplicationNotEnabledMessage, HttpStatusCode.ServiceUnavailable);
                }
                ValidateRequestSecurity();

                heContext = appInfo.OsContext;
                
                return GetResponseResult(typeof(TResponseType), responseGetter(appInfo));
            } catch (Exception ex) {
                DatabaseAccess.FreeupResources(false);
                
                var licensingException = ex as LicensingException;
                if (licensingException != null) {
                    // Error was already logged inside AppInfo's GetAppInfo
                    return GetErrorResponseResult(ApplicationNotEnabledMessage, HttpStatusCode.ServiceUnavailable);
                }

                var exposeRestException = ex as ExposeRestException;
                if (exposeRestException != null) {
                    ErrorLog.LogApplicationError(exposeRestException, heContext, "Module Services");
                    return GetErrorResponseResult(ex.Message, exposeRestException.StatusCode);
                }
                
                ErrorLog.LogApplicationError(ex, heContext, "Module Services");
                return GetErrorResponseResult("Internal Server Error", HttpStatusCode.InternalServerError);
            }
        }

        protected IHttpActionResult endpoint(string endpointName) {
            return GetResponse(appInfo => GetCachedPayload(appInfo));
        }

        public virtual IHttpActionResult Ping() {
            AppInfo appInfo = null;
            try {
                appInfo = AppInfo.GetAppInfo();

                if (!IsApplicationEnabled(appInfo)) {
                    return GetErrorResponseResult(ApplicationNotEnabledMessage, HttpStatusCode.ServiceUnavailable);
                }

                ValidateRequestSecurity();

                if (appInfo != null) {
                    GetCachedPayload(appInfo); //ensure that payload is cached to speedup first request time
                }
            } catch (Exception ex) {

                DatabaseAccess.FreeupResources(false);

                var licensingException = ex as LicensingException;
                if (licensingException != null) {
                    // Error was already logged inside AppInfo's GetAppInfo
                    return GetErrorResponseResult(ApplicationNotEnabledMessage, HttpStatusCode.ServiceUnavailable);
                }

                var exposeRestException = ex as ExposeRestException;
                if (exposeRestException != null) {
                    ErrorLog.LogApplicationError(exposeRestException, appInfo, null, "Module Services");
                    return GetErrorResponseResult(exposeRestException.Message, exposeRestException.StatusCode);
                }

                ErrorLog.LogApplicationError(ex, appInfo, null, "Module Services");
                return GetErrorResponseResult("Internal Server Error", HttpStatusCode.InternalServerError);
            }

            return Ok();
        }

        public virtual IHttpActionResult ModuleVersionInfo() {
            return GetResponse(appInfo => GetModuleVersionInfo());
        }


        private static readonly string[] allowedMessageTypes = { "USER", "WARNING" };
        public static readonly int maxLogsPerBatch = 10;

        private static readonly object logsRateLockObj = new object();
        private static DateTime currentLogsRatePeriodStart = DateTime.MinValue;
        private static int currentLogsRatePeriodCount;

        protected static void ResetLogsCount() {
            currentLogsRatePeriodCount = 0;
        }

        private static int? logsRateLimitCache;
        private static int GetLogsRateLimit() {
            if (logsRateLimitCache == null) {
                logsRateLimitCache = RuntimePlatformSettings.Misc.MaxLogsPerSecondInLogsEndpoint.GetValue();
            }
            return logsRateLimitCache.Value;
        }

        private int CountNumberOfLogs(Payload.LogMessage[] logs, bool allowAuditing, bool clientTracingEnabled) {
            // ignore traces if the ClientSideTracing property is enabled
            return logs.Where(log => allowAuditing || !log.LogType.EqualsIgnoreCase("general"))
                       .Where(log => !clientTracingEnabled || !log.LogType.EqualsIgnoreCase("trace")).Count();
        }

        private bool CanProcessLogRequest(Payload.LogMessage[] logs, bool allowAuditing, bool clientTracingEnabled) {
            int numberOfLogs = CountNumberOfLogs(logs, allowAuditing, clientTracingEnabled);

            var rateLimit = GetLogsRateLimit();
            if (rateLimit > 0) {
                lock (logsRateLockObj) {
                    var currentTime = DateTime.UtcNow;
                    if (currentLogsRatePeriodStart.AddSeconds(1) < currentTime) {
                        currentLogsRatePeriodStart = currentTime;
                        currentLogsRatePeriodCount = numberOfLogs;
                        return true;
                    } else {
                        currentLogsRatePeriodCount += numberOfLogs;
                        return rateLimit > currentLogsRatePeriodCount;
                    }
                }
            } else {
                return rateLimit < 0; // no limit if < 0, no logs allowed if == 0
            }
        }

        protected virtual bool IsApplicationEnabled(AppInfo info) {
            return info != null && info.IsApplicationEnabled;
        }

        private string ProcessLogExtra(Payload.LogMessage log) {
            StringBuilder environmentInformation = new StringBuilder();

            if (log.Extra != null) {
                foreach (var extraInfo in log.Extra) {
                    environmentInformation.Append(Environment.NewLine + extraInfo.Key + ": " + extraInfo.Value);
                }
            }

            return environmentInformation.ToString();
        }

        public virtual IHttpActionResult Log(Payload.LogMessage[] logs, long clientTimeInMillis) {
            AppInfo appInfo = null;
            HeContext context = null;
            string sessionId;
            int espaceId = 0;
            string eSpaceName = null;
            string applicationName = null;
            ObjectKey applicationKey = null;
            int tenantId = 0;
            int userId = 0;
            string username = null;

            try {
                appInfo = AppInfo.GetAppInfo();
                if (!IsApplicationEnabled(appInfo)) {
                    return GetErrorResponseResult(ApplicationNotEnabledMessage, HttpStatusCode.ServiceUnavailable);
                }

                ValidateRequestSecurity();

                if (logs == null || logs.Length == 0) {
                    return Ok(); // Nothing to log so we can return already
                }

                GatherLogInformation(/*updateSessionFromCookie*/true, appInfo, out context, out espaceId, out eSpaceName,
                    out tenantId, out applicationName, out applicationKey, out sessionId, out userId, out username);
                var allowAuditing = appInfo == null /*because of tests */ || appInfo.Properties.AllowAuditing;
                var clientTraceEnabled = appInfo == null/*because of tests */ || appInfo.Properties.ClientSideTracingEnabled;

                if (logs.Length > maxLogsPerBatch) {
                    return GetErrorResponseResult("Too many logs in a batch.", HttpStatusCode.ServiceUnavailable);
                }

                if (!CanProcessLogRequest(logs, allowAuditing, clientTraceEnabled)) {
                    return GetErrorResponseResult("Too many requests", HttpStatusCode.ServiceUnavailable);
                }

                TimeSpan dateDiff = TimeSpan.Zero;
                if (clientTimeInMillis > 0) {
                    dateDiff = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc).AddMilliseconds(clientTimeInMillis).Subtract(DateTime.UtcNow);
                }

                foreach (var log in logs) {
                    string logType = log.LogType;

                    DateTime date = DateTime.Parse(log.Instant);
                    if (clientTimeInMillis > 0) {
                    	date = Conversions.DateTimeToUniversal(date).Subtract(dateDiff);
                    }
                    date = Conversions.DateTimeToLocal(date);

                    if (StringUtils.EqualsIgnoreCase(logType, "general")) {
                        if (allowAuditing) {
                            WriteToGeneralLog(log, date, sessionId, espaceId, tenantId, userId);
                        }
                    } else if (StringUtils.EqualsIgnoreCase(logType, "trace")) {
                        if (clientTraceEnabled) {
                            OSTrace.Debug("[" + date.ToString("yyyy-MM-dd HH:mm:ss.ffff") + "] " + log.Module_Name + " - " + log.Message);
                        }
                    } else if (StringUtils.EqualsIgnoreCase(logType, "error")) {
                        string environmentInformation = ErrorLog.GetStackEnvironmentInfo(appInfo, context);
                        environmentInformation += ProcessLogExtra(log);
                        environmentInformation += Environment.NewLine + "Client-Side Log";
                        if (log.ErrorStack != null) { // Limit stack to the lower storage size
                            log.ErrorStack = log.ErrorStack.Left(ErrorLog.MAX_STACK_SMALL_STORAGE_SIZE);
                        }
                        ErrorLog.StaticWrite(date, sessionId, espaceId, tenantId, userId, log.Message, log.ErrorStack, environmentInformation, log.Module_Name,
                            eSpaceName: eSpaceName, applicationName: applicationName, applicationKey: applicationKey, username: username);
                    } else {
                        ErrorLog.LogApplicationError("Invalid log type: " + logType, /*stack*/(string) null, context, "Module Services");
                        return GetErrorResponseResult("Invalid log type", HttpStatusCode.InternalServerError);
                    }
                }

            } catch (Exception ex) {
                DatabaseAccess.FreeupResources(false);

                var licensingException = ex as LicensingException;
                if (licensingException != null) {
                    // Error was already logged inside AppInfo's GetAppInfo
                    return GetErrorResponseResult(ApplicationNotEnabledMessage, HttpStatusCode.ServiceUnavailable);
                }

                var exposeRestException = ex as ExposeRestException;
                if (exposeRestException != null) {
                    ErrorLog.LogApplicationError(exposeRestException, appInfo, context, "Module Services");
                    return GetErrorResponseResult(exposeRestException.Message, exposeRestException.StatusCode);
                }
                
                ErrorLog.LogApplicationError(ex, appInfo, context, "Module Services");
                return GetErrorResponseResult("Internal Server Error", HttpStatusCode.InternalServerError);
            }

            return Ok();
        }

        private void WriteToGeneralLog(Payload.LogMessage log, DateTime instant, string sessionId, int espaceId, int tenantId, int userId) {
            string messageType = allowedMessageTypes.FirstOrDefault(allowedType => allowedType.EqualsIgnoreCase(log.Message_Type)) ?? "USER";
            GeneralLog.StaticWrite(instant, sessionId, espaceId, tenantId, userId, log.Message, messageType, log.Module_Name, "");
        }

        private void GatherLogInformation(bool updateSessionFromCookie, AppInfo appInfo, out HeContext context,
            out int espaceId, out string eSpaceName, out int tenantId, out string applicationName, out ObjectKey applicationKey,
            out string sessionId, out int userId, out string username) {

            context = null;
            sessionId = null;
            espaceId = 0;
            eSpaceName = null;
            tenantId = 0;
            applicationName = null;
            applicationKey = null;
            userId = 0;
            username = null;

            if (appInfo != null) {
                if (updateSessionFromCookie) {
                    try {
                        // Update login information if necessary
                        var loginInfo = new MobileLoginInfoEndpoint(appInfo, appInfo.GetMobileLoginConfigurations()).ReadLoginInfoFromRequest();
                        loginInfo.Validate();
                        userId = loginInfo.UserId;
                        tenantId = loginInfo.TenantId;
                        username = loginInfo.Username;
                    } catch {
                    }
                }

                try {
                    espaceId = appInfo.eSpaceId;
                    eSpaceName = appInfo.eSpaceName;
                    applicationName = appInfo.ApplicationName;
                    applicationKey = appInfo.ApplicationUIDAsKey;
                    context = appInfo.OsContext;
                } catch { }

                if (context != null) {
                    try { sessionId = context.Session.SessionID; } catch { }
                }
            }
        }

        public virtual IHttpActionResult CheckRequestSuspendedByDebugger(string requestToken) {

            AppInfo appInfo = null;
            HeContext context = null;
            try {
                appInfo = AppInfo.GetAppInfo();
                if (appInfo == null || !appInfo.IsApplicationEnabled) {
                    return GetErrorResponseResult(ApplicationNotEnabledMessage, HttpStatusCode.ServiceUnavailable);
                }

                ValidateRequestSecurity();

                context = appInfo.OsContext;

            var isRequestSupended = DebuggerHelper.HasSuspendedThreadWithRequestToken(requestToken);
            return GetResponseResult(typeof(bool), isRequestSupended);
            } catch (Exception ex) {
                DatabaseAccess.FreeupResources(false);

                var licensingException = ex as LicensingException;
                if (licensingException != null) {
                    return GetErrorResponseResult(ApplicationNotEnabledMessage, HttpStatusCode.ServiceUnavailable);
                }

                var exposeRestException = ex as ExposeRestException;
                if (exposeRestException != null) {
                    ErrorLog.LogApplicationError(exposeRestException, appInfo, context, "Module Services");
                    return GetErrorResponseResult(exposeRestException.Message, exposeRestException.StatusCode);
                }

                ErrorLog.LogApplicationError(ex, appInfo, context, "Module Services");
                return GetErrorResponseResult("Internal Server Error", HttpStatusCode.InternalServerError);
            }
        }
    }
}
