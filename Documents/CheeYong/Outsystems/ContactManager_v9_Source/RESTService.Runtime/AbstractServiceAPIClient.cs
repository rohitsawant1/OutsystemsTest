/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using OutSystems.HubEdition.RuntimePlatform;
using OutSystems.HubEdition.RuntimePlatform.Internal;
using OutSystems.HubEdition.RuntimePlatform.Log;
using OutSystems.ObjectKeys;
using OutSystems.RESTService.Controllers;
using OutSystems.RuntimeCommon;
using static OutSystems.HubEdition.RuntimePlatform.Internal.SecurityTokenAPI;
using static OutSystems.RESTService.Controllers.CoreServicesApiController.Payload;

namespace OutSystems.RESTService {

    public abstract class AbstractServiceAPIClient { // TODO: to be moved on #ABE-823

        private const int DefaultTimeoutInSeconds = 100;
        private const string AuthorizationTokenType = "Bearer ";
        private const string AuthorizationHeaderKey = "Authorization";
        
        public static RestServiceControllerConfiguration ServiceConfiguration { get; } = new RestServiceControllerConfiguration();

        protected static ObjectKey ConsumerModuleKey {
            get { return AppInfo.GetAppInfo().eSpaceUIDAsKey; }
        }

        protected readonly ObjectKey ProducerModuleKey;
        protected readonly string ProducerModuleName;

        protected AbstractServiceAPIClient(ObjectKey producerModuleKey, string producerModuleName) {
            ProducerModuleKey = producerModuleKey;
            ProducerModuleName = producerModuleName;
        }

        protected HttpWebRequest BuildServiceAPIMethodRequest(HeContext context, string sapimName, object inputs) {
            var zoneSettings = DeploymentZoneResolution.ByModuleKey(ProducerModuleKey);
            var securityProtocol = zoneSettings.EnableHttps ? "https" : "http";
            var sapimEndpoint = $"{securityProtocol}://{zoneSettings.Address}/{ProducerModuleName}/serviceapi/{UrlEncode(sapimName)}";
            string httpMethod = "POST";
            var headers = new Dictionary<string, string>();
            headers.Add("User-Agent", "OutSystemsPlatform");
            headers.Add("Content-Type", "application/json");
            headers.Add("Content-Language", context.CurrentLocale);

            var requestPayload = new CoreServicesApiController.Payload.RequestPayload();
            requestPayload.RequestKey = RuntimePlatformUtils.GetRequestTracer()?.RequestKey ?? Guid.NewGuid().ToString();
            requestPayload.InputParameters = JObject.FromObject(inputs);
            string payloadString = JsonConvert.SerializeObject(requestPayload, Formatting.None);

            var stringToken = SecurityTokenAPI.GenerateJWTTokenString(
                settingsProvider: RuntimeSettingsProvider.Instance,
                consumerModuleKey: ObjectKeyUtils.DatabaseValue(ConsumerModuleKey),
                producerModuleKey: ObjectKeyUtils.DatabaseValue(ProducerModuleKey),
                userId: context.Session.UserId,
                tenantId: context.Session.TenantId,
                requestHash: SecurityTokenAPI.GeneratePayloadHash(RuntimeSettingsProvider.Instance, payloadString),
                requestLifetime: RuntimePlatformSettings.ServiceAPIs.RequestLifetime.GetValue()
            );

            headers.Add(AuthorizationHeaderKey, AuthorizationTokenType + stringToken);

            var request = (HttpWebRequest)HttpWebRequest.Create(sapimEndpoint);
            request.Method = httpMethod;
            // set the timeout for the request            
            request.Timeout = DefaultTimeoutInSeconds * 1000;

            // set headers in request
            foreach (var header in headers.Keys) {
                SetRequestHeader(request, header, headers[header]);
            }

            // set request body
            using (Stream requestStream = request.GetRequestStream()) {
                var requestBody = Encoding.UTF8.GetBytes(payloadString);
                requestStream.Write(requestBody, 0, requestBody.Length);
            }

            return request;
        }

        // TODO ABE: these helper methods were stolen from the OutSystems.REST.HttpHelper class. We need to move the class to a common place accessible to rest, sapim, etc.
        private static string UrlEncode(String urlToEncode) {
            return Uri.EscapeDataString(Uri.UnescapeDataString(urlToEncode));
        }

        private static void SetRequestHeader(HttpWebRequest request, String headerName, String headerValue) {
            switch (headerName.ToLowerInvariant()) {
                case "accept":
                request.Accept = headerValue;
                break;
                case "expect":
                request.Expect = headerValue;
                break;
                case "referer":
                request.Referer = headerValue;
                break;
                case "user-agent":
                request.UserAgent = headerValue;
                break;
                case "if-modified-since":
                request.IfModifiedSince = DateTime.Parse(headerValue);
                break;
                case "content-type":
                request.ContentType = headerValue;
                break;
                case "host":
                request.Host = headerValue;
                break;
                case "date":
                request.Date = DateTime.Parse(headerValue);
                break;
                case "transfer-encoding":   // useful for sending compressed data or data in chuncks // return request.SendChunked = true; request.TransferEncoding = headerValue;
                case "connection":          // only used in HTTP 1.0
                case "content-length":      // this headerValue should be computed
                case "range":               // only useful for partial downloads
                case "proxy-connection":    // header equivalent to the connection header (no way to set it in .NET)
                break;
                default:
                request.Headers.Set(headerName, headerValue);
                break;
            }
        }
        
        protected static Exception ConvertPayloadToException(FailResponsePayload exception) {
            switch (exception.Exception.Name) {
                case "NotRegisteredException":
                    return new NotRegisteredException(exception.Exception.Message);
                case "InvalidLoginException":
                    return new InvalidLoginException(exception.Exception.Message);
                case "AbortActivityChangeException":
                    return new AbortActivityChangeException(exception.Exception.Message);
                case "SecurityException":
                    return new SecurityException(exception.Exception.Message);
                case "DataBaseException":
                    return new DataBaseException(exception.Exception.Message);
                case "UserException":
                    return new UserException(exception.Exception.Message);
                case "CommunicationException":
                    return new CommunicationException(exception.Exception.Message);
                default:
                    return new Exception(exception.Exception.Message);
            }
        }

        protected static Exception ProcessErrorResponse(WebException e) {
            HttpWebResponse response = (HttpWebResponse) e.Response;

            if (response != null && response.StatusCode == HttpStatusCode.InternalServerError) {
            	string responseString = FetchResponseString(response);

                try {
                    FailResponsePayload exceptionPayload = JsonConvert.DeserializeObject<FailResponsePayload>(responseString);
                    return ConvertPayloadToException(exceptionPayload);
                } catch (Exception parseException) {
                    return new CommunicationException($"{e.Message} Failed to parse the error response.", parseException);
                }
            } else {
                return new CommunicationException(e.Message);
            }
        }

        protected static string FetchResponseString(HttpWebResponse response) {
            using (StreamReader reader = new StreamReader(response.GetResponseStream())) {
                return reader.ReadToEnd();
            }
        }

        protected bool IsResponseValid(HttpWebResponse response, string responseString) {
            ResponseSecurityTokenPayload payload = null;
            var authorizationHeader = response.Headers[AuthorizationHeaderKey];
            if(authorizationHeader == null) {
                OSTrace.Error("Authorization header is null");
                return false;
            }

            var stringToken = authorizationHeader.RemoveIfStartsWith(AuthorizationTokenType);

            payload = SecurityTokenAPI.GetValidatedToken<ResponseSecurityTokenPayload>(RuntimeSettingsProvider.Instance, stringToken);
            if(payload == null) {
                return false;
            }
            return ValidateConsumerAndProducerKeys(payload.ConsumerKey, payload.ProducerKey) &&
                IsResponsePayloadValid(responseString, payload);
        }

        private static bool IsResponsePayloadValid(string responseString, ResponseSecurityTokenPayload authorizationPayload) {
            bool isResponseValid = SecurityTokenAPI.ValidatePayloadHash(RuntimeSettingsProvider.Instance, responseString, authorizationPayload.ResponseHash);
            if (!isResponseValid) {
                OSTrace.Error("Response hash doesn't match the response. Response may have been tampered with.");
            }
            return isResponseValid;
        }

        private bool ValidateConsumerAndProducerKeys(string consumerKey, string producerKey) {
            bool consumerKeysAreValid = ObjectKey.Parse(consumerKey) == ConsumerModuleKey;
            bool producerKeysAreValid = ObjectKey.Parse(producerKey) == ProducerModuleKey;

            if (!consumerKeysAreValid) {
                OSTrace.Error($"Consumer Module keys don't match. Expected '{ObjectKeyUtils.DatabaseValue(ConsumerModuleKey)}' but was '{consumerKey}'");
            }
            if (!producerKeysAreValid) {
                OSTrace.Error($"Producer Module keys don't match. Expected '{ObjectKeyUtils.DatabaseValue(ProducerModuleKey)}' but was '{producerKey}'");
            }

            return producerKeysAreValid && consumerKeysAreValid;
        }
    }
}
