/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Threading;
using System.Web.Http;
using System.Web.Http.Controllers;
using System.Web.Http.Dispatcher;
using System.Web.Http.Filters;
using OutSystems.HubEdition.RuntimePlatform.Extensibility;
using OutSystems.HubEdition.RuntimePlatform.NewRuntime;
using OutSystems.RESTService.Controllers;
using OutSystems.RESTService.ErrorHandling;
using OutSystems.RESTService.Formatters;
using OutSystems.RuntimeCommon;

namespace OutSystems.RESTService {
    public class ServiceConfiguration : LifecyleListener {
        // This Selector is here to override a limitation from DefaultHttpControllerSelector, that does not allow Classes with same name to be Controllers

        public class NamespaceAwareHttpControllerSelector : DefaultHttpControllerSelector {

            private readonly HttpConfiguration configuration;
            private readonly Lazy<Dictionary<string, HttpControllerDescriptor>> controllers;

            public NamespaceAwareHttpControllerSelector(HttpConfiguration config) : base(config) {
                configuration = config;
                controllers = new Lazy<Dictionary<string, HttpControllerDescriptor>>(InitializeControllerDictionary, LazyThreadSafetyMode.PublicationOnly); // Should not be accessed in multiple threads in initialization, but setting it to PublicationOnly just so we never cache an exception
            }

            private Dictionary<string, HttpControllerDescriptor> InitializeControllerDictionary() {
                var dictionary = new Dictionary<string, HttpControllerDescriptor>(StringComparer.OrdinalIgnoreCase);

                IAssembliesResolver assembliesResolver = configuration.Services.GetAssembliesResolver();
                IHttpControllerTypeResolver controllersResolver = configuration.Services.GetHttpControllerTypeResolver();

                ICollection<Type> controllerTypes = controllersResolver.GetControllerTypes(assembliesResolver);

                foreach (Type t in controllerTypes) {
                    dictionary[t.FullName] = new HttpControllerDescriptor(configuration, t.Name, t);
                }

                return dictionary;
            }

            public override IDictionary<string, HttpControllerDescriptor> GetControllerMapping() {
                return controllers.Value;
            }
        }

        // This Resolver objective is to prevent the default resolver (WebHostHttpControllerTypeResolver) from caching an empty list of controllers
        // Since the Temporary ASP.NET Files folder is preserved between publishes, the cache is kept and it would not recover between publishes
        private class RESTServiceControllerTypeResolver : DefaultHttpControllerTypeResolver {
            public override ICollection<Type> GetControllerTypes(IAssembliesResolver assembliesResolver) {
                HashSet<Type> allControllers = base.GetControllerTypes(assembliesResolver).ToHashSet();
                Dictionary<string, BinaryContentUtils.DbBinaryConfig> proxyBinaryConfigs = new Dictionary<string, BinaryContentUtils.DbBinaryConfig>();

                // load controllers from dependencies
                HashSet<IScreenControllerProxy> visited = new HashSet<IScreenControllerProxy>();
                foreach (var controller in allControllers.ToArray()) {
                    var controllerProxy = ScreenServicesApiController.TryGetControllerProxy(controller);
                    if (controllerProxy != null) {
                        CollectDependenciesControllerTypesAndBinaryConfigs(controllerProxy, visited, allControllers, proxyBinaryConfigs);
                    }
                }

                ScreenServicesApiController.SetDatabaseBinaries(proxyBinaryConfigs);

                return allControllers;
            }
            
            private void CollectDependenciesControllerTypesAndBinaryConfigs(IScreenControllerProxy visiting, HashSet<IScreenControllerProxy> visited, HashSet<Type> allControllers, Dictionary<string, BinaryContentUtils.DbBinaryConfig> proxyBinaryConfigs) {
                if (visited.Add(visiting)) {
                    allControllers.Add(visiting.GetControllerType());

                    var newValues = visiting.GetDbBinaryConfigs().Where(kvp => !proxyBinaryConfigs.ContainsKey(kvp.Key));
                    proxyBinaryConfigs.AddRange(newValues);
                    visiting.EnsureInitialized();
                    foreach (var childControllerProxy in visiting.GetChildControllers()) {
                        CollectDependenciesControllerTypesAndBinaryConfigs(childControllerProxy, visited, allControllers, proxyBinaryConfigs);
                    }
                }
            }
        }

        private class RESTServiceAssembliesResolver : DefaultAssembliesResolver {
            private const string AssembliesSetting = "OutSystems.RESTService.Assemblies";

            public override ICollection<Assembly> GetAssemblies() {

                String assembliesConfig = System.Configuration.ConfigurationManager.AppSettings[AssembliesSetting];
                if (assembliesConfig != null) {
                    var assembliesToLoad = assembliesConfig.Split(';');
                    return assembliesToLoad.Select(name => Assembly.Load(name)).ToArray();
                }

                return base.GetAssemblies(); // base class will scan all assemblies in bin directory as fallback
            }
        }

        private class RESTServiceFilterProvider : IFilterProvider {
            public IEnumerable<FilterInfo> GetFilters(HttpConfiguration configuration, HttpActionDescriptor actionDescriptor) {
                if (typeof(RestServiceApiController).IsAssignableFrom(actionDescriptor.ControllerDescriptor.ControllerType)) {
                    // expose rest error handling register
                    yield return new FilterInfo(ExposeRestExceptionFilter.Instance, FilterScope.Global);
                    // register validation filter
                    yield return new FilterInfo(ValidateRequestFilter.Instance, FilterScope.Global);
                    //
                    yield return new FilterInfo(NotAcceptableFormatterHandler.Instance, FilterScope.Global);
                }
            }
        }

        private static bool routesInitialized;
        public static void Initialize() {
            if (!routesInitialized) {
                // custom assembly with controllers locator (because we have them in bin2 folder, instead of bin folder)
                GlobalConfiguration.Configuration.Services.Replace(typeof(IAssembliesResolver), new RESTServiceAssembliesResolver());
                GlobalConfiguration.Configuration.Services.Replace(typeof(IHttpControllerTypeResolver), new RESTServiceControllerTypeResolver());
                GlobalConfiguration.Configuration.Services.Replace(typeof(IHttpControllerSelector), new NamespaceAwareHttpControllerSelector(GlobalConfiguration.Configuration));
                GlobalConfiguration.Configuration.Services.Add(typeof(IFilterProvider), new RESTServiceFilterProvider());

                GlobalConfiguration.Configuration.EnableCors();

                // expose rest routing reset and configuration
                GlobalConfiguration.Configuration.Routes.Clear();
                GlobalConfiguration.Configuration.MapHttpAttributeRoutes();

                GlobalConfiguration.Configuration.EnsureInitialized();
                routesInitialized = true; // After EnsureInitialized we can't clear the routes again because it does not reinitialize them.
            }
        }

        public override void OnApplicationStart() {
            Initialize();
            base.OnApplicationStart();
        }
    }
}
