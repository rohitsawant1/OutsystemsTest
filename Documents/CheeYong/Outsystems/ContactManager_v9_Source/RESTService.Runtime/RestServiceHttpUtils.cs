/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System.Collections.Generic;
using System.Net;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Web;
using OutSystems.RuntimeCommon;

namespace OutSystems.RESTService {
    public static class RestServiceHttpUtils {

        /// <summary>
        /// Tries to get a Header from the request if pressent
        /// </summary>
        /// <param name="request"></param>
        /// <param name="headerName"></param>
        /// <returns>The header value as string, or null if not present</returns>
        public static string TryGetRequestHeader(HttpRequestMessage request, string headerName) {
            IEnumerable<string> headerValues;
            if (!request.Headers.TryGetValues(headerName, out headerValues)) {
                request.Content.Headers.TryGetValues(headerName, out headerValues);
            }

            return headerValues != null ? headerValues.StrCat(",") : null;
        }

        /// <summary>
        /// Try to get the Charset for the current HttpRequest
        /// </summary>
        /// <param name="defaultValue">The default value if no Encoding is found in the request</param>
        /// <returns>The Encoding for the current HttpRequest. Empty string if not found in the Request</returns>
        public static string TryGetRequestEncoding(HttpRequestMessage request, string defaultValue) {
            if (request.Content == null) {
                return defaultValue;
            }
            if (request.Content.Headers.ContentType == null) {
                return defaultValue;
            }

            return string.IsNullOrEmpty(request.Content.Headers.ContentType.CharSet) ? defaultValue : request.Content.Headers.ContentType.CharSet;
        }

        /// <summary>
        /// Try to get the Charset for the current HttpResponse. Should be in the Content-Type
        /// </summary>
        /// <param name="defaultValue">The default value if no Encoding is found</param>
        /// <returns>The Encoding for the current HttpResponse.</returns>
        public static string TryGetResponseEncoding(HttpResponseMessage response, string defaultValue) {
            MediaTypeHeaderValue responseMedia = TryGetResponseContentHeader(response);
            if (responseMedia != null) {
                return string.IsNullOrEmpty(responseMedia.CharSet) ? defaultValue : responseMedia.CharSet;
            }

            return defaultValue;
        }

        /// <summary>
        /// Try to get the Content-Type for the current HttpResponse
        /// </summary>
        /// <param name="defaultValue">The default value if no Content-Type is found</param>
        /// <returns>The Encoding for the current HttpResponse.</returns>
        public static string TryGetResponseContentType(HttpResponseMessage response, string defaultValue) {
            MediaTypeHeaderValue responseMedia = TryGetResponseContentHeader(response);
            return responseMedia != null ? responseMedia.MediaType : defaultValue;
        }


        private static MediaTypeHeaderValue TryGetResponseContentHeader(HttpResponseMessage response) {
            // If we already have something in the Current Response, use that instead
            if (HttpContext.Current != null) {
                // With IIS in Classic Mode, we might have the Content Type in the Items Bag - See GetCurrentResponseContentType
                string overridenContentType = (HttpContext.Current.Items["Content-Type"] as string);
                if (!string.IsNullOrEmpty(overridenContentType)) {
                    MediaTypeHeaderValue outVal;
                    return MediaTypeHeaderValue.TryParse(overridenContentType, out outVal) ? outVal : null;
                }
            }

            return (response.Content == null) ? null : response.Content.Headers.ContentType;
        }

        /// <summary>
        /// Parses the Content-Type
        /// </summary>
        /// <param name="contentType">The full content-type header</param>
        /// <returns>A MediaType</returns>
        /// <remarks>
        /// Media-type is always before any parameter. Parameters are always preceeded by ;
        /// <see cref="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.7"/>
        /// </remarks>
        private static MediaTypeHeaderValue ParseContentType(string contentType) {
            return MediaTypeHeaderValue.Parse(contentType);
        }

        /// <summary>
        /// Gets a request content-type
        /// </summary>
        /// <param name="request">The HTTPRequest to Parse</param>
        /// <returns>A MediaTypeHeader with the Content-Type that's in the HTTPRequest</returns>
        public static MediaTypeHeaderValue GetRequestContentType(HttpRequest request) {
            return ParseContentType(request.ContentType);
        }

        /// <summary>
        /// Tries to get the request content-type, returns the provided default type if an error occurs
        /// </summary>
        /// <param name="request">The HTTPRequest to Parse</param>
        /// <param name="defaultValue">The default type to return in case of error</param>
        /// <returns>A MediaTypeHeader with the Content-Type that's in the HTTPRequest or the default type provided in case of error</returns>
        public static MediaTypeHeaderValue TryGetRequestContentType(HttpRequest request, string defaultValue) {
            try {
                return ParseContentType(request.ContentType);
            } catch {
                return ParseContentType(defaultValue);
            }
        }

        /// <summary>
        /// Get the current Response Content Type
        /// </summary>
        /// <param name="defaultValue">The default value if the Response currently doesn't have any content-type set</param>
        /// <returns>A MediaType with a Content-Type header.</returns>
        public static MediaTypeHeaderValue GetCurrentResponseContentType(string defaultValue) {
            // The correct way to do this should be from HttpContext.Current.Response.Headers collection, but in IIS classic mode this is not accessible,
            // so as workaround we track uses of the HttRequestHandler.AddHeader("Content-Type", ...) in the HttpContext.Current.Items collection
            string overridenContentType = (HttpContext.Current.Items["Content-Type"] as string);
            return overridenContentType != null ? ParseContentType(overridenContentType) : ParseContentType(defaultValue);
        }

        /// <summary>
        /// Returns the current HttpContext status Code (Response)
        /// </summary>
        /// <returns></returns>
        public static HttpStatusCode GetCurrentStatusCode() {
            return (HttpStatusCode)HttpContext.Current.Response.StatusCode;
        }

        /// <summary>
        /// Reads the content of an HttpRequestMessage as a String using the current Request Encoding (if available)
        /// According to a blog @ MSDN, reading the Result Property Synchronously can cause deadlocks
        /// e.g.: requestMessage.Content.ReadAsByteArrayAsync().Result
        /// </summary>
        /// <param name="requestMessage"></param>
        /// <returns></returns>
        public static string ReadRequestContentAsString(HttpRequestMessage requestMessage) {
            if (requestMessage == null) {
                return string.Empty;
            }

            string content = string.Empty;
            if (requestMessage.Content != null) {
                requestMessage.Content.ReadAsByteArrayAsync()
                    .ContinueWith((task) => {
                        string currentReqEncoding = TryGetRequestEncoding(requestMessage, Encoding.UTF8.HeaderName);
                        Encoding currentEnc;
                        try {
                            currentEnc = Encoding.GetEncoding(currentReqEncoding);
                        } catch (System.Exception) {
                            // If a strange encoding is passed, default to UTF-8 and proceed
                            currentEnc = Encoding.UTF8;
                        }
                        content = currentEnc.GetString(task.Result);
                        return content;
                    }).Wait();
            }
            return content;
        }

        /// <summary>
        /// Reads the content of an HttpRequestMessage.
        /// According to a blog @ MSDN, reading the Result Property Synchronously can cause deadlocks
        /// e.g.: requestMessage.Content.ReadAsByteArrayAsync().Result
        /// </summary>
        /// <param name="requestMessage"></param>
        /// <returns></returns>
        public static byte[] ReadRequestContent(HttpRequestMessage requestMessage) {
            if (requestMessage == null) {
                return new byte[0];
            }

            byte[] content = new byte[0];
            if (requestMessage.Content != null) {
                requestMessage.Content.ReadAsByteArrayAsync()
                    .ContinueWith((task) => {
                        content = task.Result;
                        return content;
                    }).Wait();
            }
            return content;
        }

        /// <summary>
        /// Transforms the byte content in a String representation using the current request encoding if available
        /// This method is usefull because we have HTTPRequest.RequestText and RequestBinary. We only read the request once as binary and then convert to a string without reading the body all over again.
        /// </summary>
        /// <param name="requestMessage"></param>
        /// <param name="content"></param>
        /// <returns></returns>
        public static string GetRequestContentAsString(HttpRequestMessage requestMessage, byte[] content) {
            if (requestMessage == null) {
                return string.Empty;
            }

            string contentStr = string.Empty;
            string currentReqEncoding = TryGetRequestEncoding(requestMessage, Encoding.UTF8.HeaderName);
            Encoding currentEnc;
            try {
                currentEnc = Encoding.GetEncoding(currentReqEncoding);
            } catch (System.Exception) {
                // If a strange encoding is passed, default to UTF-8 and proceed
                currentEnc = Encoding.UTF8;
            }

            contentStr = currentEnc.GetString(content);
            return contentStr;
        }

        /// <summary>
        /// Reads the content of an HttpResponseMessage as a String using the current Request Encoding (if available)
        /// According to a blog @ MSDN, reading the Result Property Synchronously can cause deadlocks
        /// e.g.: responseMessage.Content.ReadAsByteArrayAsync().Result
        /// </summary>
        /// <param name="requestMessage"></param>
        /// <returns></returns>
        public static string ReadResponseContentAsString(HttpResponseMessage responseMessage) {
            if (responseMessage == null) {
                return string.Empty;
            }

            string content = string.Empty;
            if (responseMessage.Content != null) {
                responseMessage.Content.ReadAsByteArrayAsync()
                    .ContinueWith((task) => {
                        string currentResEncoding = TryGetResponseEncoding(responseMessage, Encoding.UTF8.HeaderName);
                        Encoding currentEnc;
                        try {
                            currentEnc = Encoding.GetEncoding(currentResEncoding);
                        } catch (System.Exception) {
                            // If a strange encoding is passed, default to UTF-8 and proceed
                            currentEnc = Encoding.UTF8;
                        }
                        content = currentEnc.GetString(task.Result);
                        return content;
                    }).Wait();
            }
            return content;
        }

        /// <summary>
        /// Reads the content of an HttpResponseMessage as a String using the current Request Encoding (if available)
        /// According to a blog @ MSDN, reading the Result Property Synchronously can cause deadlocks
        /// e.g.: responseMessage.Content.ReadAsByteArrayAsync().Result
        /// </summary>
        /// <param name="requestMessage"></param>
        /// <returns></returns>
        public static byte[] ReadResponseContent(HttpResponseMessage responseMessage) {
            if (responseMessage == null) {
                return new byte[0];
            }

            byte[] content = new byte[0];
            if (responseMessage.Content != null) {
                responseMessage.Content.ReadAsByteArrayAsync()
                    .ContinueWith((task) => {
                        content = task.Result;
                        return content;
                    }).Wait();
            }
            return content;
        }

        /// <summary>
        /// Transforms the byte content in a String representation using the current response encoding if available
        /// This method is usefull because we have HTTPResponse.ResponseText and ResponseBinary. We only read the response once as binary and then convert to a string without reading the body all over again.
        /// </summary>
        /// <param name="responseMessage"></param>
        /// <param name="content"></param>
        /// <returns></returns>
        public static string GetResponseContentAsString(HttpResponseMessage responseMessage, byte[] content) {
            if (responseMessage == null) {
                return string.Empty;
            }

            string contentStr = string.Empty;
            string currentReqEncoding = TryGetResponseEncoding(responseMessage, Encoding.UTF8.HeaderName);
            Encoding currentEnc;
            try {
                currentEnc = Encoding.GetEncoding(currentReqEncoding);
            } catch (System.Exception) {
                // If a strange encoding is passed, default to UTF-8 and proceed
                currentEnc = Encoding.UTF8;
            }

            contentStr = currentEnc.GetString(content);
            return contentStr;
        }

        /// <summary>
        /// Adds the minimum set of headers to prevent browser caching.
        /// </summary>
        /// <param name="response"></param>
        /// <returns></returns>
        internal static void AddNoCacheHeaders(HttpResponseMessage response) {
            // see: http://stackoverflow.com/a/2068407
            response.Headers.CacheControl = new CacheControlHeaderValue() {
                NoStore = true,
                NoCache = true
            };
            response.Headers.Pragma.Add(NameValueHeaderValue.Parse("no-cache"));
        }

        /// <summary>
        /// Adds the given header to the response.
        /// </summary>
        /// <param name="response"></param>
        /// <returns></returns>
        internal static void AddCustomHeader(HttpResponseMessage response, string name, string value) {
            response.Headers.Add(name, value);
        }
    }
}