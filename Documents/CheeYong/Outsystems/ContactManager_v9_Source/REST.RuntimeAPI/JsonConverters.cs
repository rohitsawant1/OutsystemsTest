/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OutSystems.REST {

    /// <summary>
    /// Utility class containing converters used to map between JSON and native data types.
    /// </summary>
    /// <seealso cref="Newtonsoft.Json.JsonConverter"/>
    public static class JsonConverters {

        /// <summary>
        /// This converter is necessary to ensure that decimals without any decimal places are not sent with a trailing .0
        /// 
        /// See http://stackoverflow.com/questions/21153381/json-net-serializing-float-double-with-minimal-decimal-places-i-e-no-redundant for details.
        /// </summary>
        public class DecimalConverter : JsonConverter {
            /// <summary>
            /// Test whether the received type can be converted to and from JSON by this converter.
            /// </summary>
            /// <param name="objectType">the type to check.</param>
            /// <returns><code>true</code> if <code>objectType</code> is the (optionally nullable) decimal type, <code>false</code> otherwise.</returns>
            public override bool CanConvert(Type objectType) {
                return (objectType == typeof(decimal?));
            }

            /// <summary>
            /// Reads the JSON representation of the object.
            /// </summary>
            /// <param name="reader">The JsonReader from where to read.</param>
            /// <param name="objectType">Type of the object to be read.</param>
            /// <param name="existingValue">The existing value of object being read.</param>
            /// <param name="serializer">The calling serializer.</param>
            /// <returns>The read object.</returns>
            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) {
                return reader.Value;
            }

            /// <summary>
            /// Writes the representation of the received object to the serializer.
            /// </summary>
            /// <param name="writer">JsonWriter where to write to.</param>
            /// <param name="value">Object to serialize.</param>
            /// <param name="serializer">The calling serializer.</param>
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) {
                var decimalValue = value as decimal?;
                if (decimalValue != null && decimalValue.HasValue) {
                    if (decimalValue.Value == Decimal.Truncate(decimalValue.Value)) {
                        writer.WriteValue(Convert.ToInt64(value));
                    } else {
                        writer.WriteValue(value);
                    }
                }
            }
        }

        /// <summary>
        /// Converter capable of transforming <see cref="DateTime"/> to Unix timestamps and the other way around.
        /// </summary>
        /// This representation is also known as POSIX or Epoch time and is defined as the number of seconds that have elapsed since 00:00:00 UTC, 1 January 1970.
        /// <seealso ref="https://en.wikipedia.org/wiki/Unix_time"/>
        /// <seealso cref="Newtonsoft.Json.Converters.DateTimeConverterBase"/>
        public class UnixTimestampConverter : Newtonsoft.Json.Converters.DateTimeConverterBase {
            /// <summary>
            /// Reads the JSON representation of a DateTime.
            /// </summary>
            /// <param name="reader">The JsonReader from where to read.</param>
            /// <param name="objectType">Type of the object to be read.</param>
            /// <param name="existingValue">The existing value of object being read.</param>
            /// <param name="serializer">The calling serializer.</param>
            /// <returns>The read DateTime object.</returns>
            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) {
                long t = long.Parse(reader.Value.ToString());
                return new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc).AddSeconds(t).ToLocalTime();
            }

            /// <summary>
            /// Writes the representation of the received date to the serializer.
            /// </summary>
            /// <param name="writer">JsonWriter where to write to.</param>
            /// <param name="value">DateTime to serialize.</param>
            /// <param name="serializer">The calling serializer.</param>
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) {
            long secondsSinceEpoch = (long)(((DateTime)value) - (new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc))).TotalSeconds;
                writer.WriteValue(secondsSinceEpoch);
            }
        }

        /// <summary>
        /// A JSON converter which parses and writes <see cref="DateTime"/> in the WCF format.
        /// </summary>
        /// It is especially useful for applications using the Windows Communication Foundation.
        /// <seealso cref="Newtonsoft.Json.Converters.DateTimeConverterBase"/>
        public class WCFDateConverter : Newtonsoft.Json.Converters.DateTimeConverterBase {
            /// <summary>
            /// Reads the JSON representation of a DateTime.
            /// </summary>
            /// <param name="reader">The JsonReader from where to read.</param>
            /// <param name="objectType">Type of the object to be read.</param>
            /// <param name="existingValue">The existing value of object being read.</param>
            /// <param name="serializer">The calling serializer.</param>
            /// <returns>The read DateTime object.</returns>
            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) {
                return ((DateTime)reader.Value).ToLocalTime();
            }

            /// <summary>
            /// Writes the representation of the received date to the serializer.
            /// </summary>
            /// <param name="writer">JsonWriter where to write to.</param>
            /// <param name="value">DateTime to serialize.</param>
            /// <param name="serializer">The calling serializer.</param>
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) {
                var millisecondsSinceEpoch = (long)(((DateTime)value) - (new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc))).TotalMilliseconds;
                writer.WriteValue("/Date(" + millisecondsSinceEpoch + ")/");
            }
        }
    }
}
