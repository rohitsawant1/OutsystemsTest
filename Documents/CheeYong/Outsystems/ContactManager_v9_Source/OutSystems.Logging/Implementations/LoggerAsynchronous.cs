/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections.Generic;
using System.Messaging;
using System.Text;
using OutSystems.Extensibility;
using OutSystems.Logging.LogDefinition;
using OutSystems.RuntimeCommon;
using OutSystems.RuntimeCommon.Settings;

namespace OutSystems.Logging.Implementations {
    public class LoggerAsynchronous : LoggerImplementation {
        private Dictionary<string, MessageQueue> messageQueues = new Dictionary<string, MessageQueue>(10);

        private MessageQueue adminQueue;
        private ISettingsProvider settingsProvider;

        public LoggerAsynchronous(ISettingsProvider settingsProvider) {
            this.settingsProvider = settingsProvider;
        }

        private MessageQueue GetMessageQueue(LogType logType) {
            string queuePath;
            if (settingsProvider.Get(LoggerSettings.SupportBulkLogs)) {
                queuePath = GetQueuePathForLogType(logType);
            } else {
                queuePath = settingsProvider.Get(LoggerSettings.QueuePath);
                logType = LogType.Dummy;
            }

            GetAndCreateMessageQueueIfNeeded(logType, queuePath);
            return messageQueues[queuePath];
        }

        public string GetQueuePathForLogType(LogType logType) {
            string queuePath;
            switch (logType) {
                case LogType.Cyclic_Job:
                    queuePath = settingsProvider.Get(LoggerSettings.TimerLogQueuePath);
                    break;
                case LogType.Error:
                    queuePath = settingsProvider.Get(LoggerSettings.ErrorLogQueuePath);
                    break;
                case LogType.General:
                    queuePath = settingsProvider.Get(LoggerSettings.GeneralLogQueuePath);
                    break;
                case LogType.Screen:
                    queuePath = settingsProvider.Get(LoggerSettings.ScreenLogQueuePath);
                    break;
                case LogType.Extension:
                    queuePath = settingsProvider.Get(LoggerSettings.ExtensionLogQueuePath);
                    break;
                case LogType.Web_Reference:
                    queuePath = settingsProvider.Get(LoggerSettings.WebReferenceLogQueuePath);
                    break;
                case LogType.Web_Service:
                    queuePath = settingsProvider.Get(LoggerSettings.WebServiceLogQueuePath);
                    break;
                case LogType.Integration:
                    queuePath = settingsProvider.Get(LoggerSettings.IntegrationLogQueuePath);
                    break;
                case LogType.Int_Detail:
                    queuePath = settingsProvider.Get(LoggerSettings.IntDetailLogQueuePath);
                    break;
                case LogType.RequestEvent:
                    queuePath = settingsProvider.Get(LoggerSettings.RequestEventQueuePath);
                    break;
                case LogType.Mobile_Request:
                    queuePath = settingsProvider.Get(LoggerSettings.MobileRequestQueuePath);
                    break;
                case LogType.MR_Detail:
                    queuePath = settingsProvider.Get(LoggerSettings.MobileRequestDetailQueuePath);
                    break;
                default:
                    queuePath = settingsProvider.Get(LoggerSettings.CustomLogQueuePath);
                    break;
            }
            return queuePath;
        }

        private void GetAndCreateMessageQueueIfNeeded(LogType logType, string queuePath) {
            if (!messageQueues.ContainsKey(queuePath)) {
                lock (messageQueues) {
                    if (adminQueue == null) {
                        adminQueue = new MessageQueue(settingsProvider.Get(LoggerSettings.AdminQueuePath));
                        adminQueue.Formatter = new BinaryMessageFormatter();
                    }
                    if (!messageQueues.ContainsKey(queuePath)) {
                        // Queues are created in ServerSetup
                        MessageQueue mQueue = CreateMessageQueue(queuePath, logType);
                        messageQueues.Add(queuePath, mQueue);
                    }
                }
            }
        }

        public static MessageQueue CreateMessageQueue(string queuePath, LogType logType) {
            MessageQueue mQueue = new MessageQueue(queuePath);
            mQueue.Formatter = new BinaryMessageFormatter();

            try {
                mQueue.Send("dummy", LogType.Dummy.ToString());
            } catch {
                mQueue = new MessageQueue(queuePath);
                mQueue.Formatter = new BinaryMessageFormatter();
                mQueue.Send("dummy", LogType.Dummy.ToString());
            }
            return mQueue;
        }

        private void Log(object log, LogType logType, MessagePriority priority) {
            using (var msg = CreateMessage(log, logType.ToString(), priority)) {
                MessageQueue messageQueue = null;
                try {
                    messageQueue = GetMessageQueue(logType);
                    messageQueue.Send(msg);
                } catch {
                    RuntimeCommon.Log.EventLogger.WriteError("Error sending message to queue \"{0}\"".F(messageQueue?.Path));
                }
            }
        }

        private void Log(object log, LogType logType) {
            Log(log, logType, MessagePriority.Normal);
        }

        public override void Stop() {
            base.Stop();

            foreach (MessageQueue queue in messageQueues.Values) {
                queue.Dispose();
            }
        }

        private int maxMessagesSizeInKbForLargeContentQueues;

        public override void SetUp() {
            maxMessagesSizeInKbForLargeContentQueues = settingsProvider.Get(LoggerSettings.LogServerMaxMessagesSizeInKbForLargeContentQueues) * 1000;
        }

        private Message CreateMessage(object log, string label, MessagePriority priority) {
            Message msg = new Message(log, new BinaryMessageFormatter());
            msg.Recoverable = false;
            msg.Label = label;
            msg.Priority = priority;
            msg.AdministrationQueue = adminQueue;
            msg.AcknowledgeType = AcknowledgeTypes.NotAcknowledgeReachQueue | AcknowledgeTypes.NotAcknowledgeReceive | AcknowledgeTypes.NegativeReceive;
            msg.TimeToBeReceived = TimeSpan.FromMinutes(settingsProvider.Get(LoggerSettings.QueueMessagesMaxAge));
            return msg;
        }
        
        public override void Log(CyclicJobLogDefinition log) {
            Log(log, LogType.Cyclic_Job);
        }

        public override void Log(GeneralLogDefinition log) {
            Log(log, LogType.General);
        }

        public override void Log(ScreenLogDefinition log) {
            Log(log, LogType.Screen);
        }

        public override void Log(ExtensionLogDefinition log) {
            Log(log, LogType.Extension);
        }

        public override void Log(CustomLogDefinition log) {
            if (!settingsProvider.Get(LoggerSettings.SupportBulkLogs)) {
                throw new NotSupportedException("Bulk logs not supported in this installation. Please contact {C}.".ReplaceBranding());
            }

            if (!settingsProvider.Get(LoggerSettings.SupportCustomLogs)) {
                throw new NotSupportedException("Custom Logs not supported in this installation. Please contact {C} support.".ReplaceBranding());
            }
            Log(log, LogType.Custom);
        }

        public override void Log(ErrorLogDefinition log) {
            Log(log, LogType.Error);
        }

        private const string TruncatedLogMessageSuffix = "\r\n<Message truncated in logging because it exceeded the maximum size>";


        public override void Log(IntegrationLogDefinition log) {
            Log(log, LogType.Integration);
        }

        public override void Log(IntDetailLogDefinition log) {
            if (log.Message != null) {
                // Ensure the limits here to avoid hitting any queues limits, but the IntDetailLogDefinition should have it already sanitized
                log.Message = StringUtils.Left(log.Message, IntDetailLogDefinition.MAX_MESSAGE_SIZE);
            }

            if (log.Detail != null && log.Detail.Length > maxMessagesSizeInKbForLargeContentQueues) {
                var builder = new StringBuilder(maxMessagesSizeInKbForLargeContentQueues + TruncatedLogMessageSuffix.Length + 1);
                builder.Append(log.Detail, 0, maxMessagesSizeInKbForLargeContentQueues);
                builder.Append(TruncatedLogMessageSuffix);
                log.Detail = builder.ToString();
            }

            Log(log, LogType.Int_Detail);
        }

        public override void Log(RequestEventDefinition log) {
            Log(log, LogType.RequestEvent);
        }

        public override void Log(MobileRequestLogDefinition log) {
            Log(log, LogType.Mobile_Request);
        }

        public override void Log(MRDetailLogDefinition log) {
            Log(log, LogType.MR_Detail);
        }

        public override void Log(ServiceAPILogDefinition log) {
            Log(log, LogType.SrvAPI);
        }

        public override void Log(ServiceAPIDetailLogDefinition log) {
            Log(log, LogType.SrvAPI_Detail);
        }
    }
}
