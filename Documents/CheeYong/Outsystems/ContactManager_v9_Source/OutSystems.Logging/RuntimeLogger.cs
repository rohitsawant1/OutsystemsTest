/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.ComponentModel;
using System.Diagnostics;
using OutSystems.Logging.Implementations;
using OutSystems.Logging.LogDefinition;
using OutSystems.Logging.Utils;
using OutSystems.RuntimeCommon;
using OutSystems.RuntimeCommon.Log;
using OutSystems.RuntimeCommon.ObfuscationProperties;
using OutSystems.RuntimeCommon.Settings;
namespace OutSystems.Logging {

    [Obsolete("Use RuntimeLogger instead.")]
    public class Logger : RuntimeLogger { }

    public partial class RuntimeLogger {

        public delegate LoggerImplementation GetRuntimeLoggerDelegate();
        public delegate void SetRuntimeLoggerDelegate(LoggerImplementation logger);
        public delegate LoggerImplementation SetupRuntimeLoggerDelegate(IServiceProvider serviceProvider);

        private static volatile GetRuntimeLoggerDelegate getRuntimeLoggerOverride = null;
        private static volatile SetRuntimeLoggerDelegate setRuntimeLoggerOverride = null;
        private static volatile SetupRuntimeLoggerDelegate setupRuntimeLoggerOverride = null;

        private static volatile ISettingsProvider SettingsProvider = null;
        private static volatile ILoggingDatabaseService LoggingDatabaseService = null;
        private static volatile IServiceProvider ServiceProvider = null;


        private static LogThrottle logthrottle = new LogThrottle(2);

        public static void OverrideRuntimeLogger(GetRuntimeLoggerDelegate getOverride, SetRuntimeLoggerDelegate setOverride, SetupRuntimeLoggerDelegate setupOverride) {
            lock (typeof(RuntimeLogger)) {
                getRuntimeLoggerOverride = getOverride;
                setRuntimeLoggerOverride = setOverride;
                setupRuntimeLoggerOverride = setupOverride;
            }
        }

        /// <summary>
        /// For tests purposes only, not thread safe
        /// </summary>
        [DoNotObfuscate]
        internal static void WithRuntimeLoggerOverride(GetRuntimeLoggerDelegate getOverride, Action action) {
            GetRuntimeLoggerDelegate previousGetRuntimeLoggerOverride = null;

            try {
                lock (typeof(RuntimeLogger)) {
                    previousGetRuntimeLoggerOverride = getRuntimeLoggerOverride;
                    OverrideRuntimeLogger(getOverride, setRuntimeLoggerOverride, setupRuntimeLoggerOverride);
                }
                action();
            } finally {
                OverrideRuntimeLogger(previousGetRuntimeLoggerOverride, setRuntimeLoggerOverride, setupRuntimeLoggerOverride);
            }
        }

        public static volatile bool DisableLogs = false;

        private static string applicationName = "Undefined Application";

        private static volatile LoggerImplementation loggerInstance = null;

        private static bool IsInitiated {
            get {
                // Create a local variable since the GetRuntimeLoggerOverride is volatile and implies extra locks;
                var getOverride = getRuntimeLoggerOverride;
                return ((getOverride == null) && (null != loggerInstance)) || ((getOverride != null) && (getOverride() != null));
            }
        }
        public static LoggerImplementation LoggerInstance {
            get {
                if (loggerInstance == null) {
                    lock (typeof (RuntimeLogger)) {
                        if (loggerInstance == null) {
                            loggerInstance = NullLogger.Instance;
                        }
                    }
                }
                return loggerInstance;
            }
            private set {
                lock (typeof(RuntimeLogger)) {
                    loggerInstance = value;
                }
            }
        }

        private static volatile bool isApplicationMonitoringEnabled = true;
        public static bool ApplicationMonitoringEnabled {
            get {
                return isApplicationMonitoringEnabled;
            } set {
                isApplicationMonitoringEnabled = value;
            }
        }

        public static void SetUp(string applicationName, bool ignoreExceptions, ISettingsProvider settingsProvider, ILoggingDatabaseService loggingDatabaseService) {
            lock (typeof(RuntimeLogger)) {
                RuntimeLogger.applicationName = applicationName;
                RuntimeLogger.SettingsProvider = settingsProvider;
                RuntimeLogger.LoggingDatabaseService = loggingDatabaseService;
                RuntimeLogger.ServiceProvider = new LoggerServiceProvider(settingsProvider, new LoggingPluginProvider(), loggingDatabaseService);
            }
        }

        private static void SetUpLoggerInstance(bool ignoreExceptions, IServiceProvider serviceProvider) {
            if (ignoreExceptions) {
                lock (typeof(RuntimeLogger)) {
                    try {
                        LoggerInstance = GetRuntimeLogger(serviceProvider);
                    } catch (Exception e) {
                        EventLogger.WriteError("Error initializing logger for " + applicationName + ": " + e.ToString());
                    }
                }
            } else {
                lock (typeof(RuntimeLogger)) {
                    LoggerInstance = GetRuntimeLogger(serviceProvider);
                }
            }
        }
        
        private static LoggerImplementation GetRuntimeLogger(IServiceProvider serviceProvider) {
            LoggerImplementation logger = new NullLogger();
            logger.SetUp();
            return logger;
        }

        public static void Log(CyclicJobLogDefinition log) {
            try {
                if (!ApplicationMonitoringEnabled)
                    return;
                LoggerInstance.Log(log);
            } catch (Exception e) {
                logthrottle.WriteErrorWithThrottle(EventLogger.WriteError, "Error sending log: " + e.ToString());
            }
        }

        public static void Stop() {
            if(IsInitiated) {
                LoggerInstance.Stop();
            }
        }
        
        public static void Log(ErrorLogDefinition log) {
            try {
                if (LoggerInstance != null) {
                    LoggerInstance.Log(log);
                } else {
                    EventLogger.WriteError(log.Message);
                }
            } catch (Exception e) {
                EventLogger.WriteError("Error sending log: " + e.ToString());
            }
        }

        public static void Log(GeneralLogDefinition log) {
            try {
                if (!ApplicationMonitoringEnabled)
                    return;
                if (log.ModuleName == "ALARM") {
                    EventLogger.WriteWarning(log.Message);
                }
                if (LoggerInstance != null) {
                    LoggerInstance.Log(log);
                } else {
                    EventLogger.WriteInfo(log.Message);
                }
            } catch (Exception e) {
                logthrottle.WriteErrorWithThrottle(EventLogger.WriteError, "Error sending log: " + e.ToString());
            }
        }

        public static void Log(ScreenLogDefinition screenLog) {
            try {
                if (!ApplicationMonitoringEnabled)
                    return;
                
                switch (screenLog.ScreenType) {
                    case "WEB":
                        break;
                    case "SMS":
                        break;
                    default:
                        break;
                }
                LoggerInstance.Log(screenLog);
            } catch (Exception e) {
                logthrottle.WriteErrorWithThrottle(EventLogger.WriteError, "Error sending log: " + e.ToString());
            }
        }

        public static void Log(ExtensionLogDefinition extensionLog) {
            try {
                if (!ApplicationMonitoringEnabled)
                    return;
                LoggerInstance.Log(extensionLog);
            } catch (Exception e) {
                logthrottle.WriteErrorWithThrottle(EventLogger.WriteError, "Error sending log: " + e.ToString());
            }
        }

        public static void Log(IntegrationLogDefinition log) {
            try {
                if (!ApplicationMonitoringEnabled)
                    return;
                LoggerInstance.Log(log);
            } catch (Exception e) {
                logthrottle.WriteErrorWithThrottle(EventLogger.WriteError, "Error sending log: " + e.ToString());
            }
        }

        public static void Log(IntDetailLogDefinition log) {
            try {
                if (!ApplicationMonitoringEnabled) {
                    return;
                }
                if (LoggerInstance != null) {
                    LoggerInstance.Log(log);
                } else {
                    EventLogger.WriteInfo(log.Message);
                }
            } catch (Exception e) {
                logthrottle.WriteErrorWithThrottle(EventLogger.WriteError, "Error sending log: " + e.ToString());
            }
        }

        public static void Log(CustomLogDefinition log) {
            try {
                if (!ApplicationMonitoringEnabled) {
                    return;
                }
                LoggerInstance.Log(log);
            } catch (NotSupportedException) {
                throw;
            } catch (Exception e) {
                logthrottle.WriteErrorWithThrottle(EventLogger.WriteError, "Error sending log: " + e.ToString());
            }
        }

        public static void Log(RequestEventDefinition log) {
            try {
                LoggerInstance.Log(log);
            } catch (Exception e) {
                logthrottle.WriteErrorWithThrottle(EventLogger.WriteError, "Error sending log: " + e.ToString());
            }
        }

        public static void Log(MobileRequestLogDefinition log) {
            try {
                if (!ApplicationMonitoringEnabled)
                    return;
                LoggerInstance.Log(log);
            } catch (Exception e) {
                logthrottle.WriteErrorWithThrottle(EventLogger.WriteError, "Error sending log: " + e.ToString());
            }
        }

        public static void Log(MRDetailLogDefinition log) {
            try {
                if (!ApplicationMonitoringEnabled) {
                    return;
                }
                if (LoggerInstance != null) {
                    LoggerInstance.Log(log);
                } else {
                    EventLogger.WriteInfo(log.Message);
                }
            } catch (Exception e) {
                logthrottle.WriteErrorWithThrottle(EventLogger.WriteError, "Error sending log: " + e.ToString());
            }
        }

        public static void Log(ServiceAPILogDefinition log) {
            try {
                if (!ApplicationMonitoringEnabled) {
                    return;
                }
                LoggerInstance.Log(log);
            } catch (Exception e) {
                logthrottle.WriteErrorWithThrottle(EventLogger.WriteError, "Error sending log: " + e.ToString());
            }
        }

        public static void Log(ServiceAPIDetailLogDefinition log) {
            try {
                if (!ApplicationMonitoringEnabled) {
                    return;
                }
                if (LoggerInstance != null) {
                    LoggerInstance.Log(log);
                } else {
                    EventLogger.WriteInfo(log.Message);
                }
            } catch (Exception e) {
                logthrottle.WriteErrorWithThrottle(EventLogger.WriteError, "Error sending log: " + e.ToString());
            }
        }





        private static DateTime referenceDate = new DateTime(2000, 1, 1, 0, 0, 0);

        public static int CalculateIndex(DateTime current, int cycleSize) {
            return CalculateIndex(current, cycleSize, null);
        }

        public static int CalculateIndex(DateTime current, int cycleSize, Func<string, object> getSetting) {
            int cyclePeriod = 7; // 1 week default
            try {
                if (getSetting != null) {
                    var converter = TypeDescriptor.GetConverter(typeof(int));
                    if (converter != null) {
                        return (int)converter.ConvertTo(getSetting(LoggerSettings.DbCyclePeriod.Key), typeof(int));
                    }
                    return default(int);
                } else {
                    cyclePeriod = RuntimeLogger.SettingsProvider.Get(LoggerSettings.DbCyclePeriod);
                }
            } catch {
            }
            return CalculateIndex(current, cycleSize, cyclePeriod);
        }

        public static int CalculateIndex(DateTime current, int cycleSize, int cyclePeriod) {
            return (current.Subtract(referenceDate).Days / cyclePeriod) % cycleSize;
        }

        public static int CalculateLastDirtyIndex(int cycleSize, int cyclePeriod, int windowSize) {
            int current = CalculateIndex(DateTime.Now, cycleSize, cyclePeriod);
            // This may look more complicated than needed, but guards against very big or negative windowSize's...
            current = (current - windowSize) % cycleSize;

            return (current >= 0 ? current : current + cycleSize);
        }

        public static int CalculateLastDirtyIndex(int cycleSize, int windowSize, Func<string, object> getSetting) {
            int current = CalculateIndex(DateTime.Now, cycleSize, getSetting);
            // This may look more complicated than needed, but guards against very big or negative windowSize's...
            current = (current - windowSize) % cycleSize;

            return (current >= 0 ? current : current + cycleSize);
        }

        public static int CalculateLastDirtyIndex(int cycleSize, int windowSize) {
            return CalculateLastDirtyIndex(cycleSize, windowSize, /*getSetting*/null);
        }

        public static int CalculatePreviousIndex(int currentIndex, int cycleSize) {
            int current = (currentIndex - 1) % cycleSize;
            return (current >= 0 ? current : current + cycleSize);
        }

        public static void SetDisableLogs(bool value) {
            lock (typeof (RuntimeLogger)) {
                DisableLogs = value;
            }
        }
    }
}
