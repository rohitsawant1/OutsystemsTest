/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Text;
using System.Threading;
using OutSystems.HubEdition.RuntimePlatform;
using OutSystems.RuntimeCommon;
using OutSystems.RuntimeCommon.Log;
using OutSystems.RuntimeCommon.PubSub;
using OutSystems.RuntimeCommon.Settings;
using RabbitMQ.Client;
using RabbitMQ.Client.Events;

namespace OutSystems.Plugin.RabbitMQ {

    internal class RabbitMQSubscription : ISubscription {

        public event OnMessageCallback OnMessage;

        private ConcurrentDictionary<string, bool> topics;
        private IJobExecutor executor;
        private readonly string declareQueueJobKey;
        private string queueName;
        private string consumerTag;

        private object topicsLocker = new object();

        private LazyInitializer<IModel> Channel { get; }

        public RabbitMQSubscription(LazyInitializer<IModel> Channel, IJobExecutor executor) {
            this.Channel = Channel;
            this.topics = new ConcurrentDictionary<string, bool>();
            this.executor = executor;
            this.declareQueueJobKey = Guid.NewGuid().ToString();
            this.executor.AddJob(DeclareQueueAndRegisterConsumer, key: declareQueueJobKey);
        }

        private void DeclareQueueAndRegisterConsumer() {
            this.queueName = RabbitMQUtils.DeclareQueue(this.Channel.Value);
            var consumer = new EventingBasicConsumer(Channel.Value);
            consumer.Received += (object model, BasicDeliverEventArgs eventArgs) => {
                try {
                    var message = Encoding.UTF8.GetString(eventArgs.Body);
                    RaiseOnMessage(new PubSubMessage(eventArgs.Exchange, message));
                } catch (Exception ex) {
                    EventLogger.WriteError($"Error handling Rabbit consumer event for queue: {this.queueName}. Cache invalidation skipped.");
                    EventLogger.WriteError(ex);
                }
            };
            RabbitMQUtils.BasicConsume(this.queueName, consumer, this.Channel.Value);
            this.consumerTag = consumer.ConsumerTag;
        }

        public void RaiseOnMessage(PubSubMessage message) {
            OnMessage?.Invoke(message);
        }

        public IEnumerable<string> GetSubscribedTopics() {
            return this.topics.Keys;
        }

        public void SubscribeTopic(string topic) {
            Action job = () => InnerSubscribeTopic(topic);
            executor.AddJob(job, dependencyKey: declareQueueJobKey);
        }

        private void InnerSubscribeTopic(string topic) {
            if (!this.topics.ContainsKey(topic)) {
                lock (topicsLocker) {
                    if (!this.topics.ContainsKey(topic)) {
                        RabbitMQUtils.DeclareExchange(topic, this.Channel.Value);
                        RabbitMQUtils.BindQueueToExchange(this.queueName, topic, this.Channel.Value);
                        this.topics[topic] = true;
                    }
                }
            }
        }

        public void UnsubscribeAll() {
            lock (topicsLocker) {
                foreach (var kvp in this.topics) {
                    UnsubscribeTopic(kvp.Key);
                }
            }
        }

        public void UnsubscribeTopic(string topic) {
            Action job = () => InnerUnsubscribeTopic(topic);
            executor.AddJob(job);
        }

        private void InnerUnsubscribeTopic(string topic) {
            if (this.topics.ContainsKey(topic)) {
                lock (topicsLocker) {
                    if (this.topics.TryRemove(topic, out bool value)) {
                        RabbitMQUtils.UnbindQueueFromExchange(this.queueName, topic, this.Channel.Value);
                    }
                }
            }
        }

        public void Dispose() {
            if (this.Channel.IsValueInitialized) {
                Action job = () => {
                    if(this.consumerTag != null) {
                        RabbitMQUtils.BasicCancel(this.consumerTag, this.Channel.Value);
                    }
                    if(this.queueName != null) {
                        RabbitMQUtils.DeleteQueue(this.queueName, this.Channel.Value);
                    }
                };
                executor.AddJob(job);
            }
        }
    }

    internal class LazyInitializer<T> {
        private Func<T> _valueFactory;
        private T _value;

        public LazyInitializer(Func<T> valueFactory) {
            this._valueFactory = valueFactory;
        }

        public T Value {
            get {
                if (_value == null) {
                    lock (this) {
                        if (_value == null) {
                            var result = _valueFactory();
                            _valueFactory = null;
                            _value = result;
                        }
                    }
                }
                return _value;
            }
        }

        public bool IsValueInitialized {
            get {
                lock (this) {
                    return _value != null;
                }
            }
        }
    }

    internal class RabbitMQUtils {
        
        public static void DeclareExchange(string topic, IModel channel) {
            lock (channel) {
                channel.ExchangeDeclare(
                    exchange: topic,
                    type: ExchangeType.Fanout,
                    durable: false,
                    autoDelete: false);
            }
        }

        public static string DeclareQueue(IModel channel) {
            lock (channel) {
                return channel
                .QueueDeclare(
                    durable: false,
                    exclusive: true,
                    autoDelete: true)
                .QueueName;
            }
        }

        public static void UnbindQueueFromExchange(string queueName, string topic, IModel channel) {
            lock (channel) {
                channel.QueueUnbind(
                        queue: queueName,
                        exchange: topic,
                        routingKey: string.Empty);
            }
        }

        public static void DeleteQueue(string queueName, IModel channel) {
            lock (channel) {
                channel.QueueDelete(
                    queue: queueName,
                    ifEmpty: false,
                    ifUnused: false);
            }
        }

        public static void BindQueueToExchange(string queueName, string topic, IModel channel) {
            lock (channel) {
                channel.QueueBind(
                    queue: queueName,
                    exchange: topic,
                    routingKey: string.Empty);
            }
        }

        public static void BasicConsume(string queueName, IBasicConsumer consumer, IModel channel) {
            lock (channel) {
                channel.BasicConsume(
                    queue: queueName,
                    autoAck: true,
                    consumer: consumer);
            }
        }

        public static void BasicCancel(string consumerTag, IModel channel) {
            lock (channel) {
                channel.BasicCancel(consumerTag);
            }
        }

        public static void Publish(string topic, string message, IModel channel) {
            lock (channel) {
                var body = Encoding.UTF8.GetBytes(message);
                channel.BasicPublish(
                    exchange: topic,
                    routingKey: string.Empty,
                    body: body);
            }
        }
    }

    public class RabbitMQPubSub : IPubSub {

        private ISettingsProvider settingsProvider;
        private LazyInitializer<IConnection> connection;
        private LazyInitializer<IModel> channel;
        private IJobExecutor executor;
        private ConcurrentBag<RabbitMQSubscription> subscriptions;

        public RabbitMQPubSub(ISettingsProvider settingsProvider, IJobExecutor executor = null) {
            this.settingsProvider = settingsProvider;
            this.subscriptions = new ConcurrentBag<RabbitMQSubscription>();
            this.connection = new LazyInitializer<IConnection>(CreateConnection);
            this.channel = new LazyInitializer<IModel>(() => connection.Value.CreateModel());
            this.executor = executor ?? new PubSubJobsExecutor(this);

            // Ensure this is called explicitly on unload since Rabbit does not take care of that
            AppDomain.CurrentDomain.DomainUnload += OnAppDomainUnload;
        }

        public bool IsAvailable() {
            return IsAvailable(out _);
        }

        public bool IsAvailable(out Exception ex) {
            try {
                ex = null;
                return connection.Value.IsOpen;
            } catch (Exception e) {
                ex = e;
                return false;
            }
        }

        private IConnection CreateConnection() {
            ConnectionFactory factory = new ConnectionFactory {
                AutomaticRecoveryEnabled = true,
                TopologyRecoveryEnabled = true,
                NetworkRecoveryInterval = TimeSpan.FromSeconds(1),
                RequestedConnectionTimeout = 15000,

                HostName = settingsProvider.Get(RuntimePlatformSettings.Plugin.CacheInvalidation.RabbitMQAddress),
                Port = settingsProvider.Get(RuntimePlatformSettings.Plugin.CacheInvalidation.RabbitMQPort),
                UserName = settingsProvider.Get(RuntimePlatformSettings.Plugin.CacheInvalidation.RabbitMQUsername),
                Password = settingsProvider.Get(RuntimePlatformSettings.Plugin.CacheInvalidation.RabbitMQPassword),
                VirtualHost = settingsProvider.Get(RuntimePlatformSettings.Plugin.CacheInvalidation.RabbitMQVirtualHost),
            };

            var isTlsEnabled = settingsProvider.Get(RuntimePlatformSettings.Plugin.CacheInvalidation.RabbitMQTlsEnabled);
            if (isTlsEnabled) {
                var serverName = settingsProvider.Get(RuntimePlatformSettings.Plugin.CacheInvalidation.RabbitMQTlsServerCanonicalName);
                if (string.IsNullOrEmpty(serverName)) {
                    serverName = factory.HostName;
                }

                factory.Ssl.Enabled = isTlsEnabled;
                factory.Ssl.ServerName = serverName;
                factory.Ssl.Version =
                    System.Security.Authentication.SslProtocols.Tls
                    | System.Security.Authentication.SslProtocols.Tls11
                    | System.Security.Authentication.SslProtocols.Tls12;
            }

            return factory.CreateConnection();
        }

        public void CancelAllSubscriptions() {
            subscriptions.Apply(sub => sub.UnsubscribeAll());
        }

        public ISubscription CreateEmptySubscription() {
            var subscription = new RabbitMQSubscription(channel, executor);
            subscriptions.Add(subscription);
            return subscription;
        }

        public void Publish(string topic, string message) {
            RabbitMQUtils.DeclareExchange(topic, channel.Value);
            RabbitMQUtils.Publish(topic, message, this.channel.Value);
        }

        public ISubscription Subscribe(string topic, OnMessageCallback onMessage) {
            var subscription = CreateEmptySubscription();
            subscription.SubscribeTopic(topic);
            subscription.OnMessage += onMessage;
            return subscription;
        }

        private void OnAppDomainUnload(object sender, EventArgs e) {
            Dispose();
        }

        public void Dispose() {
            try {
                CancelAllSubscriptions();
                subscriptions.Apply(sub => sub.Dispose());
            } catch {
                // Assuming that failing on dispose, means that it is already Disposed. The channel and connection will be closed below anyway
            }

            var cleanupActions = new List<Action>();

            cleanupActions.Add(() => {
                try {
                    if (channel.IsValueInitialized) {
                        channel.Value.Dispose();
                    }
                } catch {
                    // Assuming that failing on dispose, means that it is already Disposed
                }
            });

            cleanupActions.Add(() => {
                try {
                    if (connection.IsValueInitialized) {
                        connection.Value.Dispose();
                    }
                } catch {
                    // Assuming that failing on dispose, means that it is already Disposed
                }
            });

            executor.TriggerCleanupState(cleanupActions);

            executor.Dispose();
            AppDomain.CurrentDomain.DomainUnload -= OnAppDomainUnload;
        }
    }
}
