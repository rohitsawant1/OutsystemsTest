/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Linq;
using System.Threading;
using System.Web;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.Xml;
using OutSystems.HubEdition.RuntimePlatform;
using OutSystems.HubEdition.RuntimePlatform.Db;
using OutSystems.HubEdition.RuntimePlatform.Internal;
using OutSystems.HubEdition.RuntimePlatform.Log;
using OutSystems.HubEdition.RuntimePlatform.Processes;
using OutSystems.Internal.Db;
using OutSystems.ObjectKeys;
using OutSystems.RuntimeCommon;

namespace ssContactManager.Processes.Handling {

	public class ActivityActionsHandler: System.Web.Services.WebService {
		public ActivityActionsHandler() {
			// CODEGEN: This call is required by the ASP.NET Web Services Designer
			InitializeComponent();
		}

		#region Component Designer generated code

		// Required by the Web Services Designer
		private IContainer components = null;

		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent() {
		}

		/// Clean up any resources being used.
		protected override void Dispose(bool disposing) {
			if (disposing && components != null) {
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#endregion

		[WebMethod()]
		public int ExecuteProcessDefEvent(string ssKey, int tenantId, string dataId) {
			int processId = 0;

			bool res = false;
			res = ExecuteWebService("ProcessImplicitLaunch",
			delegate(HeContext heContext) {
				return ExecuteProcessWebService(heContext, ssKey, tenantId, 0, string.Empty,
				delegate(IProcess execObj) {
					execObj.ProcessImplicitLaunch(heContext, dataId, out processId);
				});
			}
			,
			false);

			return (res ? processId: BuiltInFunction.NullIdentifier());
		}

		[WebMethod()]
		public int ExecuteProcessLaunch(string ssKey, int tenantId, int userId, int parentActivityId, int parentProcessId, List<Pair<string, object>> inputs, out List<Pair<int, ActivityKind>> nextActIds, out string failureMessage) {
			List<Pair<int, ActivityKind>> nextActivitiesIds = new List<Pair<int, ActivityKind>>();
			int newProcessId = 0;
			failureMessage = string.Empty;
			nextActIds = nextActivitiesIds;

			bool res;
			try {
				res = ExecuteWebService("ProcessLaunch",
				delegate(HeContext heContext) {
					return ExecuteProcessWebService(heContext, ssKey, tenantId, userId, string.Empty,
					delegate(IProcess execObj) {
						newProcessId = execObj.ProcessLaunch(heContext, parentActivityId, parentProcessId, inputs, out nextActivitiesIds);
					});
				}
				,
				false);

				nextActIds = nextActivitiesIds;
			} catch (Exception e) {
				failureMessage = ProcessBase.ProcessException(Global.App.OsContext, e, "",/*skipLog*/ true); ;
				return 0;
			}

			return res ? newProcessId: 0;
		}

		[WebMethod()]
		public bool ExecuteProcessTerminate(string ssKey, int processId, int tenantId, int userId, out string failureMessage) {
			bool success = false;
			string failureMessageLocal = string.Empty;

			bool res = ExecuteWebService("ProcessTerminate",
			delegate(HeContext heContext) {
				return ExecuteProcessWebService(heContext, ssKey, tenantId, userId, string.Empty,
				delegate(IProcess execObj) {
					success = execObj.ProcessTerminate(heContext, processId, out failureMessageLocal);
				});
			}
			,
			false);

			failureMessage = (res ? failureMessageLocal: "Internal Error.");
			return res && success;
		}

		[WebMethod()]
		public bool ExecuteSetProcessSuspension(string ssKey, int processId, int tenantId, int userId, bool suspend, out string failureMessage) {
			bool success = false;
			string failureMessageLocal = string.Empty;



			bool res = ExecuteWebService("ProcessSuspend",
			delegate(HeContext heContext) {
				return ExecuteProcessWebService(heContext, ssKey, tenantId, userId, string.Empty,
				delegate(IProcess execObj) {
					success = execObj.SetProcessSuspension(heContext, processId, suspend, out failureMessageLocal);
				});
			}
			,
			false);

			failureMessage = (res ? failureMessageLocal: "Internal Error.");
			return res && success;
		}

		[WebMethod()]
		public bool ExecuteActivityActionv2(string ssKey, int activityId, int processId, int tenantId, ActivityStatus forInitialStatus, DateTime previousNextRun) {

			return ExecuteWebService("ExecuteActivityActionv2",
			delegate(HeContext heContext) {
				return ExecuteActivityWebService(heContext, ssKey, activityId, processId, tenantId, 0, string.Empty,
				delegate(IProcessActivity execObj) {
					execObj.StartWork(heContext,/*isUnattended*/ true, forInitialStatus, previousNextRun);
				});
			}
			,
			true);
		}

		[WebMethod()]
		public bool ExecuteOnEvent(string ssKey, int activityId, int processId, int tenantId, string dataId, bool advanceProcess) {

			return ExecuteWebService("ExecuteOnEvent",
			delegate(HeContext heContext) {
				return ExecuteActivityWebService(heContext, ssKey, activityId, processId, tenantId, 0, string.Empty,
				delegate(IProcessActivity execObj) {
					execObj.StartOnEvent(heContext, dataId, advanceProcess);
				});
			}
			,
			false);
		}

		[WebMethod()]
		public bool ExecuteSetEventFilters(string ssKey, int activityId, int processId, int tenantId) {

			return ExecuteWebService("SetActivityEventFilters",
			delegate(HeContext heContext) {
				return ExecuteActivityWebService(heContext, ssKey, activityId, processId, tenantId, 0, string.Empty,
				delegate(IProcessActivity execObj) {
					execObj.StartSetEventFilters(heContext);
				});
			}
			,
			false);
		}

		[WebMethod()]
		public bool ExecuteRemoveEventFilters(string ssKey, int activityId, int processId, int tenantId) {
			return ExecuteWebService("RemoveActivityEventFilters",
			delegate(HeContext heContext) {
				return ExecuteActivityWebService(heContext, ssKey, activityId, processId, tenantId, 0, string.Empty,
				delegate(IProcessActivity execObj) {
					execObj.StartRemoveEventFilters(heContext);
				});
			}
			,
			false);
		}

		[WebMethod()]
		public bool ExecuteOnOpen(string ssKey, int activityId, int processId, int tenantId, int userId, string locale, string sessionId, bool requestIsSecure, string hostname, bool onlyGetUrl, out string failureMessage, out string handlingUrl) {
			bool success = false;
			string failureMessageLocal = string.Empty;
			string handlingUrlLocal = string.Empty;

			bool res = ExecuteWebService("OnOpen",
			delegate(HeContext heContext) {
				return ExecuteActivityWebService(heContext, ssKey, activityId, processId, tenantId, userId, locale,
				delegate(IProcessActivity execObj) {
					success = execObj.StartOnOpen(heContext, sessionId, requestIsSecure, hostname, onlyGetUrl, out failureMessageLocal, out handlingUrlLocal);
				});
			}
			,
			false);

			failureMessage = (res ? failureMessageLocal: "Internal Error.");
			handlingUrl = (res ? handlingUrlLocal: string.Empty);
			return res && success;
		}

		[WebMethod()]
		public bool ExecuteActivityReset(string ssKey, int activityId, int processId, bool resetActivityUser, int tenantId, int userId, string locale, out string failureMessage) {
			bool success = false;
			string failureMessageLocal = string.Empty;

			bool res = ExecuteWebService("ActivityReset",
			delegate(HeContext heContext) {
				return ExecuteActivityWebService(heContext, ssKey, activityId, processId, tenantId, userId, locale,
				delegate(IProcessActivity execObj) {
					success = execObj.StartActivityReset(heContext, activityId, resetActivityUser, out failureMessageLocal);
				});
			}
			,
			false);

			failureMessage = (res ? failureMessageLocal: "Internal Error.");
			return res && success;
		}

		[WebMethod()]
		public bool ExecuteActivitySchedule(string ssKey, int activityId, int processId, DateTime startDate, int tenantId, int userId, string locale, out string failureMessage) {
			bool success = false;
			string failureMessageLocal = string.Empty;

			bool res = ExecuteWebService("ActivitySchedule",
			delegate(HeContext heContext) {
				return ExecuteActivityWebService(heContext, ssKey, activityId, processId, tenantId, userId, locale,
				delegate(IProcessActivity execObj) {
					success = execObj.StartActivitySchedule(heContext, activityId, startDate, out failureMessageLocal);
				});
			}
			,
			false);

			failureMessage = (res ? failureMessageLocal: "Internal Error.");
			return res && success;
		}

		[WebMethod()]
		public bool ExecuteOnClose(string ssKey, int activityId, int processId, int tenantId, int userId, string locale, bool advanceProcess, bool skip, bool skipAll, List<Pair<string, object>> inputs, out string failureMessage, out List<Pair<int, ActivityKind>> nextActIds) {
			bool success = false;
			string failureMessageLocal = string.Empty;
			List<Pair<int, ActivityKind>> nextActIdsLocal = null;

			bool res = ExecuteWebService("OnClose",
			delegate(HeContext heContext) {
				return ExecuteActivityWebService(heContext, ssKey, activityId, processId, tenantId, userId, locale,
				delegate(IProcessActivity execObj) {
					success = execObj.StartOnClose(heContext, advanceProcess, skip, skipAll, inputs, out failureMessageLocal, out nextActIdsLocal);
				});
			}
			,
			false);

			failureMessage = (res ? failureMessageLocal: "Internal Error.");
			nextActIds = (res ? nextActIdsLocal: new List<Pair<int, ActivityKind>>(0));
			return res && success;
		}

		private bool ExecuteWebService(string name, Func<HeContext, bool> method, bool isUnattended) {
			if (HttpContext.Current == null) {
				GeneralLog.StaticWrite(DateTime.Now, "", 0, 0, 0, name + " Called (Context is null)", GeneralLogType.WARNING.ToString(), "", "");
			} else {
				HeContext heContext = Global.App.OsContext;

				int timeout = 0;
				if (isUnattended) {
					timeout = SchedulerAutomaticActivitiesTimeout;
				} else {
					timeout = SchedulerActivitiesTimeout;
				}



				SetWebserviceTimeout(heContext, timeout);

				bool processedOk = false;
				try {
					processedOk = method(heContext);
					return processedOk;
				} catch (Exception e) {
					if (e.InnerException != null && (e is TypeInitializationException)) {
						throw e.InnerException;
					} else {
						throw;
					}
				} finally {
					DatabaseAccess.FreeupResources(processedOk);
				}
			}
			return false;
		}

		private void ValidateToken(HeContext heContext, int userId, int tenantId, string eSpaceKey) {

			if (!HttpContext.Current.Request.Headers.AllKeys.Contains("Authorization")) {
				// check if in compatibility mode with pre-O11 versions
				if (RuntimePlatformSettings.Authentication.ReferencesAllowLegacyAuth.GetValue()) {
					// Check if the request is from a valid IP
					if (!NetworkInterfaceUtils.IsLoopbackAddress(HttpContext.Current.Request.UserHostAddress)) {
						ErrorLog.StaticWrite(DateTime.Now,
						heContext.Session.SessionID,
						heContext.AppInfo != null ? heContext.AppInfo.eSpaceId: 0,
						heContext.AppInfo != null ? heContext.AppInfo.Tenant.Id: 0,
						heContext.Session.UserId,
						 "Access to ActivityActionsHandler with invalid IP: " + HttpContext.Current.Request.UserHostAddress,
						 "The activity actions handler can only be accessed by the 127.0.0.1 IP", "BPM");

						throw new Exception("The activity actions handler can only be accessed by the 127.0.0.1 IP");
					} else {
						// Request is valid in compatibility mode
						return;
					}
				} else {
					throw new Exception("Token validation failed");
				}

			}

			SecurityTokenManager.ValidateAuthorizationHeader(
			RuntimeSettingsProvider.Instance,
			HttpContext.Current.Request.Headers["Authorization"],
			userId,
			tenantId,
			eSpaceKey);
		}

		private bool ExecuteActivityWebService(HeContext heContext, string ssKey, int activityId, int processId, int tenantId, int userId, string locale, Action<IProcessActivity> activityMethod) {

			ValidateToken(heContext, userId, tenantId, heContext.AppInfo.eSpaceUID);

			ObjectKey activityKey = ObjectKey.Parse(ssKey);
			IProcessActivity execObj = null;

			if (AbstractProcessActivity.GetProcessActivityImplementation(processId, activityId, activityKey, true, out execObj)) {
				SetContextInfo(heContext, tenantId, userId, locale);
				heContext.AppInfo.CheckIsApplicationEnabled();


				try {
					heContext.AllowTenantSwitch = false;
					activityMethod(execObj);
				} finally {
					heContext.AllowTenantSwitch = true;
				}
				return true;
			} else {
				ErrorLog.StaticWrite(DateTime.Now, heContext.Session.SessionID, Global.eSpaceId, heContext.AppInfo.Tenant.Id,
				heContext.Session.UserId, "Activity '" + ssKey + "' isn't mapped to an object at Runtime", (new System.Diagnostics.StackTrace(true)).ToString(), "");
				return false;
			}
		}

		private bool ExecuteProcessWebService(HeContext heContext, string ssKey, int tenantId, int userId, string locale, Action<IProcess> processMethod) {

			ValidateToken(heContext, userId, tenantId, heContext.AppInfo.eSpaceUID);

			ObjectKey processKey = ObjectKey.Parse(ssKey);
			IProcess execObj = null;
			if (AbstractProcess.GetProcessDefinition(processKey, out execObj)) {
				SetContextInfo(heContext, tenantId, userId, locale);
				heContext.AppInfo.CheckIsApplicationEnabled();

				processMethod(execObj);
				return true;
			} else {
				ErrorLog.StaticWrite(DateTime.Now, heContext.Session.SessionID, Global.eSpaceId, heContext.AppInfo.Tenant.Id,
				heContext.Session.UserId, "Process " + ssKey + " isn't mapped to an object at Runtime", (new System.Diagnostics.StackTrace(true)).ToString(), "");
				return false;
			}
		}

		private void SetContextInfo(HeContext heContext, int tenantId, int userId, string locale) {
			if (tenantId != 0) {
				heContext.Session.TenantId = tenantId;
			}
			if (userId != 0) {
				heContext.Session.UserId = userId;
			}
			GenericExtendedActions.SetCurrentLocale(heContext, locale);
		}

		private static int SchedulerActivitiesTimeout = RuntimePlatformSettings.BPT.ActivitiesTimeout.GetValue();
		private static int SchedulerAutomaticActivitiesTimeout = RuntimePlatformSettings.BPT.AutomaticActivitiesTimeout.GetValue();

		private void SetWebserviceTimeout(HeContext heContext, int timeout) {
			// from tests in framework 1.0, it seems this ScriptTimeout is not working as expected...
			// but it seems in framework 1.1 it works fine (if not in debug mode)
			heContext.Context.Server.ScriptTimeout = timeout;
		}
	}
}
