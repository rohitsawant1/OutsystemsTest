/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Text;

namespace OutSystems.RuntimeCommon {

    /***
     * Wrapper for the Process class that provides access to local and remote
     * processes and enables you to start and stop local system processes.
     * Also provides methods to read the console output and console error.
     */
    public class SystemProcess : IDisposable {

        private const string PROCESS_NOT_LAUNCHED_MSG = "Process was not yet started";
        private const string PROCESS_ALREADY_DISPOSED_MSG = "Process was already disposed";

        private bool disposed = false;
        private string command;
        private string inlineArguments;
        private string path;
        
        private bool redirectOutputs;
        
        private bool? hidden;

        private ProcessPriorityClass priority;
        
        private string username;
        
        private string domain;
        
        private string password;

        private Action<String> errHandle;

        private Action<String> outHandle;

        private Process process;
        public Process Process {
            get {
                CheckProcessStatus();
                return this.process;
            }
        }

        public bool Exists {
            get {
                return this.process != null && this.process.Handle != IntPtr.Zero;
            }
        }

        public int ExitCode {
            get {
                return this.Process.ExitCode;
            }
        }

        public bool HasExecutionErrors {
            get {
                return this.Process.StandardError.Peek() != -1 || this.Process.ExitCode != 0;
            }
        }

        public bool HasExited {
            get {
                return this.Process.HasExited;
            }
        }

        public SystemProcess(string command) {
            this.command = command;
        }
        
        public void Execute() {
            this.process = new Process();
            this.process.StartInfo = new ProcessStartInfo(command, inlineArguments);
            this.process.StartInfo.UseShellExecute = false;
            if (!hidden.HasValue || hidden == true) {
                this.process.StartInfo.WindowStyle = ProcessWindowStyle.Minimized;
                this.process.StartInfo.CreateNoWindow = true;
            }
            if (hidden == true) {
                this.process.StartInfo.ErrorDialog = false;
            }
            if (this.redirectOutputs) {
                this.process.StartInfo.RedirectStandardOutput = true;
                this.process.StartInfo.RedirectStandardError = true;
                if (outHandle != null) {
                    this.process.OutputDataReceived += new DataReceivedEventHandler((sender, e) => {
                        if (!String.IsNullOrEmpty(e.Data)) {
                            outHandle(e.Data);
                        }
                    });
                }
                if (errHandle != null) {
                    this.process.ErrorDataReceived += new DataReceivedEventHandler((sender, e) => {
                        if (!String.IsNullOrEmpty(e.Data)) {
                            errHandle(e.Data);
                        }
                    });
                }
            }
            if (path != null) {
                this.process.StartInfo.WorkingDirectory = path;
            }

            this.process.StartInfo.UserName = username;
            this.process.StartInfo.Domain = domain;
            if (!String.IsNullOrEmpty(password)) {
                this.process.StartInfo.Password = new System.Security.SecureString();
                foreach (var c in password) {
                    this.process.StartInfo.Password.AppendChar(c);
                }
                this.process.StartInfo.Password.MakeReadOnly();
            }

            this.process.Start();
            if(errHandle != null) {
                this.process.BeginErrorReadLine();
            }
            if(outHandle != null) {
                this.process.BeginOutputReadLine();
            }

            this.process.PriorityClass = priority;
        }
        
        public void WaitForExit() {
            this.Process.WaitForExit();
        }

        public bool WaitForExit(int milliseconds) {
            return this.Process.WaitForExit(milliseconds);
        }

        // waits for the end of a process maxTime time
        public bool HasEnded(int maxTime) {
            return Process.WaitForExit(maxTime);
        }

        public void OnExit(Action<object, EventArgs> eventHandler) {
            if (!Process.EnableRaisingEvents) {
                Process.EnableRaisingEvents = true;
            }

            Process.Exited += new System.EventHandler(eventHandler);
        }

        public void Kill() {
            this.Process.Kill();
        }

        public string ReadStandardOutput() {
            return this.Process.StandardOutput.ReadToEnd();
        }

        public string ReadStandardError() {
            return this.Process.StandardError.ReadToEnd();
        }

        public void ReadToEnd(int timeout, out string errorString, out string outputString, out bool aborted) {
            ProcessConsoleRead.ReadToEnd(this.Process, timeout, out errorString, out outputString, out aborted);
        }

        public void ReadToEnd(int timeout, out string errorString, out string outputString, out bool aborted, Encoding encoding) {
            ProcessConsoleRead.ReadToEnd(this.Process, timeout, out errorString, out outputString, out aborted, encoding);
        }

        public void ReadProgressive(out StreamHandle errorStream, out StreamHandle outputStream, Encoding encoding) {
            ProcessConsoleRead.ReadProgressive(this.Process, out errorStream, out outputStream, encoding);
        }

        public void Dispose() {
            if (!this.disposed) {
                if (this.process != null) {
                    this.process.Dispose();
                    this.process = null;
                }
                this.disposed = true;
            }
        }

        private void CheckProcessStatus() {
            if (this.disposed) {
                throw new InvalidOperationException(PROCESS_ALREADY_DISPOSED_MSG);
            }
            if (this.process == null) {
                throw new InvalidOperationException(PROCESS_NOT_LAUNCHED_MSG);
            }
        }
        
        private static SystemProcess Launch(string command, string commandParams, string path, bool redirectOutputs, bool? hidden, ProcessPriorityClass priority, string username, string domain, string password, Action<string> outHandle = null, Action<string> errHandle = null) {
            var process = new SystemProcess(command);
            process.inlineArguments = commandParams;
            process.path = path;
            process.redirectOutputs = redirectOutputs;
            if (redirectOutputs && errHandle != null && outHandle != null) {
                process.errHandle = errHandle;
                process.outHandle = outHandle;
            }
            process.hidden = hidden;
            process.priority = priority;
            process.username = username;
            process.domain = domain;
            process.password = password;
            process.Execute();
            return process;
        }

        /// <summary>
        /// Launches a process.
        /// </summary>
        /// <remarks>
        /// The output and error streams are redirected.
        /// It is advised to read its contents to prevent the process from hanging by writing to a full buffer.
        /// </remarks>
        public static SystemProcess Launch(string command, string commandParams, string path, ProcessPriorityClass priority, string username, string domain, string password) {
            return Launch(command, commandParams, path, /* redirectOutputs */ true, null, priority, username, domain, password);
        }


        /// <summary>
        /// Launches a process.
        /// </summary>
        /// <remarks>
        /// The output and error streams are redirected.
        /// It is advised to read its contents to prevent the process from hanging by writing to a full buffer.
        /// </remarks>
        public static SystemProcess Launch(String command, String commandParams, String path, ProcessPriorityClass priority) {
            return Launch(command, commandParams, path, /* redirectOutputs */ true, null, priority, null, null, null);
        }

        /// <summary>
        /// Launches a process.
        /// </summary>
        /// <remarks>
        /// The output and error streams are not redirected making them not available for read
        /// </remarks>
        public static SystemProcess Launch(String command, String commandParams, bool hidden, ProcessPriorityClass priority) {
            // LEGACY STUFF: Outputs are not redirected because the code that uses this method does not read them
            // Setting it to true may cause the system process to hang waiting for the outputs to be read
            // which causes the launcher process to hang waiting for the system process to end
            return Launch(command, commandParams, null, /* redirectOutputs */ false, hidden, priority, null, null, null);
        }

        private static SystemProcess Launch(string command, SystemProcessArguments commandParams, string path, bool redirectOutputs, bool? hidden, ProcessPriorityClass priority, string username, string domain, string password, Action<string> outHandle = null, Action<string> errHandle = null) {
            return Launch(command, commandParams.ToString(), path, redirectOutputs, hidden, priority, username, domain, password, outHandle, errHandle);
        }

        /// <summary>
        /// Launches a process.
        /// </summary>
        /// <remarks>
        /// The output and error streams are redirected.
        /// It is advised to read its contents to prevent the process from hanging by writing to a full buffer.
        /// </remarks>

        public static SystemProcess Launch(String command, SystemProcessArguments commandParams, String path, ProcessPriorityClass priority, Action<string> outHandle = null, Action<string> errHandle = null) {
            return Launch(command, commandParams, path, true, null, priority, null, null, null, outHandle, errHandle);
        }

        /// <summary>
        /// Launches a process.
        /// </summary>
        /// <remarks>
        /// The output and error streams are not redirected making them not available for read
        /// </remarks>
        public static SystemProcess Launch(String command, SystemProcessArguments commandParams, bool hidden, ProcessPriorityClass priority) {
            // LEGACY STUFF: Outputs are not redirected because the code that uses this method does not read them
            // Setting it to true may cause the system process to hang waiting for the outputs to be read
            // which causes the launcher process to hang waiting for the system process to end
            return Launch(command: command, commandParams: commandParams, path: null, redirectOutputs: false, hidden: hidden, priority: priority, username: null, domain: null, password: null);
        }
    }
}
