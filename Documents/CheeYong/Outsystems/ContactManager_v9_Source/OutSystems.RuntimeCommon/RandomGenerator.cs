/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Security.Cryptography;

namespace OutSystems.RuntimeCommon {
    public class RandomGenerator : Random {

        /// <summary>
        /// A random number generator that can be used for security-sensitive operations (based on RNGCryptoServiceProvider)
        /// and also for non security-sensitive operations (based on Random).
        /// 
        /// The behaviour for security-sensitive operations was adapted from the "Tales from the CryptoRandom" 
        /// article in MSDN Magazine (September 2007) but with explicit guarantee to be thread safe. This implementation also includes
        /// a random buffer which provides a significant speed boost as it greatly reduces the amount of calls into unmanaged land.
        /// 
        /// For non security-sensitive operations, this is just a wrapper around Random
        /// 
        /// See: https://gist.github.com/niik/1017834
        /// </summary>

        private bool IsSecure { get; set; } = false;

        // The initialization of the secure random takes a while, so we do it as soon as the class is loaded
        private static RNGCryptoServiceProvider _secureRandom = new RNGCryptoServiceProvider();
        private static Random _globalRandom = new Random();

        [ThreadStatic]
        private static Random _localRandom;

        private static Random LocalRandom {
            get {
                if (_localRandom == null) {
                    int seed;
                    lock (_globalRandom) {
                        // Making sure all Thread Local Randoms use different seeds.
                        seed = _globalRandom.Next();
                    }
                    _localRandom = new Random(seed);
                }
                return _localRandom;
            }
            set {
                _localRandom = value;
            }
        }

        private RandomGenerator(bool secure) {
            IsSecure = secure;
        }

        /**
         * Creates a new Random Provider that uses a secure random generator,
         * which can be used for cryptographic or other security-sensitive operations
         */
        public static RandomGenerator GetSecureRandomGenerator() {
            return new RandomGenerator(/*secure*/true);
        }

        /**
         * Creates a new Random Provider, which can be used for any kind of operations in which security is not an issue
         */
        public static RandomGenerator GetRandomGenerator() {
            return new RandomGenerator(/*secure*/false);
        }

        private byte[] randomPool;
        private int randomPoolPosition;
        private readonly object randomPoolLock = new object();

        private void InitBuffer() {
            if (randomPool == null || randomPool.Length != 512) {
                randomPool = new byte[512];
            }

            _secureRandom.GetBytes(randomPool);
            randomPoolPosition = 0;
        }

        /// <summary>
        /// Returns a nonnegative random number.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer greater than or equal to zero and less than <see cref="F:System.Int32.MaxValue"/>.
        /// </returns>
        public override int Next() {
            if (IsSecure) {
                // Mask away the sign bit so that we always return nonnegative integers
                return (int)GetRandomUInt32() & 0x7FFFFFFF;
            }

            return LocalRandom.Next();
        }

        /// <summary>
        /// Returns a nonnegative random number less than the specified maximum.
        /// </summary>
        /// <param name="maxValue">The exclusive upper bound of the random number to be generated. <paramref name="maxValue"/> must be greater than or equal to zero.</param>
        /// <returns>
        /// A 32-bit signed integer greater than or equal to zero, and less than <paramref name="maxValue"/>; that is, the range of return values ordinarily includes zero but not <paramref name="maxValue"/>. However, if <paramref name="maxValue"/> equals zero, <paramref name="maxValue"/> is returned.
        /// </returns>
        public override int Next(int maxValue) {
            if (IsSecure) {
                if (maxValue < 0) {
                    throw new ArgumentOutOfRangeException("maxValue");
                }
                
                return Next(0, maxValue);
            }

            return LocalRandom.Next(maxValue);
        }

        /// <summary>
        /// Returns a random number within a specified range.
        /// </summary>
        /// <param name="minValue">The inclusive lower bound of the random number returned.</param>
        /// <param name="maxValue">The exclusive upper bound of the random number returned. <paramref name="maxValue"/> must be greater than or equal to <paramref name="minValue"/>.</param>
        /// <returns>
        /// A 32-bit signed integer greater than or equal to <paramref name="minValue"/> and less than <paramref name="maxValue"/>; that is, the range of return values includes <paramref name="minValue"/> but not <paramref name="maxValue"/>. If <paramref name="minValue"/> equals <paramref name="maxValue"/>, <paramref name="minValue"/> is returned.
        /// </returns>
        public override int Next(int minValue, int maxValue) {
            if (IsSecure) {
                if (minValue > maxValue) {
                    throw new ArgumentOutOfRangeException("minValue");
                }

                if (minValue == maxValue) {
                    return minValue;
                }

                long diff = maxValue - minValue;

                while (true) {
                    uint rand = GetRandomUInt32();
                    long max = 1 + (long)uint.MaxValue;
                    long remainder = max % diff;

                    if (rand < max - remainder) {
                        return (int)(minValue + (rand % diff));
                    }
                }
            }

            // Using an inline st instruction here, since we don't want to use the one in the mappings which would generate a stack overflow...
            return LocalRandom.Next(minValue, maxValue);
        }

        /// <summary>
        /// Returns a random number between 0.0 and 1.0.
        /// </summary>
        /// <returns>
        /// A double-precision floating point number greater than or equal to 0.0, and less than 1.0.
        /// </returns>
        public override double NextDouble() {
            if (IsSecure) {
                return GetRandomUInt32() / (1.0 + uint.MaxValue);
            }

            return LocalRandom.NextDouble();
        }

        /// <summary>
        /// Fills the elements of a specified array of bytes with random numbers.
        /// </summary>
        /// <param name="buffer">An array of bytes to contain random numbers.</param>
        public override void NextBytes(byte[] buffer) {
            if (IsSecure) {
                if (buffer == null) {
                    throw new ArgumentNullException("buffer");
                }

                lock (randomPoolLock) {
                    if (randomPool == null) {
                        InitBuffer();
                    }

                    // Can we get the requested number of bytes from the buffer?
                    if (buffer.Length <= randomPool.Length) {
                        int count = buffer.Length;
                        EnsureRandomBuffer(count);
                        Buffer.BlockCopy(randomPool, randomPoolPosition, buffer, 0, count);
                        randomPoolPosition += count;
                    } else {
                        _secureRandom.GetBytes(buffer);
                    }
                }
            } else {
                LocalRandom.NextBytes(buffer);
            }
        }

        /// <summary>
        /// Gets one random unsigned 32bit integer in a thread safe manner. Only used if we need a secure random.
        /// </summary>
        private uint GetRandomUInt32() {
            lock (randomPoolLock) {
                EnsureRandomBuffer(4);
                uint rand = BitConverter.ToUInt32(randomPool, randomPoolPosition);
                randomPoolPosition += 4;
                return rand;
            }
        }

        /// <summary>
        /// Ensures that we have enough bytes in the random buffer. Only used if we need a secure random.
        /// </summary>
        /// <param name="requiredBytes">The number of required bytes.</param>
        private void EnsureRandomBuffer(int requiredBytes) {
            if (randomPool == null) {
                InitBuffer();
            }

            if (requiredBytes > randomPool.Length) {
                throw new ArgumentOutOfRangeException("requiredBytes", "cannot be greater than random buffer");
            }

            if ((randomPool.Length - randomPoolPosition) < requiredBytes) {
                InitBuffer();
            }
        }
    }
}
