/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Runtime.Serialization;
using System.Security;
using System.Security.Permissions;
using OutSystems.RuntimeCommon;

namespace OutSystems.ObjectKeys {

    [Serializable]
    public abstract partial class ObjectKey : IComparable, IComparable<ObjectKey>, ISerializable {

        public const char SeparatorChar = '.';
        public const string FullFormat = "F";
        public const string ShortFormat = "S";
        public const string LocalKeyPrefix = "#";
        public const string DatabaseFormat = "DB";

        // this array contains the prefixes for keys that remain with their pre-5.0 value
        private static bool IsAPre50KeyToKeep(string str) {
            if (str.StartsWith("PermissionArea") || 
                str.StartsWith("EntityRecord") ||
                (str.StartsWith("Entity") && !str.StartsWith("EntityIndex"))) {
                return true;
            }

            return false;
        }

        public static readonly ObjectKey Dummy = ObjectKey.NewKey(Guid.Empty);


        [SecurityCritical]
        [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]
        void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context) {
            info.AddValue(SerializationHelper.SerializedKeyName, GetSerializationInfoData());

            // Instead of serializing this object, 
            // serialize a SerializationHelper instead.
            info.SetType(typeof(SerializationHelper));
        }

        protected virtual string GetSerializationInfoData() {
            return ToString(ObjectKey.FullFormat);
        }

        protected delegate int SpecificTypeDelegate<SpecificType>(SpecificType specificType);

        protected int DefaultCompareTo<SpecificType>(ObjectKey obj, SpecificTypeDelegate<SpecificType> specificTypeComparer)
            where SpecificType : ObjectKey {

            SpecificType other = obj as SpecificType;

            if (ReferenceEquals(other, null)) {
                return KeyType.CompareTo(obj.KeyType);
            } else {
                return specificTypeComparer(other);
            }
        }

        public virtual bool NeedsParent { get { return false; } }

        public virtual ObjectKey Parent {
            get { return null; }
            set { throw new InvalidOperationException(); }
        }

        public static ObjectKey Parse(string str) {
            if (string.IsNullOrEmpty(str) || str == " ") {
                return null;
            }

            int separatorPos = str.LastIndexOf(SeparatorChar);

            if (separatorPos == -1) {
                if (str.StartsWith(LocalKeyPrefix)) {
                    return new LocalKey(LocalKeyValueUtils.ToLocalKeyValue(str.Substring(LocalKeyPrefix.Length)));
                } else if (IsAPre50KeyToKeep(str)) {
                    return new Pre50Key(str);
                } else if (str.Length < Constants.MinimumExtendedGuidLength) {
                    Guid guid = Base64.GuidFromBase64(str);
                    if (guid != Guid.Empty) {
                        return new GuidKey(guid);
                    }
                    return null;
                } else {
                    if (GuidUtils.IsGuid(str)) {
                        return new GuidKey(new Guid(str));
                    }
                    return null;
                }
            }

            ObjectKey key = Parse(str.Substring(separatorPos + 1));
            if (key == null) {
                return null;    
            }

            key.Parent = Parse(str.Substring(0, separatorPos));
            return key;
        }

        public delegate ObjectKey KeyPartDecoderDelegate(string str);

        public static ObjectKey Parse(string str, KeyPartDecoderDelegate keyPartDecoder) {
            int separatorPos = str.LastIndexOf(SeparatorChar);

            if (separatorPos == -1) {
                return keyPartDecoder(str);
            }

            ObjectKey key = keyPartDecoder(str.Substring(separatorPos + 1));
            key.Parent = Parse(str.Substring(0, separatorPos), keyPartDecoder);
            return key;
        }

        public static ObjectKey NewKey() {
            return new GuidKey(Guid.NewGuid());
        }

        public static ObjectKey NewKey(Guid guid) {
            return new GuidKey(guid);
        }

        public static ObjectKey NewKey(LocalKeyValue localKey) {
            return new LocalKey(localKey);
        }

        /// <summary>
        /// Should be used only for the cases in which we want to preserve the pre 5.0 key as is
        /// (e.g., that is what happens for roles and static entity records)
        /// </summary>
        /// <param name="verbatimKeyValue"></param>
        /// <returns></returns>
        public static ObjectKey NewKey(string verbatimKeyValue) {
            return new Pre50Key(verbatimKeyValue);
        }

        /// <summary>
        /// This method should only be used inside compound keys or merge
        /// </summary>
        public virtual bool EqualsIgnoringParent(ObjectKey obj) {
            return this.Equals(obj);
        }

        /// <summary>
        /// This method should only be used inside compound keys
        /// </summary>
        public virtual int GetHashCodeIgnoringParent() {
            return this.GetHashCode();
        }

        public override bool Equals(object obj) {
            throw new InvalidOperationException();
        }

        public override int GetHashCode() {
            throw new InvalidOperationException();
        }

        public static bool operator ==(ObjectKey a, ObjectKey b) {
            if (ReferenceEquals(a, null)) {
                return ReferenceEquals(b, null);
            }
            return a.Equals(b);
        }

        public static bool operator !=(ObjectKey a, ObjectKey b) {
            if (ReferenceEquals(a, null)) {
                return !ReferenceEquals(b, null);
            }
            return !a.Equals(b);
        }

        public bool IsAnyOf(params ObjectKey[] keys) {
            foreach (var key in keys) {
                if (Equals(key)) {
                    return true;
                }
            }
            return false;
        }

        public int CompareTo(object obj) {
            ObjectKey other = obj as ObjectKey;
            if (other == null) {
                return -1;
            }
            return CompareTo(other);
        }

        public abstract int CompareTo(ObjectKey obj);
        public abstract string ToString(string format);

        public abstract bool IsLocal { get; }
        protected abstract ObjectKeyType KeyType { get; }

        public virtual LocalKeyValue LocalPart {
            get { throw new InvalidOperationException("Not a local key"); }
        }

        public virtual Guid AsGuid {
            get { return Guid.Empty; }
        }

        public abstract ObjectKey Duplicate();

        private string asIdentifier;
        public string AsIdentifier() {
            if (asIdentifier == null) {
                asIdentifier = "K" + StringUtils.WithoutInvalidChars(ToString());
            }
            return asIdentifier;
        }
        
        public override string ToString() {
            return ToString(ObjectKey.FullFormat);
        }
    }
}