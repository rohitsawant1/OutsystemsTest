/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;

namespace OutSystems.RuntimeCommon {

    public static class Base64 {

        private static readonly uint[] fromBase64 = new uint[128];
        private static readonly char[] toBase64 = new char[64];

        private const uint INVALID_VALUE = 64;

        static Base64() {
            string base64Chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_+";
            for (int i = 0; i < 128; ++i) {
                fromBase64[i] = INVALID_VALUE;
            }
            for (int i = 0; i < 64; ++i) {
                char base64Char = base64Chars[i];
                fromBase64[base64Char] = (uint)i;
                toBase64[i] = base64Char;
            }
        }

        public static ulong ULongFromBase64(string str) {
            ulong result = 0;
            foreach (char base64Char in str) {
                uint value = fromBase64[base64Char];
#if DEBUG
                if (value == INVALID_VALUE) {
                    throw new InvalidOperationException("Not a Base64 string");
                }
#endif
                result = (result << 6) + value;
            }
            return result;
        }

        public static long LongFromBase64(string str) {
            return (long)ULongFromBase64(str);
        }

        public static uint UIntFromBase64(string str) {
            return (uint)ULongFromBase64(str);
        }

        public static int IntFromBase64(string str) {
            return (int)ULongFromBase64(str);
        }

        public static ushort UShortFromBase64(string str) {
            return (ushort)ULongFromBase64(str);
        }

        public static short ShortFromBase64(string str) {
            return (short)ULongFromBase64(str);
        }

        public static Guid GuidFromBase64(string str) {
            int padding = 24 - str.Length;
            str = str.Replace('_', '/');
            if (padding == 2) {
                str += "==";
            } else if (padding == 1) {
                str += "=";
            }
            if ((str.Length % 4) == 0) {
                try {
                    var bytes = Convert.FromBase64String(str);
                    if (bytes != null && bytes.Length == 16) {
                        return new Guid(bytes);
                    }
                } catch(FormatException) {
                    // do nothing
                }
            }

            return Guid.Empty;
        }

        public static string ToBase64(ulong n) {
            if (n == 0) {
                return "0";
            }

            string result = string.Empty;
            while (n != 0) {
                result = toBase64[(int)(n & 0x3f)] + result;
                n = n >> 6;
            }

            return result;
        }

        public static string ToBase64(long n) {
            return ToBase64((ulong)n);
        }

        public static string ToBase64(uint n) {
            return ToBase64((ulong)n);
        }

        public static string ToBase64(int n) {
            return ToBase64((ulong)n);
        }

        public static string ToBase64(ushort n) {
            return ToBase64((ulong)n);
        }

        public static string ToBase64(short n) {
            return ToBase64((ulong)n);
        }

        public static string ToBase64(Guid guid) {
            return Convert.ToBase64String(guid.ToByteArray()).Replace('/', '_').Replace("=", null);
        }
    }
}