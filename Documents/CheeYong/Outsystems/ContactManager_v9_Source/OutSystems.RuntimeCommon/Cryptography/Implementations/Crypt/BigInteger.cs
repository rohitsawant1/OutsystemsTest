/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections;
using System.Globalization;

namespace OutSystems.RuntimeCommon.Cryptography.Implementations.Crypt
{
    public class BigInteger {

        private int sign; // -1 means -ve; +1 means +ve; 0 means 0;

        private int[] magnitude; // array of ints with [0] being the most significant

        private int nBits = -1; // cache BitCount() value

        private int nBitLength = -1; // cache BitLength() value

        private long mQuote = -1L; // -m^(-1) mod b, b = 2^32 (see Montgomery mult.)

        private static readonly long IMASK = 0xffffffffL;

        private static readonly int[] ZeroMagnitude = new int[0];

        private BigInteger() { }

        private BigInteger(int signum, int[] mag) {
            sign = signum;
            if (mag.Length > 0) {
                int i = 0;
                while (i < mag.Length && mag[i] == 0) {
                    i++;
                }
                if (i == 0) {
                    magnitude = mag;
                } else {
                    // strip leading 0 bytes
                    int[] newMag = new int[mag.Length - i];
                    Array.Copy(mag, i, newMag, 0, newMag.Length);
                    magnitude = newMag;
                    if (newMag.Length == 0) {
                        sign = 0;
                    }
                }
            } else {
                magnitude = mag;
                sign = 0;
            }
        }

        public BigInteger(String value) : this(value, 10) { }

        public BigInteger(String value, int radix) {
            if (value.Length == 0) {
                throw new FormatException("Zero length BigInteger");
            }
            NumberStyles style;
            switch (radix) {
                case 10:
                    // This style seems to handle spaces and minus sign already (our processing redundant?)
                    style = NumberStyles.Integer;
                    break;
                case 16:
                    // TODO Should this be HexNumber?
                    style = NumberStyles.AllowHexSpecifier;
                    break;
                default:
                    throw new FormatException("Only base 10 or 16 allowed");
            }
            int index = 0;
            sign = 1;
            if (value[0] == '-') {
                if (value.Length == 1) {
                    throw new FormatException("Zero length BigInteger");
                }
                sign = -1;
                index = 1;
            }
            // strip leading zeros from the string value
            while (index < value.Length && Int32.Parse(value[index].ToString(), style) == 0) {
                index++;
            }
            if (index >= value.Length) {
                // zero value - we're done
                sign = 0;
                magnitude = ZeroMagnitude;
                return;
            }
            //////
            // could we work out the max number of ints required to store
            // value.Length digits in the given base, then allocate that
            // storage in one hit?, then Generate the magnitude in one hit too?
            //////
            BigInteger b = Zero;
            BigInteger r = ValueOf(radix);
            while (index < value.Length) {
                // TODO (optimise this by taking chunks of digits instead?)
                b = b.Multiply(r).Add(ValueOf(Int32.Parse(value[index].ToString(), style)));
                index++;
            }
            magnitude = b.magnitude;
            return;
        }

        public BigInteger(byte[] bytes) {
            if (bytes.Length == 0) {
                throw new FormatException("Zero length BigInteger");
            }
            this.sign = 1;
            if ((sbyte)bytes[0] < 0) {
                // TODO: FIXME:
                int iBval;
                this.sign = -1;
                // strip leading sign bytes
                for (iBval = 0; iBval < bytes.Length && ((sbyte)bytes[iBval] == -1); iBval++) {
                    ;
                }
                // TODO Should this be [((bytes.Length - iBval) + 3) / 4]?
                magnitude = new int[(bytes.Length - iBval) / 2 + 1];
                // TODO copy bytes to magnitude
                // TODO invert bytes then add one to find magnitude of value
            } else {
                // strip leading zero bytes and return magnitude bytes
                magnitude = MakeMagnitude(bytes);
            }
        }

        private static int[] MakeMagnitude(byte[] bytes) {
            int firstSignificant;
            // strip leading zeros
            for (firstSignificant = 0; firstSignificant < bytes.Length
                                       && bytes[firstSignificant] == 0; firstSignificant++) {
                                           ;
                                       }
            if (firstSignificant >= bytes.Length) {
                return ZeroMagnitude;
            }
            int nInts = (bytes.Length - firstSignificant + 3) / 4;
            int bCount = (bytes.Length - firstSignificant) % 4;
            if (bCount == 0) {
                bCount = 4;
            }
            int[] mag = new int[nInts];
            int v = 0;
            int magnitudeIndex = 0;
            for (int i = firstSignificant; i < bytes.Length; ++i) {
                v <<= 8;
                v |= bytes[i] & 0xff;
                bCount--;
                if (bCount <= 0) {
                    mag[magnitudeIndex] = v;
                    magnitudeIndex++;
                    bCount = 4;
                    v = 0;
                }
            }
            if (magnitudeIndex < mag.Length) {
                mag[magnitudeIndex] = v;
            }
            return mag;
        }

        public BigInteger(int sign, byte[] value) {
            if (sign < -1 || sign > 1) {
                throw new FormatException("Invalid sign value");
            }
            if (sign == 0) {
                this.sign = 0;
                this.magnitude = ZeroMagnitude;
                return;
            }
            // copy bytes
            this.magnitude = MakeMagnitude(value);
            this.sign = this.magnitude.Length < 1 ? 0 : sign;
        }

        public BigInteger(int sizeInBits, Random random) {
            if (sizeInBits < 0) {
                throw new ArgumentException("sizeInBits must be non-negative");
            }
            this.nBits = -1;
            this.nBitLength = -1;
            if (sizeInBits == 0) {
                this.sign = 0;
                this.magnitude = ZeroMagnitude;
                return;
            }
            int nBytes = (sizeInBits + BITS_PER_BYTE - 1) / BITS_PER_BYTE;
            byte[] b = new byte[nBytes];
            NextRndBytes(random, b);
            // strip off any excess bits in the MSB
            b[0] &= rndMask[BITS_PER_BYTE * nBytes - sizeInBits];
            this.magnitude = MakeMagnitude(b);
            this.sign = this.magnitude.Length < 1 ? 0 : 1;
        }

        private static readonly int BITS_PER_BYTE = 8;

        private static readonly int BYTES_PER_INT = 4;

        /**
         * strictly speaking this is a little dodgey from a compliance
         * point of view as it forces people to be using SecureRandom as
         * well, that being said - this implementation is for a crypto
         * library and you do have the source!
         */

        private static void NextRndBytes(Random random, byte[] bytes) {
            int numRequested = bytes.Length;
            int numGot = 0,
                r = 0;
            /* We'll not move SecureRandom over*
            if (typeof(SecureRandom).IsInstanceOfType(random))
            {
                ((SecureRandom)random).NextBytes(bytes);
            }
            */
            if (false) { } else {
                for (; ; ) {
                    for (int i = 0; i < BYTES_PER_INT; i++) {
                        if (numGot == numRequested) {
                            return;
                        }
                        r = (i == 0 ? random.Next() : r >> BITS_PER_BYTE);
                        bytes[numGot++] = (byte)r;
                    }
                }
            }
        }

        private static readonly byte[] rndMask = { (byte)255, 127, 63, 31, 15, 7, 3, 1 };

        public BigInteger(int bitLength, int certainty, Random random) {
            if (bitLength < 2) {
                throw new ArithmeticException("bitLength < 2");
            }
            if ((certainty & 0x1) == 1) {
                certainty = certainty / 2 + 1;
            } else {
                certainty /= 2;
            }
            this.sign = 1;
            this.nBitLength = bitLength;
            int nBytes = (bitLength + 7) / BITS_PER_BYTE;
            int xBits = BITS_PER_BYTE * nBytes - bitLength;
            byte mask = rndMask[xBits];
            byte[] b = new byte[nBytes];
            do {
                NextRndBytes(random, b);
                // strip off any excess bits in the MSB
                b[0] &= mask;
                // ensure the leading bit is 1 (to meet the strength requirement)
                b[0] |= (byte)(1 << (7 - xBits));
                // ensure the trailing bit is 1 (i.e. must be odd)
                b[nBytes - 1] |= (byte)1;
                this.magnitude = MakeMagnitude(b);
                this.nBits = -1;
                this.mQuote = -1L;
            } while (!this.CheckProbablePrime(certainty, random));
        }

        public BigInteger Abs() {
            return (sign >= 0) ? this : this.Negate();
        }

        /**
         * return a = a + b - b preserved.
         */

        private static int[] Add(int[] a, int[] b) {
            int tI = a.Length - 1;
            int vI = b.Length - 1;
            long m = 0;
            while (vI >= 0) {
                m += (((long)a[tI]) & IMASK) + (((long)b[vI--]) & IMASK);
                a[tI--] = (int)m;
                m = (long)((ulong)m >> 32);
            }
            while (tI >= 0 && m != 0) {
                m += (((long)a[tI]) & IMASK);
                a[tI--] = (int)m;
                m = (long)((ulong)m >> 32);
            }
            return a;
        }

        public BigInteger Add(BigInteger value) {
            if (value.sign == 0) {
                return this;
            }
            if (this.sign == 0) {
                return value;
            }
            if (value.sign < 0) {
                if (this.sign > 0) {
                    return this.Subtract(value.Negate());
                }
            } else {
                if (this.sign < 0) {
                    return value.Subtract(this.Negate());
                }
            }
            // both BigIntegers are either +ve or -ve; set the sign later
            int[] mag, op;
            if (this.magnitude.Length < value.magnitude.Length) {
                mag = new int[value.magnitude.Length + 1];
                Array.Copy(value.magnitude, 0, mag, 1, value.magnitude.Length);
                op = this.magnitude;
            } else {
                mag = new int[this.magnitude.Length + 1];
                Array.Copy(this.magnitude, 0, mag, 1, this.magnitude.Length);
                op = value.magnitude;
            }
            return new BigInteger(this.sign, Add(mag, op));
        }

        public int BitCount() {
            if (nBits == -1) {
                nBits = 0;
                for (int i = 0; i < magnitude.Length; i++) {
                    nBits += bitCounts[magnitude[i] & 0xff];
                    nBits += bitCounts[(magnitude[i] >> 8) & 0xff];
                    nBits += bitCounts[(magnitude[i] >> 16) & 0xff];
                    nBits += bitCounts[(magnitude[i] >> 24) & 0xff];
                }
            }
            return nBits;
        }

        private static readonly byte[] bitCounts = {
            0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1,
            2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4,
            4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3,
            4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5,
            3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2,
            3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3,
            3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6,
            7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6,
            5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5,
            6, 6, 7, 6, 7, 7, 8
        };

        private int BitLength(int indx, int[] mag) {
            int bitLength;
            if (mag.Length == 0) {
                return 0;
            } else {
                while (indx != mag.Length && mag[indx] == 0) {
                    indx++;
                }
                if (indx == mag.Length) {
                    return 0;
                }
                // bit length for everything after the first int
                bitLength = 32 * ((mag.Length - indx) - 1);
                // and determine bitlength of first int
                bitLength += BitLen(mag[indx]);
                if (sign < 0) {
                    // Check if magnitude is a power of two
                    bool pow2 = ((bitCounts[mag[indx] & 0xff])
                                 + (bitCounts[(mag[indx] >> 8) & 0xff])
                                 + (bitCounts[(mag[indx] >> 16) & 0xff]) + (bitCounts[(mag[indx] >> 24) & 0xff])) == 1;
                    for (int i = indx + 1; i < mag.Length && pow2; i++) {
                        pow2 = (mag[i] == 0);
                    }
                    bitLength -= (pow2 ? 1 : 0);
                }
            }
            return bitLength;
        }

        public int BitLength() {
            if (nBitLength == -1) {
                if (sign == 0) {
                    nBitLength = 0;
                } else {
                    nBitLength = BitLength(0, magnitude);
                }
            }
            return nBitLength;
        }

        //
        // BitLen(value) is the number of bits in value.
        //
        private static int BitLen(int w) {
            // Binary search - decision tree (5 tests, rarely 6)
            return (w < 1 << 15 ? (w < 1 << 7
                                       ? (w < 1 << 3 ? (w < 1 << 1
                                                            ? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)
                                                            : (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5
                                                                                           ? (w < 1 << 4 ? 4 : 5)
                                                                                           : (w < 1 << 6 ? 6 : 7)))
                                       : (w < 1 << 11
                                              ? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))
                                              : (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19
                                                                                                                                          ? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))
                                                                                                                                          : (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27
                                                                                                                                                                                                                      ? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))
                                                                                                                                                                                                                      : (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
        }

        private static readonly byte[] bitLengths = {
            0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,
            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
            6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
            7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
            7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8,
            8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
            8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
            8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
            8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
            8, 8, 8, 8, 8, 8, 8, 8
        };

        public int CompareTo(Object obj) {
            return CompareTo((BigInteger)obj);
        }

        /**
         * unsigned comparison on two arrays - note the arrays may
         * start with leading zeros.
         */

        private static int CompareTo(int xIndx, int[] x, int yIndx, int[] y) {
            while (xIndx != x.Length && x[xIndx] == 0) {
                xIndx++;
            }
            while (yIndx != y.Length && y[yIndx] == 0) {
                yIndx++;
            }
            if ((x.Length - xIndx) < (y.Length - yIndx)) {
                return -1;
            }
            if ((x.Length - xIndx) > (y.Length - yIndx)) {
                return 1;
            }
            // lengths of magnitudes the same, test the magnitude values
            while (xIndx < x.Length) {
                long v1 = (long)(x[xIndx++]) & IMASK;
                long v2 = (long)(y[yIndx++]) & IMASK;
                if (v1 < v2) {
                    return -1;
                }
                if (v1 > v2) {
                    return 1;
                }
            }
            return 0;
        }

        public int CompareTo(BigInteger value) {
            if (sign < value.sign) {
                return -1;
            }
            if (sign > value.sign) {
                return 1;
            }
            if (sign == 0) {
                return 0;
            }
            return this.sign * CompareTo(0, magnitude, 0, value.magnitude);
        }

        /**
         * return z = x / y - done in place (z value preserved, x contains the
         * remainder)
         */

        private int[] Divide(int[] x, int[] y) {
            int xyCmp = CompareTo(0, x, 0, y);
            int[] count;
            if (xyCmp > 0) {
                int[] c;
                int shift = BitLength(0, x) - BitLength(0, y);
                if (shift > 1) {
                    c = ShiftLeft(y, shift - 1);
                    count = ShiftLeft(One.magnitude, shift - 1);
                    if (shift % 32 == 0) {
                        // Special case where the shift is the size of an int.
                        int[] countSpecial = new int[shift / 32 + 1];
                        Array.Copy(count, 0, countSpecial, 1, countSpecial.Length - 1);
                        countSpecial[0] = 0;
                        count = countSpecial;
                    }
                } else {
                    c = new int[x.Length];
                    count = new int[1];
                    Array.Copy(y, 0, c, c.Length - y.Length, y.Length);
                    count[0] = 1;
                }
                int[] iCount = new int[count.Length];
                Subtract(0, x, 0, c);
                Array.Copy(count, 0, iCount, 0, count.Length);
                int xStart = 0;
                int cStart = 0;
                int iCountStart = 0;
                for (; ; ) {
                    int cmp = CompareTo(xStart, x, cStart, c);
                    while (cmp >= 0) {
                        Subtract(xStart, x, cStart, c);
                        Add(count, iCount);
                        cmp = CompareTo(xStart, x, cStart, c);
                    }
                    xyCmp = CompareTo(xStart, x, 0, y);
                    if (xyCmp > 0) {
                        if (x[xStart] == 0) {
                            xStart++;
                        }
                        shift = BitLength(cStart, c) - BitLength(xStart, x);
                        if (shift == 0) {
                            c = ShiftRightOne(cStart, c);
                            iCount = ShiftRightOne(iCountStart, iCount);
                        } else {
                            c = ShiftRight(cStart, c, shift);
                            iCount = ShiftRight(iCountStart, iCount, shift);
                        }
                        if (c[cStart] == 0) {
                            cStart++;
                        }
                        if (iCount[iCountStart] == 0) {
                            iCountStart++;
                        }
                    } else if (xyCmp == 0) {
                        Add(count, One.magnitude);
                        for (int i = xStart; i != x.Length; i++) {
                            x[i] = 0;
                        }
                        break;
                    } else {
                        break;
                    }
                }
            } else if (xyCmp == 0) {
                count = new int[1];
                count[0] = 1;
            } else {
                count = new int[1];
                count[0] = 0;
            }
            return count;
        }

        public BigInteger Divide(BigInteger value) {
            if (value.sign == 0) {
                throw new ArithmeticException("Divide by zero");
            }
            if (sign == 0) {
                return Zero;
            }
            if (value.CompareTo(One) == 0) {
                return this;
            }
            int[] mag = new int[this.magnitude.Length];
            Array.Copy(this.magnitude, 0, mag, 0, mag.Length);
            return new BigInteger(this.sign * value.sign, Divide(mag, value.magnitude));
        }

        public BigInteger[] DivideAndRemainder(BigInteger value) {
            if (value.sign == 0) {
                throw new ArithmeticException("Divide by zero");
            }
            BigInteger[] biggies = new BigInteger[2];
            if (sign == 0) {
                biggies[0] = biggies[1] = Zero;
                return biggies;
            }
            if (value.CompareTo(One) == 0) {
                biggies[0] = this;
                biggies[1] = Zero;
                return biggies;
            }
            int[] remainder = new int[this.magnitude.Length];
            Array.Copy(this.magnitude, 0, remainder, 0, remainder.Length);
            int[] quotient = Divide(remainder, value.magnitude);
            biggies[0] = new BigInteger(this.sign * value.sign, quotient);
            biggies[1] = new BigInteger(this.sign, remainder);
            return biggies;
        }

        public override bool Equals(Object obj) {
            if (obj == this) {
                return true;
            }
            BigInteger biggie = obj as BigInteger;
            if (biggie == null) {
                return false;
            }
            if (biggie.sign != sign || biggie.magnitude.Length != magnitude.Length) {
                return false;
            }
            for (int i = 0; i < magnitude.Length; i++) {
                if (biggie.magnitude[i] != magnitude[i]) {
                    return false;
                }
            }
            return true;
        }

        public BigInteger Gcd(BigInteger value) {
            if (value.sign == 0) {
                return this.Abs();
            } else if (sign == 0) {
                return value.Abs();
            }
            BigInteger r;
            BigInteger u = this;
            BigInteger v = value;
            while (v.sign != 0) {
                r = u.Mod(v);
                u = v;
                v = r;
            }
            return u;
        }

        public override int GetHashCode() {
            return 0;
        }

        public int IntValue() {
            if (magnitude.Length == 0) {
                return 0;
            }
            if (sign < 0) {
                return -magnitude[magnitude.Length - 1];
            } else {
                return magnitude[magnitude.Length - 1];
            }
        }

        /**
         * return whether or not a BigInteger is probably prime with a
         * probability of 1 - (1/2)**certainty.
         * <p>
         * From Knuth Vol 2, pg 395.
         */

        public bool IsProbablePrime(int certainty) {
            if (certainty == 0) {
                return true;
            }
            BigInteger n = this.Abs();
            if (n.Equals(Two)) {
                return true;
            }
            if (n.Equals(One) || !n.TestBit(0)) {
                return false;
            }
            if ((certainty & 0x1) == 1) {
                certainty = certainty / 2 + 1;
            } else {
                certainty /= 2;
            }
            // We are dealing with primes here, and this package is all about cryptography, so we want to use the secure random provider...
            return CheckProbablePrime(certainty, RandomGenerator.GetSecureRandomGenerator());
        }

        private bool CheckProbablePrime(int certainty, Random random) {
            /* To take out the namespace System.Diagnostics
            Debug.Assert(certainty >= 0);
            Debug.Assert(random != null);

            Debug.Assert(this.CompareTo(Two) > 0);
            Debug.Assert(this.TestBit(0));
            */
            BigInteger n = this;
            int nBitLength = n.BitLength();
            BigInteger nMinusOne = n.Subtract(One);
            //
            // let n = 1 + 2^kq
            //
            BigInteger q = nMinusOne;
            int k = q.GetLowestSetBit();
            q = q.ShiftRight(k);
            // TODO Should this really be <= ?
            for (int i = 0; i <= certainty; i++) {
                BigInteger x;
                do {
                    x = new BigInteger(nBitLength, random);
                } while (x.CompareTo(One) <= 0 || x.CompareTo(n) >= 0);
                BigInteger y = x.ModPow(q, n);
                if (!(y.Equals(One) || y.Equals(nMinusOne))) {
                    int j = 0;
                    do {
                        if (++j == k) {
                            return false;
                        }
                        y = y.ModPow(Two, n);
                    } while (!(y.Equals(One) || y.Equals(nMinusOne)));
                }
            }
            return true;
        }

        public long LongValue() {
            long value = 0;
            if (magnitude.Length == 0) {
                return 0;
            }
            if (magnitude.Length > 1) {
                value = ((long)magnitude[magnitude.Length - 2] << 32)
                        | (magnitude[magnitude.Length - 1] & IMASK);
            } else {
                value = (magnitude[magnitude.Length - 1] & IMASK);
            }
            if (sign < 0) {
                return -value;
            } else {
                return value;
            }
        }

        public BigInteger Max(BigInteger value) {
            return (CompareTo(value) > 0) ? this : value;
        }

        public BigInteger Min(BigInteger value) {
            return (CompareTo(value) < 0) ? this : value;
        }

        public BigInteger Mod(BigInteger m) {
            if (m.sign <= 0) {
                throw new ArithmeticException("BigInteger: modulus is not positive");
            }
            BigInteger biggie = this.Remainder(m);
            return (biggie.sign >= 0 ? biggie : biggie.Add(m));
        }

        public BigInteger ModInverse(BigInteger m) {
            if (m.sign != 1) {
                throw new ArithmeticException("Modulus must be positive");
            }
            BigInteger x = new BigInteger();
            BigInteger y = new BigInteger();
            BigInteger gcd = ExtEuclid(this, m, x, y);
            if (!gcd.Equals(One)) {
                throw new ArithmeticException("Numbers not relatively prime.");
            }
            if (x.CompareTo(Zero) < 0) {
                x = x.Add(m);
            }
            return x;
        }

        /**
         * Calculate the numbers u1, u2, and u3 such that:
         *
         * u1 * a + u2 * b = u3
         *
         * where u3 is the greatest common divider of a and b.
         * a and b using the extended Euclid algorithm (refer p. 323
         * of The Art of Computer Programming vol 2, 2nd ed).
         * This also seems to have the side effect of calculating
         * some form of multiplicative inverse.
         *
         * @param a    First number to calculate gcd for
         * @param b    Second number to calculate gcd for
         * @param u1Out      the return object for the u1 value
         * @param u2Out      the return object for the u2 value
         * @return     The greatest common divisor of a and b
         */

        private static BigInteger ExtEuclid(BigInteger a, BigInteger b, BigInteger u1Out,
                                            BigInteger u2Out) {
            BigInteger res;
            BigInteger u1 = One;
            BigInteger u3 = a;
            BigInteger v1 = Zero;
            BigInteger v3 = b;
            while (v3.CompareTo(Zero) > 0) {
                BigInteger q,
                           tn;
                //tv;
                q = u3.Divide(v3);
                tn = u1.Subtract(v1.Multiply(q));
                u1 = v1;
                v1 = tn;
                tn = u3.Subtract(v3.Multiply(q));
                u3 = v3;
                v3 = tn;
            }
            u1Out.sign = u1.sign;
            u1Out.magnitude = u1.magnitude;
            res = u3.Subtract(u1.Multiply(a)).Divide(b);
            u2Out.sign = res.sign;
            u2Out.magnitude = res.magnitude;
            return u3;
                                            }

        /**
         * zero out the array x
         */

        private static void ZeroOut(int[] x) {
            for (int i = 0; i != x.Length; i++) {
                x[i] = 0;
            }
        }

        public BigInteger ModPow(
            BigInteger exponent,
            BigInteger m) {
            if (m.CompareTo(Zero) != 1) {
                throw new ArithmeticException("m <= 0");
            }
            if (m.Equals(One)) {
                return Zero;
            }
            // Zero exponent check
            if (exponent.sign == 0) {
                return One;
            }
            int[] zVal = null;
            int[] yAccum = null;
            int[] yVal;
            // Montgomery exponentiation is only possible if the modulus is odd,
            // but AFAIK, this is always the case for crypto algo's
            bool useMonty = ((m.magnitude[m.magnitude.Length - 1] & 1) == 1);
            long mQ = 0;
            if (useMonty) {
                mQ = m.GetMQuote();
                // tmp = this * R mod m
                BigInteger tmp = this.ShiftLeft(32 * m.magnitude.Length).Mod(m);
                zVal = tmp.magnitude;
                useMonty = (zVal.Length <= m.magnitude.Length);
                if (useMonty) {
                    yAccum = new int[m.magnitude.Length + 1];
                    if (zVal.Length < m.magnitude.Length) {
                        int[] longZ = new int[m.magnitude.Length];
                        Array.Copy(zVal, 0, longZ, longZ.Length - zVal.Length, zVal.Length);
                        zVal = longZ;
                    }
                }
            }
            if (!useMonty) {
                if (magnitude.Length <= m.magnitude.Length) {
                    //zAccum = new int[m.magnitude.Length * 2];
                    zVal = new int[m.magnitude.Length];
                    Array.Copy(magnitude, 0, zVal, zVal.Length - magnitude.Length,
                               magnitude.Length);
                } else {
                    //
                    // in normal practice we'll never see this...
                    //
                    BigInteger tmp = this.Remainder(m);
                    //zAccum = new int[m.magnitude.Length * 2];
                    zVal = new int[m.magnitude.Length];
                    Array.Copy(tmp.magnitude, 0, zVal, zVal.Length - tmp.magnitude.Length,
                               tmp.magnitude.Length);
                }
                yAccum = new int[m.magnitude.Length * 2];
            }
            yVal = new int[m.magnitude.Length];
            //
            // from LSW to MSW
            //
            for (int i = 0; i < exponent.magnitude.Length; i++) {
                int v = exponent.magnitude[i];
                int bits = 0;
                if (i == 0) {
                    while (v > 0) {
                        v <<= 1;
                        bits++;
                    }
                    //
                    // first time in initialise y
                    //
                    Array.Copy(zVal, 0, yVal, 0, zVal.Length);
                    v <<= 1;
                    bits++;
                }
                while (v != 0) {
                    if (useMonty) {
                        // Montgomery square algo doesn't exist, and a normal
                        // square followed by a Montgomery reduction proved to
                        // be almost as heavy as a Montgomery mulitply.
                        MultiplyMonty(yAccum, yVal, yVal, m.magnitude, mQ);
                    } else {
                        Square(yAccum, yVal);
                        Remainder(yAccum, m.magnitude);
                        Array.Copy(yAccum, yAccum.Length - yVal.Length, yVal, 0, yVal.Length);
                        ZeroOut(yAccum);
                    }
                    bits++;
                    if (v < 0) {
                        if (useMonty) {
                            MultiplyMonty(yAccum, yVal, zVal, m.magnitude, mQ);
                        } else {
                            Multiply(yAccum, yVal, zVal);
                            Remainder(yAccum, m.magnitude);
                            Array.Copy(yAccum, yAccum.Length - yVal.Length, yVal, 0,
                                       yVal.Length);
                            ZeroOut(yAccum);
                        }
                    }
                    v <<= 1;
                }
                while (bits < 32) {
                    if (useMonty) {
                        MultiplyMonty(yAccum, yVal, yVal, m.magnitude, mQ);
                    } else {
                        Square(yAccum, yVal);
                        Remainder(yAccum, m.magnitude);
                        Array.Copy(yAccum, yAccum.Length - yVal.Length, yVal, 0, yVal.Length);
                        ZeroOut(yAccum);
                    }
                    bits++;
                }
            }
            if (useMonty) {
                // Return y * R^(-1) mod m by doing y * 1 * R^(-1) mod m
                ZeroOut(zVal);
                zVal[zVal.Length - 1] = 1;
                MultiplyMonty(yAccum, yVal, zVal, m.magnitude, mQ);
            }
            return new BigInteger(1, yVal);
            }

        /**
         * return w with w = x * x - w is assumed to have enough space.
         */

        private static int[] Square(int[] w, int[] x) {
            long u1,
                 u2,
                 c;
            if (w.Length != 2 * x.Length) {
                throw new ArgumentException("no I don't think so...");
            }
            for (int i = x.Length - 1; i != 0; i--) {
                long v = (x[i] & IMASK);
                u1 = v * v;
                u2 = (long)((ulong)u1 >> 32);
                u1 = u1 & IMASK;
                u1 += (w[2 * i + 1] & IMASK);
                w[2 * i + 1] = (int)u1;
                c = u2 + (u1 >> 32);
                for (int j = i - 1; j >= 0; j--) {
                    u1 = (x[j] & IMASK) * v;
                    u2 = (long)((ulong)u1 >> 31); // multiply by 2!
                    u1 = (u1 & 0x7fffffff) << 1; // multiply by 2!
                    u1 += (w[i + j + 1] & IMASK) + c;
                    w[i + j + 1] = (int)u1;
                    c = u2 + (long)((ulong)u1 >> 32);
                }
                c += w[i] & IMASK;
                w[i] = (int)c;
                w[i - 1] = (int)(c >> 32);
            }
            u1 = (x[0] & IMASK);
            u1 = u1 * u1;
            u2 = (long)((ulong)u1 >> 32);
            u1 = u1 & IMASK;
            u1 += (w[1] & IMASK);
            w[1] = (int)u1;
            w[0] = (int)(u2 + (u1 >> 32) + w[0]);
            return w;
        }

        /**
         * return x with x = y * z - x is assumed to have enough space.
         */

        private static int[] Multiply(int[] x, int[] y, int[] z) {
            for (int i = z.Length - 1; i >= 0; i--) {
                long a = z[i] & IMASK;
                long value = 0;
                for (int j = y.Length - 1; j >= 0; j--) {
                    value += a * (y[j] & IMASK) + (x[i + j + 1] & IMASK);
                    x[i + j + 1] = (int)value;
                    value = (long)((ulong)value >> 32);
                }
                x[i] = (int)value;
            }
            return x;
        }

        /**
         * Calculate mQuote = -m^(-1) mod b with b = 2^32 (32 = word size)
         */

        private long GetMQuote() {
            if (mQuote != -1L) {
                // allready calculated
                return mQuote;
            }
            if ((magnitude[magnitude.Length - 1] & 1) == 0) {
                return -1L; // not for even numbers
            }
            byte[] bytes = { 1, 0, 0, 0, 0 };
            BigInteger b = new BigInteger(1, bytes); // 2^32
            mQuote = this.Negate().Mod(b).ModInverse(b).LongValue();
            return mQuote;
        }

        /**
         * Montgomery multiplication: a = x * y * R^(-1) mod m
         * <br>
         * Based algorithm 14.36 of Handbook of Applied Cryptography.
         * <br>
         * <li> m, x, y should have length n </li>
         * <li> a should have length (n + 1) </li>
         * <li> b = 2^32, R = b^n </li>
         * <br>
         * The result is put in x
         * <br>
         * NOTE: the indices of x, y, m, a different in HAC and in Java
         */

        private static void MultiplyMonty(int[] a, int[] x, int[] y, int[] m, long mQuote)
            // mQuote = -m^(-1) mod b
        {
            int n = m.Length;
            int nMinus1 = n - 1;
            long y_0 = y[n - 1] & IMASK;
            // 1. a = 0 (Notation: a = (a_{n} a_{n-1} ... a_{0})_{b} )
            for (int i = 0; i <= n; i++) {
                a[i] = 0;
            }
            // 2. for i from 0 to (n - 1) do the following:
            for (int i = n; i > 0; i--) {
                long x_i = x[i - 1] & IMASK;
                // 2.1 u = ((a[0] + (x[i] * y[0]) * mQuote) mod b
                long u = ((((a[n] & IMASK) + ((x_i * y_0) & IMASK)) & IMASK) * mQuote) & IMASK;
                // 2.2 a = (a + x_i * y + u * m) / b
                long prod1 = x_i * y_0;
                long prod2 = u * (m[n - 1] & IMASK);
                long tmp = (a[n] & IMASK) + (prod1 & IMASK) + (prod2 & IMASK);
                long carry = (long)((ulong)prod1 >> 32) + (long)((ulong)prod2 >> 32) + (long)((ulong)tmp >> 32);
                for (int j = nMinus1; j > 0; j--) {
                    prod1 = x_i * (y[j - 1] & IMASK);
                    prod2 = u * (m[j - 1] & IMASK);
                    tmp = (a[j] & IMASK) + (prod1 & IMASK) + (prod2 & IMASK) + (carry & IMASK);
                    carry = (long)((ulong)carry >> 32) + (long)((ulong)prod1 >> 32) +
                            (long)((ulong)prod2 >> 32) + (long)((ulong)tmp >> 32);
                    a[j + 1] = (int)tmp; // division by b
                }
                carry += (a[0] & IMASK);
                a[1] = (int)carry;
                a[0] = (int)((ulong)carry >> 32); // OJO!!!!!
            }
            // 3. if x >= m the x = x - m
            if (CompareTo(0, a, 0, m) >= 0) {
                Subtract(0, a, 0, m);
            }
            // put the result in x
            for (int i = 0; i < n; i++) {
                x[i] = a[i + 1];
            }
        }

        public BigInteger Multiply(BigInteger value) {
            if (sign == 0 || value.sign == 0) {
                return Zero;
            }
            int[] res = new int[magnitude.Length + value.magnitude.Length];
            return new BigInteger(sign * value.sign, Multiply(res, magnitude, value.magnitude));
        }

        public BigInteger Negate() {
            return sign == 0 ? this : new BigInteger(-sign, magnitude);
        }

        public BigInteger Pow(int exp) {
            if (exp < 0) {
                throw new ArithmeticException("Negative exponent");
            }
            if (sign == 0) {
                return (exp == 0 ? One : this);
            }
            BigInteger y,
                       z;
            y = One;
            z = this;
            while (exp != 0) {
                if ((exp & 0x1) == 1) {
                    y = y.Multiply(z);
                }
                exp >>= 1;
                if (exp != 0) {
                    z = z.Multiply(z);
                }
            }
            return y;
        }

        /**
         * return x = x % y - done in place (y value preserved)
         */

        private int[] Remainder(int[] x, int[] y) {
            int xyCmp = CompareTo(0, x, 0, y);
            if (xyCmp > 0) {
                int[] c;
                int shift = BitLength(0, x) - BitLength(0, y);
                if (shift > 1) {
                    c = ShiftLeft(y, shift - 1);
                } else {
                    c = new int[x.Length];
                    Array.Copy(y, 0, c, c.Length - y.Length, y.Length);
                }
                Subtract(0, x, 0, c);
                int xStart = 0;
                int cStart = 0;
                for (; ; ) {
                    int cmp = CompareTo(xStart, x, cStart, c);
                    while (cmp >= 0) {
                        Subtract(xStart, x, cStart, c);
                        cmp = CompareTo(xStart, x, cStart, c);
                    }
                    xyCmp = CompareTo(xStart, x, 0, y);
                    if (xyCmp > 0) {
                        if (x[xStart] == 0) {
                            xStart++;
                        }
                        shift = BitLength(cStart, c) - BitLength(xStart, x);
                        if (shift == 0) {
                            c = ShiftRightOne(cStart, c);
                        } else {
                            c = ShiftRight(cStart, c, shift);
                        }
                        if (c[cStart] == 0) {
                            cStart++;
                        }
                    } else if (xyCmp == 0) {
                        for (int i = xStart; i != x.Length; i++) {
                            x[i] = 0;
                        }
                        break;
                    } else {
                        break;
                    }
                }
            } else if (xyCmp == 0) {
                for (int i = 0; i != x.Length; i++) {
                    x[i] = 0;
                }
            }
            return x;
        }

        public BigInteger Remainder(BigInteger value) {
            if (value.sign == 0) {
                throw new ArithmeticException("BigInteger: Divide by zero");
            }
            if (sign == 0) {
                return Zero;
            }
            int[] res = new int[this.magnitude.Length];
            Array.Copy(this.magnitude, 0, res, 0, res.Length);
            return new BigInteger(sign, Remainder(res, value.magnitude));
        }

        /**
         * do a left shift - this returns a new array.
         */

        private static int[] ShiftLeft(int[] mag, int n) {
            int nInts = (int)((uint)n >> 5);
            int nBits = n & 0x1f;
            int magLen = mag.Length;
            int[] newMag = null;
            if (nBits == 0) {
                newMag = new int[magLen + nInts];
                for (int i = 0; i < magLen; i++) {
                    newMag[i] = mag[i];
                }
            } else {
                int i = 0;
                int nBits2 = 32 - nBits;
                int highBits = (int)((uint)mag[0] >> nBits2);
                if (highBits != 0) {
                    newMag = new int[magLen + nInts + 1];
                    newMag[i++] = highBits;
                } else {
                    newMag = new int[magLen + nInts];
                }
                int m = mag[0];
                for (int j = 0; j < magLen - 1; j++) {
                    int next = mag[j + 1];
                    newMag[i++] = (m << nBits) | (int)((uint)next >> nBits2);
                    m = next;
                }
                newMag[i] = mag[magLen - 1] << nBits;
            }
            return newMag;
        }

        public BigInteger ShiftLeft(int n) {
            if (sign == 0 || magnitude.Length == 0) {
                return Zero;
            }
            if (n == 0) {
                return this;
            }
            if (n < 0) {
                return ShiftRight(-n);
            }
            return new BigInteger(sign, ShiftLeft(magnitude, n));
        }

        /**
         * do a right shift - this does it in place.
         */

        private static int[] ShiftRight(int start, int[] mag, int n) {
            int nInts = (int)((uint)n >> 5) + start;
            int nBits = n & 0x1f;
            int magLen = mag.Length;
            if (nInts != start) {
                int delta = (nInts - start);
                for (int i = magLen - 1; i >= nInts; i--) {
                    mag[i] = mag[i - delta];
                }
                for (int i = nInts - 1; i >= start; i--) {
                    mag[i] = 0;
                }
            }
            if (nBits != 0) {
                int nBits2 = 32 - nBits;
                int m = mag[magLen - 1];
                for (int i = magLen - 1; i >= nInts + 1; i--) {
                    int next = mag[i - 1];
                    mag[i] = (int)((uint)m >> nBits) | (next << nBits2);
                    m = next;
                }
                mag[nInts] = (int)((uint)mag[nInts] >> nBits);
            }
            return mag;
        }

        /**
         * do a right shift by one - this does it in place.
         */

        private static int[] ShiftRightOne(int start, int[] mag) {
            int magLen = mag.Length;
            int m = mag[magLen - 1];
            for (int i = magLen - 1; i >= start + 1; i--) {
                int next = mag[i - 1];
                mag[i] = ((int)((uint)m >> 1)) | (next << 31);
                m = next;
            }
            mag[start] = (int)((uint)mag[start] >> 1);
            return mag;
        }

        public BigInteger ShiftRight(int n) {
            if (n == 0) {
                return this;
            }
            if (n < 0) {
                return ShiftLeft(-n);
            }
            if (n >= BitLength()) {
                return (this.sign < 0 ? ValueOf(-1) : Zero);
            }
            int[] res = new int[this.magnitude.Length];
            Array.Copy(this.magnitude, 0, res, 0, res.Length);
            return new BigInteger(this.sign, ShiftRight(0, res, n));
        }

        public int SignValue {
            get {
                return sign;
            }
        }

        /**
         * returns x = x - y - we assume x is >= y
         */

        private static int[] Subtract(int xStart, int[] x, int yStart, int[] y) {
            int iT = x.Length - 1;
            int iV = y.Length - 1;
            long m;
            int borrow = 0;
            do {
                m = (((long)x[iT]) & IMASK) - (((long)y[iV--]) & IMASK) + borrow;
                x[iT--] = (int)m;
                if (m < 0) {
                    borrow = -1;
                } else {
                    borrow = 0;
                }
            } while (iV >= yStart);
            while (iT >= xStart) {
                m = (((long)x[iT]) & IMASK) + borrow;
                x[iT--] = (int)m;
                if (m < 0) {
                    borrow = -1;
                } else {
                    break;
                }
            }
            return x;
        }

        public BigInteger Subtract(BigInteger value) {
            if (value.sign == 0) {
                return this;
            }
            if (this.sign == 0) {
                return value.Negate();
            }
            if (this.sign != value.sign) {
                return this.Add(value.Negate());
            }
            int compare = CompareTo(0, magnitude, 0, value.magnitude);
            if (compare == 0) {
                return Zero;
            }
            BigInteger bigun, littlun;
            if (compare < 0) {
                bigun = value;
                littlun = this;
            } else {
                bigun = this;
                littlun = value;
            }
            int[] res = new int[bigun.magnitude.Length];
            Array.Copy(bigun.magnitude, 0, res, 0, res.Length);
            return new BigInteger(this.sign * compare, Subtract(0, res, 0, littlun.magnitude));
        }

        public byte[] ToByteArray() {
            int bitLength = this.BitLength();
            byte[] bytes = new byte[bitLength / 8 + 1]; // TODO Is this right?
            int bytesCopied = 4;
            int mag = 0;
            int ofs = magnitude.Length - 1;
            int carry = 1;
            long lMag;
            for (int i = bytes.Length - 1; i >= 0; i--) {
                if (bytesCopied == 4 && ofs >= 0) {
                    if (sign < 0) {
                        // we are dealing with a +ve number and we want a -ve one, so
                        // invert the magnitude ints and add 1 (propagating the carry)
                        // to make a 2's complement -ve number
                        lMag = ~magnitude[ofs--] & IMASK;
                        lMag += carry;
                        if ((lMag & ~IMASK) != 0) {
                            carry = 1;
                        } else {
                            carry = 0;
                        }
                        mag = (int)(lMag & IMASK);
                    } else {
                        mag = magnitude[ofs--];
                    }
                    bytesCopied = 1;
                } else {
                    mag = (int)((uint)mag >> 8);
                    bytesCopied++;
                }
                bytes[i] = (byte)mag;
            }
            return bytes;
        }

        public override String ToString() {
            return ToString(10);
        }

        public String ToString(int radix) {
            String format;
            switch (radix) {
                case 10:
                    format = "d";
                    break;
                case 16:
                    format = "x";
                    break;
                default:
                    throw new FormatException("Only base 10 or 16 are allowed");
            }
            if (magnitude == null) {
                return "null";
            } else if (sign == 0) {
                return "0";
            }
            String s = "";
            String h;
            if (radix == 16) {
                for (int i = 0; i < magnitude.Length; i++) {
                    h = "0000000" + magnitude[i].ToString("x");
                    h = h.Substring(h.Length - 8);
                    s = s + h;
                }
            } else {
                // This is algorithm 1a from chapter 4.4 in Seminumerical Algorithms, slow but it works
                Stack S = new Stack();
                BigInteger bs = new BigInteger(radix.ToString());
                // The sign is handled separatly.
                // Notice however that for this to work, radix 16 _MUST_ be a special case,
                // unless we want to enter a recursion well. In their infinite wisdom, why did not 
                // the Sun engineers made a c'tor for BigIntegers taking a BigInteger as parameter?
                // (Answer: Becuase Sun's BigIntger is clonable, something bouncycastle's isn't.)
                BigInteger u = new BigInteger(this.Abs().ToString(16), 16);
                BigInteger b;
                // For speed, maye these test should look directly a u.magnitude.Length?
                while (!u.Equals(Zero)) {
                    b = u.Mod(bs);
                    if (b.Equals(Zero)) {
                        S.Push("0");
                    } else {
                        // see how to interact with different bases
                        S.Push(b.magnitude[0].ToString(format));
                    }
                    u = u.Divide(bs);
                }
                // Then pop the stack
                while (S.Count != 0) {
                    s = s + S.Pop();
                }
            }
            // Strip leading zeros.
            while (s.Length > 1 && s[0] == '0') {
                s = s.Substring(1);
            }
            if (s.Length == 0) {
                s = "0";
            } else if (sign == -1) {
                s = "-" + s;
            }
            return s;
        }

        public static readonly BigInteger Zero = new BigInteger(0, ZeroMagnitude);

        public static readonly BigInteger One = createValueOf(1);

        public static readonly BigInteger Two = createValueOf(2);

        private static BigInteger createValueOf(long value) {
            // The constructor used below doesn't work for negative values yet
            if (value < 0) {
                if (value == long.MinValue) {
                    return createValueOf(-(value + 1)).Add(One).Negate();
                }
                return createValueOf(-value).Negate();
            }
            // store value into a byte array
            byte[] b = new byte[8];
            for (int i = 0; i < 8; i++) {
                b[7 - i] = (byte)value;
                value >>= 8;
            }
            return new BigInteger(b);
        }

        public static BigInteger ValueOf(long value) {
            switch ((int)value) {
                case 0:
                    return Zero;
                case 1:
                    return One;
                case 2:
                    return Two;
            }
            return createValueOf(value);
        }

        public int GetLowestSetBit() {
            if (this.sign == 0) {
                return -1;
            }
            int w = magnitude.Length - 1;
            while (w >= 0) {
                if (magnitude[w] != 0) {
                    break;
                }
                w--;
            }
            int b = 31;
            while (b > 0) {
                if ((uint)(magnitude[w] << b) == 0x80000000) {
                    break;
                }
                b--;
            }
            return (((magnitude.Length - 1) - w) * 32 + (31 - b));
        }

        public bool TestBit(int n) {
            if (n < 0) {
                throw new ArithmeticException("Bit position must not be negative");
            }
            if ((n / 32) >= magnitude.Length) {
                return sign < 0;
            }
            return ((magnitude[(magnitude.Length - 1) - n / 32] >> (n % 32)) & 1) > 0;
        }

        public BigInteger Xor(BigInteger value) {
            int resultLength = Math.Max(magnitude.Length, value.magnitude.Length);
            int[] result = new int[resultLength];
            for (int i = 0; i < result.Length; i++) {
                int index = result.Length - i - 1;
                if (magnitude.Length > i) {
                    result[index] = magnitude[magnitude.Length - i - 1];
                }
                if (value.magnitude.Length > i) {
                    result[index] ^= value.magnitude[value.magnitude.Length - i - 1];
                } else {
                    // TODO Is this necessary?
                    result[index] ^= 0;
                }
            }
            // TODO This sign calculation is incorrect
            int resSign = 1;
            if (sign < 0 || value.sign < 0) {
                resSign = -1;
            }
            return new BigInteger(resSign, result);
        }

        public BigInteger SetBit(int n) {
            if (n < 0) {
                throw new ArithmeticException("Bit address less than zero");
            }
            int wordPos = n / 32 + 1;
            int[] result = CreateResult(wordPos);
            result[result.Length - wordPos] |= (1 << (n % 32));
            int newSign = sign < 0 ? -1 : 1;
            return new BigInteger(newSign, result);
        }

        public BigInteger ClearBit(int n) {
            if (n < 0) {
                throw new ArithmeticException("Bit address less than zero");
            }
            int wordPos = n / 32 + 1;
            int[] result = CreateResult(wordPos);
            result[result.Length - wordPos] &= ~(1 << (n % 32));
            // TODO Check that this handles the case of a zero result correctly
            return new BigInteger(sign, result);
        }

        public BigInteger FlipBit(int n) {
            if (n < 0) {
                throw new ArithmeticException("Bit address less than zero");
            }
            int wordPos = n / 32 + 1;
            int[] result = CreateResult(wordPos);
            result[result.Length - wordPos] ^= (1 << (n % 32));
            // TODO Check that this handles the case of a zero result correctly
            int newSign = sign < 0 ? -1 : 1;
            return new BigInteger(newSign, result);
        }

        private int[] CreateResult(int wordPos) {
            int resultLength = Math.Max(wordPos, magnitude.Length);
            int[] result = new int[resultLength];
            Array.Copy(magnitude, 0, result, result.Length - magnitude.Length, magnitude.Length);
            return result;
        }
    }
}