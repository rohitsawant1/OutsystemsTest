/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;

namespace OutSystems.RuntimeCommon.Cryptography.VersionedAlgorithms {
    public class VersionedCryptographyAlgorithms<TAlgorithm> where TAlgorithm: IVersionedCryptographyAlgorithm {
        public static readonly string DEFAULT_ALGORITHM_ID_SEPARATOR = "$";

        private readonly TAlgorithm[] algorithms;
        private readonly string separator;
        
        private int GetAlgorithmIndexForAlgorithmResult(string algorithmResult, out string algorithmResultToProcess) {
            int result = 0; // the first algorithm is the default...
            algorithmResultToProcess = algorithmResult;

            if (algorithmResult.StartsWith(separator)) {
                algorithmResult = algorithmResult.Substring(1);  // Remove the first separator
                int separatorIdx = algorithmResult.IndexOf(separator, StringComparison.Ordinal);
                
                if ((separatorIdx > 0) && (separatorIdx < algorithmResult.Length)) {
                    int algorithmIdx;
                    algorithmResultToProcess = algorithmResult.Substring(separatorIdx + 1);

                    if (Int32.TryParse(algorithmResult.Substring(0, separatorIdx), out algorithmIdx) && (algorithmIdx >= 0) 
                            && (algorithmIdx < algorithms.Length)) {

                        result = algorithmIdx;
                    }
                }
            }

            return result;
        } 
        
        /// <summary>
        /// Create a new VersionedAlgorithm class
        /// </summary>
        /// <param name="separator">The separator to use to separate the algorithm result from the algorithm id.</param>
        /// <param name="algorithms">
        /// List of algorithms by order of security. 
        /// A more secure algorithms should always be added to the end of this list.
        /// The first algorithm is the default to use when processing the result and the result isn't in the correct format.
        /// </param>
        public VersionedCryptographyAlgorithms(string separator, params TAlgorithm[] algorithms) {
            this.separator = separator;
            this.algorithms = algorithms;
        }

        /// <summary>
        /// Create a new VersionedAlgorithm class
        /// </summary>
        /// <param name="algorithms">
        /// List of algorithms by order of security. 
        /// A more secure algorithms should always be added to the end of this list.
        /// The first algorithm is the default to use when processing the result and the result isn't in the correct format.
        /// </param>
        public VersionedCryptographyAlgorithms(params TAlgorithm[] algorithms): this(DEFAULT_ALGORITHM_ID_SEPARATOR, algorithms) {}

        public int BestAlgorithmIndex { get { return algorithms.Length - 1; } }

        public int GetSpecificAlgorithmIndex(TAlgorithm algorithm) {
            int algorithmIdx = Array.IndexOf(algorithms, algorithm);

            if (algorithmIdx < 0) {
                throw new InvalidOperationException("Algorithm not valid in this VersionedCryptographyAlgorithms collection");
            }

            return algorithmIdx;
        }

        public string ApplyBestAlgorithm(string value) {
            return ApplySpecificAlgorithm(value, BestAlgorithmIndex);
        }

        public string ApplySpecificAlgorithm(string value, TAlgorithm algorithm) {
            return ApplySpecificAlgorithm(value, GetSpecificAlgorithmIndex(algorithm));
        }

        public string ApplySpecificAlgorithm(string value, int algorithmIdx) {
            TAlgorithm algorithm = GetSpecificAlgorithmFromIndex(algorithmIdx);
            if (!algorithm.IsSecure) {
                throw new InvalidOperationException("Insecure algorithms are not allowed. Try using a secure algorithm instead.");
            }
            //In compatibility mode "algorithmIdx == 0" we don't add any separators to keep the same behavior as before... So simply invoke its ApplyAlgorithm method...
            if (algorithmIdx == 0) {
                return algorithm.ApplyAlgorithm(value);
            } else {
                return String.Format("{0}{1}{0}{2}", separator, algorithmIdx, algorithm.ApplyAlgorithm(value));
            }
        }

        /// <summary>
        /// Process the result of the ProcessWithBestAlgorithm method.
        /// NOTE: The first algorithm is the default to use when processing the result and the result isn't in the correct format.
        /// </summary>
        public TResult ProcessAlgorithmResult<TResult>(string algorithmResult, Func<TAlgorithm, string, TResult> processAlgorithmResult) {
            return ProcessAlgorithmResult(algorithmResult, processAlgorithmResult, true);
        }

        protected TResult ProcessAlgorithmResult<TResult>(string algorithmResult, Func<TAlgorithm, string, TResult> processAlgorithmResult, 
                bool checkSecureAlgorithm) {

            string algorithmResultToProcess;
            int algorithmIndex = GetAlgorithmIndexForAlgorithmResult(algorithmResult, out algorithmResultToProcess);
            TAlgorithm algorithm = algorithms[algorithmIndex];
            if (checkSecureAlgorithm && !algorithm.IsSecure) {
                throw new InvalidOperationException("Insecure algorithms are not allowed. Try using a secure algorithm instead.");
            }
            return processAlgorithmResult(algorithm, algorithmResultToProcess);
        }

        public int GetAlgorithmIndexForAlgorithmResult(string algorithmResult) {
            string dummy;
            return GetAlgorithmIndexForAlgorithmResult(algorithmResult, out dummy);
        }

        public TAlgorithm GetSpecificAlgorithmFromIndex(int algorithmIdx) {
            if ((algorithmIdx < 0) || (algorithmIdx > algorithms.Length - 1)) {
                throw new InvalidOperationException("Algorithm index not valid in this VersionedCryptographyAlgorithms collection");
            }
            
            return algorithms[algorithmIdx];
        }
    }
}
