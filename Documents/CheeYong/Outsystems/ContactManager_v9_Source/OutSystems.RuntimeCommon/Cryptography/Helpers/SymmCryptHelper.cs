/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;



// ReSharper disable once CheckNamespace
namespace OutSystems.RuntimeCommon.Cryptography {
    /// <summary>
    /// NOTE: This algorithm is FIPS compliant...
    /// </summary>

    public static class SymmCryptHelper {

        private static int DefaultBufferSize = 1024 * 2; // bytes

        /// <summary>
        /// Creates an Encryptor CryptoStream based on the AES 128 OFB algorithm.
        /// </summary>
        /// <param name="outputStream">The output stream.</param>
        /// <param name="key">The Key.</param>
        /// <param name="iv"></param>
        /// <returns>The Encryptor CryptoStream</returns>
        private static CryptoStream GetAES128EncryptorStream(Stream outputStream, string key, string iv) {            
            // Pre: iv is a 16bytes base64 encoded string
            return CryptManager.Instance.GetAES128EncryptorStream(outputStream, CryptManager.DecodeBase64ToBytes(key), 
                CryptManager.DecodeBase64ToBytes(iv));
        }

        /// <summary>
        /// Creates a Decryptor CryptoStream based on the AES 128 OFB algorithm.
        /// </summary>
        /// <param name="inputStream">The input stream.</param>
        /// <param name="key">The Key.</param>
        /// <param name="iv"></param>
        /// <returns>the Decryptor CryptoStream</returns>
        private static CryptoStream GetAES128DecryptorStream(Stream inputStream, string key, string iv) {
            // Pre: iv is a 16bytes base64 encoded string
            return CryptManager.Instance.GetAES128DecryptorStream(inputStream, CryptManager.DecodeBase64ToBytes(key), 
                CryptManager.DecodeBase64ToBytes(iv));
        }
        
        private static void Encrypt(Stream outputStream, Action<Stream> produceContent, Func<Stream, CryptoStream> cryptoStreamCreator) {
            // This stream is used locally only to encrypt the content, allowing the outputStream to stay open
            using (var tempStream = new MemoryStream()) {
                using (var cryptoStream = cryptoStreamCreator(tempStream)) {
                    produceContent(cryptoStream);
                    cryptoStream.FlushFinalBlock();
                    tempStream.Position = 0;
                    StreamUtils.PumpStream(tempStream, outputStream);
                }
            }
        }
   
        private static void Decrypt(Stream inputStream, Action<Stream> consumeContent, Func<Stream, CryptoStream> cryptoStreamCreator) {
            using (var cryptoStream = cryptoStreamCreator(inputStream)) {
                consumeContent(cryptoStream);
            }
        }

        private static byte[] Encrypt(byte[] content, Func<Stream, CryptoStream> cryptoStreamCreator) {
            using (var outputStream = new MemoryStream()) {
                Encrypt(outputStream, stream => {
                    stream.Write(content, 0, content.Length);
                }, cryptoStreamCreator);

                return outputStream.ToArray();
            }
        }

        private static string Encrypt(string content, Func<Stream, CryptoStream> cryptoStreamCreator) {    
            return Convert.ToBase64String(Encrypt( Encoding.UTF8.GetBytes(content), cryptoStreamCreator));
        }

        private static byte[] Decrypt(byte[] content, Func<Stream, CryptoStream> cryptoStreamCreator) {
            using (var inputStream = new MemoryStream(content)) {
                byte[] result = null;

                Decrypt(inputStream, stream => {
                    result = StreamUtils.ToArray(stream, DefaultBufferSize);
                }, cryptoStreamCreator);

                return result;
            }
        }

        private static string Decrypt(string cipherText, Func<Stream, CryptoStream> cryptoStreamCreator) {
            return Encoding.UTF8.GetString(Decrypt(Convert.FromBase64String(cipherText), cryptoStreamCreator));
        }

        private static int PredictBase64OutputSize(int n) {
            return 4 * (int) Math.Ceiling(n / 3.0);
        }

        /// <summary>
        /// Creates an Encryptor CryptoStream based on the AES 256 CBC algorithm.
        /// </summary>
        /// <param name="outputStream">The output stream.</param>
        /// <param name="key">The Key.</param>
        /// <returns>The Encryptor CryptoStream</returns>
        /// <author>dfs</author>
        /// <datetime>18-01-2013-10:46</datetime>
        private static CryptoStream GetAES256EncryptorStreamWithFixedIV(Stream outputStream, string key, byte[] salt) {
            var keyGenerator = new Rfc2898DeriveBytes(key, salt);

            return CryptManager.Instance.GetAES256EncryptorStream(outputStream, keyGenerator.GetBytes(256 / 8),
                keyGenerator.GetBytes(CryptManager.Instance.AES256InitializationVectorSizeInBytes));
        }

        /// <summary>
        /// Creates a Decryptor CryptoStream based on the AES 256 CBC algorithm.
        /// </summary>
        /// <param name="inputStream">The input stream.</param>
        /// <param name="key">The Key.</param>
        /// <returns>the Decryptor CryptoStream</returns>
        /// <author>dfs</author>
        /// <datetime>18-01-2013-10:46</datetime>
        private static CryptoStream GetAES256DecryptorStreamWithFixedIV(Stream inputStream, string key, byte[] salt) {
            var keyGenerator = new Rfc2898DeriveBytes(key, salt);

            return CryptManager.Instance.GetAES256DecryptorStream(inputStream, keyGenerator.GetBytes(256 / 8),
                keyGenerator.GetBytes(CryptManager.Instance.AES256InitializationVectorSizeInBytes));
        }

        public static string EncryptWithAES256FixedIV(string password, string content, byte[] salt) {
            return Encrypt(content, s => GetAES256EncryptorStreamWithFixedIV(s, password, salt));
        }

        public static string DecryptWithAES256FixedIV(string password, string cipherText, byte[] salt) {
            try {
                return Decrypt(cipherText, s => GetAES256DecryptorStreamWithFixedIV(s, password, salt));
            } catch (Exception) {
                throw new InvalidOperationException("Cannot decrypt the content");
            }
        }

        /// <summary>
        /// Creates the set of bytes for a AES 256 CBC algorithm based on a key a salt.
        /// </summary>
        /// <param name="key">The key.</param>
        /// <param name="salt">The salt.</param>
        /// <returns>the key and salt bytes</returns>
        /// <author>csx</author>
        /// <datetime>21-05-2018-17:00</datetime>
        public static KeyData GetAES256KeyDataWithFixedIV(string key, byte[] salt) {
            var keyGenerator = new Rfc2898DeriveBytes(key, salt);

            return new KeyData(keyGenerator.GetBytes(256 / 8),
                keyGenerator.GetBytes(CryptManager.Instance.AES256InitializationVectorSizeInBytes));
        }

        public static string EncryptWithAES256(KeyData key, string content) {
            return Encrypt(content, s => GetAES256EncryptorStream(s, key));
        }

        public static string DecryptWithAES256(KeyData key, string cipherText) {
            try {
                return Decrypt(cipherText, s => GetAES256DecryptorStream(s, key));
            } catch (Exception) {
                throw new InvalidOperationException("Cannot decrypt the content");
            }
        }

        /// <summary>
        /// Creates an Encryptor CryptoStream based on the AES 256 CBC algorithm.
        /// </summary>
        /// <param name="outputStream">The output stream.</param>
        /// <param name="key">The Key.</param>
        /// <returns>The Encryptor CryptoStream</returns>
        /// <author>dfs</author>
        /// <datetime>18-01-2013-10:46</datetime>
        private static CryptoStream GetAES256EncryptorStream(Stream outputStream, KeyData key) {
            return CryptManager.Instance.GetAES256EncryptorStream(outputStream, key.KeyBytes, key.IVBytes);
        }

        /// <summary>
        /// Creates a Decryptor CryptoStream based on the AES 256 CBC algorithm.
        /// </summary>
        /// <param name="inputStream">The input stream.</param>
        /// <param name="key">The Key.</param>
        /// <returns>the Decryptor CryptoStream</returns>
        /// <author>dfs</author>
        /// <datetime>18-01-2013-10:46</datetime>
        private static CryptoStream GetAES256DecryptorStream(Stream inputStream, KeyData key) {
            return CryptManager.Instance.GetAES256DecryptorStream(inputStream, key.KeyBytes, key.IVBytes);
        }
    
        public static string EncryptWithAES128(string password, string content) {    
            var iv = CryptManager.Instance.GenerateStrongPassword(CryptManager.Instance.AES128InitializationVectorSizeInBytes);
            return iv + Encrypt(content, s => GetAES128EncryptorStream(s, password, iv));
        }

        public static string DecryptWithAES128(string password, string cipherText) {
            try {
                int ivSize = PredictBase64OutputSize(CryptManager.Instance.AES128InitializationVectorSizeInBytes);

                if (cipherText.Length < 2 * ivSize) {
                    throw new InvalidOperationException();
                }

                var iv = cipherText.Substring(0, ivSize);
                return Decrypt(cipherText.Substring(ivSize), s => GetAES128DecryptorStream(s, password, iv));
            } catch (Exception) {
                throw new InvalidOperationException("Cannot decrypt the content");
            }
        }


        public static string EncryptThenMacWithAES(string key, string plaintext) {
            string result = CryptManager.EncodeBase64(EncryptThenMacWithAES(CryptManager.DecodeBase64ToBytes(key), Encoding.UTF8.GetBytes(plaintext), null));
            return result;
        }



        public static byte[] EncryptThenMacWithAES(byte[] keyBytes, byte[] plainBytes, byte[] associatedData) {
            return EncryptThenMacWithAESDotNet(keyBytes, plainBytes, associatedData);
        }


        // first of all it's encrypt then mac, meaning it's a safe authenticated encryption construction
        // secondly it'll try to better hide the underlying plaintext size by adding padding.
        private static byte[] EncryptThenMacWithAESDotNet(byte[] keyBytes, byte[] plainBytes, byte[] associatedData) {

            using (Aes crypto = new AesManaged() {
                Mode = CipherMode.CBC,
                Padding = PaddingMode.PKCS7
            }) {
                crypto.Key = keyBytes;
                crypto.IV = CryptManager.Instance.GenerateSalt(crypto.BlockSize / 8);

                MemoryStream ms = new MemoryStream();
                ms.Write(crypto.IV, 0, crypto.IV.Length);
                using (CryptoStream cs = new CryptoStream(ms, crypto.CreateEncryptor(crypto.Key, crypto.IV), CryptoStreamMode.Write)) {
                    cs.Write(plainBytes, 0, plainBytes.Length);
                }
                ms.Close();
                var cipherBytes = ms.ToArray();

                HMACSHA256 mac = new HMACSHA256();
                mac.Key = keyBytes;

                byte[] allBytes = cipherBytes;
                if (associatedData != null) {
                    allBytes = new byte[cipherBytes.Length + associatedData.Length];
                    cipherBytes.CopyTo(allBytes, 0);
                    associatedData.CopyTo(allBytes, cipherBytes.Length);
                }

                byte[] macBytes = mac.ComputeHash(allBytes);

                MemoryStream resStream = new MemoryStream();
                resStream.Write(cipherBytes, 0, cipherBytes.Length);
                resStream.Write(macBytes, 0, macBytes.Length);
                return resStream.ToArray();
            }
        }


        public static string DecryptThenMacWithAES(string key, string ciphertext) {
            return Encoding.UTF8.GetString(DecryptThenMacWithAES(CryptManager.DecodeBase64ToBytes(key), CryptManager.DecodeBase64ToBytes(ciphertext), null));
        }

        public static byte[] DecryptThenMacWithAES(byte[] keyBytes, byte[] allBytes, byte[] associatedData) {
            return DecryptThenMacWithAESDotNet(keyBytes, allBytes, associatedData);
        }

        public static byte[] DecryptThenMacWithAESDotNet(byte[] keyBytes, byte[] allBytes, byte[] associatedData) {
            using (Aes crypto = new AesManaged() {
                Mode = CipherMode.CBC,
                Padding = PaddingMode.PKCS7
            }) {

                HMACSHA256 mac = new HMACSHA256();
                mac.Key = keyBytes;

                byte[] iv = new byte[crypto.BlockSize / 8];
                byte[] macBytes = new byte[mac.HashSize / 8];
                byte[] cipherBytes = new byte[allBytes.Length - iv.Length - macBytes.Length];

                using (MemoryStream ms = new MemoryStream(allBytes, /*writable*/false)) {
                    ms.Read(iv, 0, iv.Length);
                    ms.Read(cipherBytes, 0, cipherBytes.Length);
                    ms.Read(macBytes, 0, macBytes.Length);
                }

                crypto.Key = keyBytes;
                crypto.IV = iv;

                byte[] maccable = new byte[iv.Length + cipherBytes.Length];
                iv.CopyTo(maccable, 0);
                cipherBytes.CopyTo(maccable, iv.Length);

                byte[] hBytes = maccable;
                if (associatedData != null) {
                    hBytes = new byte[maccable.Length + associatedData.Length];
                    maccable.CopyTo(hBytes, 0);
                    associatedData.CopyTo(hBytes, maccable.Length);
                }

                byte[] mBytes = mac.ComputeHash(hBytes);

                // Need to question why the slowEquals here
                if (!CryptManager.SlowEquals(mBytes, macBytes)) {
                    throw new InvalidOperationException("Cannot decrypt the content");
                }

                MemoryStream output = new MemoryStream();
                using (CryptoStream cs = new CryptoStream(output, crypto.CreateDecryptor(), CryptoStreamMode.Write)) {
                    cs.Write(cipherBytes, 0, cipherBytes.Length);
                }
                output.Close();

                return output.ToArray();
            }
        }
    }
}