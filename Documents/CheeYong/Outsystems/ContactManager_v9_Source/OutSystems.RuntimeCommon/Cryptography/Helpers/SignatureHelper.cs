/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

namespace OutSystems.RuntimeCommon.Cryptography
{
    /// <summary>
    /// NOTE: This algorithm is FIPS compliant...
    /// </summary>
    public static class SignatureHelper
    {
        /// <summary>
        /// Signs the plain text with Hash-based Message Authentication Code (HMAC) using the <see cref="T:System.Security.Cryptography.SHA1"/>.
        /// </summary>
        /// <param name="plainText">The plain text.</param>
 		/// <param name="key">
        /// The secret key for encryption.
        /// The key can have any length but if it is more than 64 bytes long, it will be hashed
        ///  to derive a 64-byte key. Therefore, the recommended size of the secret key is 64 bytes.
        /// </param>
        /// <returns>The signed(hashed) text in Base64.</returns>
        /// <example>string signedString = SignatureHelper.Sign("This is a text example", "asdfEWFADScsdcAsadas13");</example>
        /// <author>dfs</author>
        /// <datetime>18-01-2013-11:44</datetime>
        public static string Sign(string plainText, string key) {
            return CryptManager.Instance.Sign(plainText, key);
        }

        /// <summary>
        /// Signs the array of bytes using Hash-based Message Authentication Code (HMAC) using the <see cref="T:System.Security.Cryptography.SHA1"/>.
        /// </summary>
        /// <param name="bytes">the array of bytes to be signed.</param>
        /// <param name="key">
        /// The secret key for encryption.
        /// The key can have any length but if it is more than 64 bytes long, it will be hashed
        ///  to derive a 64-byte key. Therefore, the recommended size of the secret key is 64 bytes.
        /// </param>
        /// <returns>The signed(hashed) text in Base64.</returns>
        /// <example>string signedStringFromBytes = SignatureHelper.Sign(arrBytes, "asdfEWFADScsdcAsadas13");</example>
        /// <author>dfs</author>
        /// <datetime>18-01-2013-11:44</datetime>
        public static string Sign(byte[] bytes, string key) {
            return CryptManager.Instance.Sign(bytes, key);
        }

        /// <summary>
        /// Signs the array of bytes using Hash-based Message Authentication Code (HMAC) using the <see cref="T:System.Security.Cryptography.SHA1"/>.
        /// </summary>
        /// <param name="bytes">the array of bytes to be signed.</param>
        /// <param name="key">
        /// The secret key for encryption.
        /// The key can have any length but if it is more than 64 bytes long, it will be hashed
        ///  to derive a 64-byte key. Therefore, the recommended size of the secret key is 64 bytes.
        /// </param>
        /// <returns>The signed(hashed) in bytes.</returns>
        /// <example>byte[] signedStringFromBytes = SignatureHelper.Sign(arrBytes, new byte[] {1, 2, 3});</example>
        /// <author>phb</author>
        /// <datetime>4-12-2015-16:33</datetime>
        public static byte[] ByteSign(byte[] bytes, byte[] key) {
            return CryptManager.Instance.ByteSign(bytes, key);
        }

        /// <summary>
        /// Signs the array of bytes using Hash-based Message Authentication Code (HMAC) using the <see cref="T:System.Security.Cryptography.HMACSHA256"/>.
        /// </summary>
        /// <param name="bytes">the array of bytes to be signed.</param>
        /// <param name="key"></param>
        /// <returns>The signed(hashed) in bytes.</returns>
        /// <author>ppc</author>
        /// <datetime>23-11-2016-01:20</datetime>
        public static byte[] ByteSignHMACSHA256(byte[] bytes, byte[] key) {
            return CryptManager.Instance.ByteSignHMACSHA256(bytes,key);
        }

        public static bool SlowEquals(byte[] sign1, byte[] sign2) {
            return CryptManager.SlowEquals(sign1, sign2);
        }

        public static bool SlowEquals(string sign1, string sign2) {
            return CryptManager.SlowEquals(sign1, sign2);
        }
    }
}