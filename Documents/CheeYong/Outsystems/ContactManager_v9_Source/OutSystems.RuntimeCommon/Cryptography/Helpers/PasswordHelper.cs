/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Security.Cryptography;
using System.Text;

// ReSharper disable once CheckNamespace


namespace OutSystems.RuntimeCommon.Cryptography
{
    public static class PasswordHelper
    {
        internal static readonly byte[] RFC_2898_DERIVE_BYTES_SALT = Convert.FromBase64String(
            "cyhAuARq2V0HRvo3TEtRGRzRwwHyD1Va5jFDiiNnJRADNxYUx8zb5nw1AvMpd2RaAaJMHQ6/w2ANiQu5J1nbKHNN0wxX8q4hkfzv3F64e9X8FnR1ZIPmcq9KZczMCdJ3+uGE3jWm/114tSioBOGsojt8SoT2vrrfQ1OQ32hwvFqPoPz24aNb12TWiYfcTbem8hk8KyGjjZOJ/WoM86AQ+bhJAAlsZ2lKFvFwTGXCJQn4iyFrMerlrQ+KsyawPN2aBbo7njlOeb7Hl4vELJKy9JXay0RQnZkvtogwUKfeK6dreNpzPOF+pVMIbe+SyAvNdE+cjAOUmx1pfd3CdHv6sw==");

        /// <summary>
        /// Generates a strong password using a secure random algorithm. (NOTE: This algorithm is FIPS compliant...)
        /// </summary>
        /// <returns>Strong password in Base64.</returns>
        /// <example>string strongPassword = PasswordHelper.GenerateStrongPassword();</example>
        /// <author>dfs</author>
        /// <datetime>18-01-2013-11:56</datetime>
        public static string GenerateStrongPassword() {
            return CryptManager.Instance.GenerateStrongPassword();
        }

        /// <summary>
        /// Generates a strong password using a secure random algorithm. (NOTE: This algorithm is FIPS compliant...)
        /// </summary>
        /// <param name="sizeInBytes">The size of the generated password, in bytes.</param>
        /// <returns>Strong password in Base64.</returns>
        /// <example>string strongPassword = PasswordHelper.GenerateStrongPassword(16);</example>
        /// <author>syg</author>
        /// <datetime>16-01-2014-14:29</datetime>
        public static string GenerateStrongPassword(int sizeInBytes) {
            return CryptManager.Instance.GenerateStrongPassword(sizeInBytes);
        }

        /// <summary>
        /// Computes the hash value for the specified text. (NOTE: This algorithm is FIPS compliant...)
        /// </summary>
        /// <param name="plainText">The plain text.</param>
        /// <param name="salt">The salt.</param>
        /// <returns>
        /// The hash value in string hexadecimal pairs, where
        /// each pair represents the corresponding element for
        /// example, "7F2C4A".
        /// </returns>
        /// <example>string hashedPassword = PasswordHelper.HexDeriveUsingUTF16("This is a text example");</example>
        /// <author>dfs</author>
        /// <datetime>18-01-2013-11:51</datetime>
        public static string HexDeriveUsingUTF16(string plainText, string salt) {
            return CryptManager.Instance.SHA512HexDeriveUsingUTF16(plainText, salt);
        }

        public static string DeriveKeyFromSecret(string secret, int keySizeInBytes) {
            var keyGenerator = new Rfc2898DeriveBytes(secret, RFC_2898_DERIVE_BYTES_SALT);
            return CryptManager.EncodeBase64(keyGenerator.GetBytes(keySizeInBytes));
        }

        // this class was introduced solely for the purpose of delaying the
        // initialization of the Random object
        public class PasswordWithLimitationsHelper {
            // the static constructor is needed to
            // ensure the instantiate-on-use behaviour
            // see http://www.yoda.arachsys.com/csharp/beforefieldinit.html
            static PasswordWithLimitationsHelper() { }

            // This one is used for cryptographic stuff, so use the secure one
            private static Random _randGenerator = RandomGenerator.GetSecureRandomGenerator();

            /// <summary>
            /// Generates a password using a secure random algorithm, but limiting the output to a set of known characters. 
            /// </summary>
            /// <returns>Password without encoding</returns>
            /// <example>string password = PasswordHelper.GeneratePassword(20, "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!.#");</example>
            /// <author>rcm</author>
            public static string GeneratePasswordWithCharacterLimitations(int length, string allowedChars) {

                StringBuilder password = new StringBuilder();
                int div = allowedChars.Length;
                for (int i = 0; i < length; i++) {
                    password.Append(allowedChars[_randGenerator.Next(div)]);
                }
                return password.ToString();
            }

            public static string AddSequenceAtRandomPosition(string originalPassword, string sequence) {
                int originalPasswordLength = originalPassword.Length;
                int pos = _randGenerator.Next(originalPasswordLength);
                return originalPassword.Left(pos) + sequence + originalPassword.Right(originalPasswordLength - pos);
            }
        }
    }
}