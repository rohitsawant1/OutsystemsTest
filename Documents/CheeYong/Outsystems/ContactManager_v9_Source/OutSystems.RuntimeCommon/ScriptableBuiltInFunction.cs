/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Globalization;
using System.Text;
using System.Text.RegularExpressions;

namespace OutSystems.RuntimeCommon {

    /// <summary>
    /// Contains the definitions for the scriptable builtin functions
    /// </summary>	
    /// <remarks>
    /// When a function is added, it is necessary to include it in the compiler.
    /// See the "FillFunctionInfo" function in the "Language" class.
    /// 
    /// NOTE : TRY/CATCH added to all functions even if we think/know they 
    /// throw no exception (just in case). Exception: fn returning the argument received.
    /// </remarks>
    public static class ScriptableBuiltInFunction {

        // Math functions
        public static decimal Abs(decimal n) {
            try {
                return Math.Abs(n);
            } catch {
                return Decimal.Zero;
            }
        }

        public static decimal Mod(decimal n, decimal m) {
            try {
                return n % m;
            } catch {
                return 0;
            }
        }

        public static decimal Power(decimal n, decimal m) {
            try {
                return Convert.ToDecimal(Math.Pow(Convert.ToDouble(n), Convert.ToDouble(m)));
            } catch {
                return Decimal.Zero;
            }
        }

        // for backward compatibility
        public static decimal Round(decimal n) {
            return Round(n, 0);
        }

        public static decimal Round(decimal n, int fractionalDigits) {
            try {
                return Math.Round(n, fractionalDigits);
            } catch {
                return Decimal.Zero;
            }
        }

        public static decimal Sqrt(decimal n) {
            try {
                return Convert.ToDecimal(Math.Sqrt(Convert.ToDouble(n)));
            } catch {
                return Decimal.Zero;
            }
        }

        public static decimal Trunc(decimal n) {
            try {
                if (n >= 0M) {
                    return Math.Floor(n);
                } else {
                    return Math.Ceiling(n);
                }
            } catch {
                return Decimal.Zero;
            }
        }

        // Numeric
        public static decimal Min(decimal n, decimal m) {
            try {
                return Math.Min(n, m);
            } catch {
                return Decimal.Zero;
            }
        }

        public static decimal Max(decimal n, decimal m) {
            try {
                return Math.Max(n, m);
            } catch {
                return Decimal.Zero;
            }
        }

        public static int Sign(decimal n) {
            try {
                return Math.Sign(n);
            } catch {
                return 0;
            }
        }

        // Text
        public static int Length(string t) {
            try {
                return t.Length;
            } catch {
                return 0;
            }
        }

        // #906491 - Support Surrogate Pairs
        public static int LengthSC(string t) {
            try {
                return StringUtils.LengthWithSC(t);
            } catch {
                return 0;
            }
        }

        public static string Concat(string t1, string t2) {
            try {
                return string.Concat(t1, t2);
            } catch {
                return string.Empty;
            }
        }

        public static string ToLower(string t) {
            try {
                return t.ToLower();
            } catch {
                return string.Empty;
            }
        }

        public static string ToUpper(string t) {
            try {
                return t.ToUpper();
            } catch {
                return string.Empty;
            }
        }

        public static string Trim(string t) {
            try {
                return t.Trim(' ');
            } catch {
                return string.Empty;
            }
        }

        public static string TrimStart(string t) {
            try {
                return t.TrimStart(' ');
            } catch {
                return string.Empty;
            }
        }

        public static string TrimEnd(string t) {
            try {
                return t.TrimEnd(' ');
            } catch {
                return string.Empty;
            }
        }

        // for backward compatibility
        public static int Index(string t, string s) {
            return Index(t, s, 0, false, false);
        }

        public static int Index(string t, string s, int startIndex, bool searchFromEnd, bool ignoreCase) {
            try {
                if (s.Length == 0) {// for consistency with sql Index (also vb behaviour when t=s=string.Empty)
                    return -1;
                }
                var comparisonType = ignoreCase ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal;
                if (searchFromEnd) {
                    if (startIndex != 0) {
                        return t.LastIndexOf(s, startIndex, comparisonType);
                    } else {
                        return t.LastIndexOf(s, comparisonType);
                    }
                } else {
                    if (startIndex != 0) {
                        return t.IndexOf(s, startIndex, comparisonType);
                    } else {
                        return t.IndexOf(s, comparisonType);
                    }
                }
            } catch {
                return -1;
            }
        }

        // #906491 - Support Surrogate Pairs
        public static int IndexSC(string t, string s, int startIndex, bool searchFromEnd, bool ignoreCase) {
            try {
                if (s.Length == 0) {// for consistency with sql Index (also vb behaviour when t=s=string.Empty)
                    return -1;
                }

                var comparisonType = ignoreCase ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal;

                if (searchFromEnd) {

                    if (startIndex == 0) {
                        return StringUtils.LastIndexOfWithSC(t, s, comparisonType);
                    } else {
                        return StringUtils.LastIndexOfWithSC(t, s, startIndex, comparisonType);
                    }

                } else {

                    if (startIndex == 0) {
                        return StringUtils.IndexOfWithSC(t, s, comparisonType);
                    } else {
                        return StringUtils.IndexOfWithSC(t, s, startIndex, comparisonType);
                    }
                }

            } catch {
                return -1;
            }
        }

        public static string Replace(string t, string s, string r) {
            try {
                return t.Replace(s, r);
            } catch {
                return string.Empty;
            }
        }

        public static string Substr(string t, int s, int l) {
            try {
                if (s >= 0 && l > 0 && t.Length >= s + l) {
                    return t.Substring(s, l);
                } else if (s >= 0 && l > 0 && t.Length > s) {
                    return t.Substring(s, t.Length - s);
                } else {
                    return string.Empty;
                }
            } catch {
                return string.Empty;
            }
        }

        // #906491 - Support Surrogate Pairs
        public static string SubstrSC(string t, int s, int l) {
            try {
                int tLength = StringUtils.LengthWithSC(t);

                if (s >= 0 && l > 0 && tLength >= s + l) {
                    return StringUtils.SubstringWithSC(t, s, l);
                } else if (s >= 0 && l > 0 && tLength > s) {
                    return StringUtils.SubstringWithSC(t, s, tLength - s);
                } else {
                    return string.Empty;
                }
            } catch {
                return string.Empty;
            }
        }

        public static string Chr(int unicodeCharCode) {
            try {
                if (unicodeCharCode >= char.MinValue && unicodeCharCode <= char.MaxValue)
                    return ((char)unicodeCharCode).ToString();
                else
                    return string.Empty;
            } catch {
                return string.Empty;
            }
        }

        // Date & Time
        public static DateTime CurrDate() {
            try {
                return DateTime.Today;
            } catch {
                return new DateTime(1900, 1, 1, 0, 0, 0);
            }
        }

        public static DateTime CurrTime() {
            try {
                DateTime dtmNow = DateTime.Now;
                return new DateTime(1900, 1, 1, dtmNow.Hour, dtmNow.Minute, dtmNow.Second);
            } catch {
                return new DateTime(1900, 1, 1, 0, 0, 0);
            }
        }

        public static DateTime CurrDateTime() {
            try {
                DateTime dtmNow = DateTime.Now;
                return new DateTime(dtmNow.Year, dtmNow.Month, dtmNow.Day,
                    dtmNow.Hour, dtmNow.Minute, dtmNow.Second);
            } catch {
                return new DateTime(1900, 1, 1, 0, 0, 0);
            }
        }

        public static int Day(DateTime dt) {
            try {
                return dt.Day;
            } catch {
                return 1;
            }
        }

        public static int Month(DateTime dt) {
            try {
                return dt.Month;
            } catch {
                return 1;
            }
        }

        public static int Year(DateTime dt) {
            try {
                return dt.Year;
            } catch {
                return 1900;
            }
        }

        public static int DayOfWeek(DateTime dt) {
            try {
                return (int)dt.DayOfWeek;
            } catch {
                return 0; // (as a matter of fact, 0=sunday)
            }
        }

        public static int Hour(DateTime dt) {
            try {
                return dt.Hour;
            } catch {
                return 0;
            }
        }

        public static int Minute(DateTime dt) {
            try {
                return dt.Minute;
            } catch {
                return 0;
            }
        }

        public static int Second(DateTime dt) {
            try {
                return dt.Second;
            } catch {
                return 0;
            }
        }

        public static DateTime BuildDateTime(DateTime d, DateTime t) {
            try {
                return new DateTime(d.Year, d.Month, d.Day, t.Hour, t.Minute, t.Second);
            } catch {
                return new DateTime(1900, 1, 1, 0, 0, 0);
            }
        }

        public static DateTime NewDate(int y, int mo, int d) {
            try {
                return new DateTime(y, mo, d);
            } catch {
                return new DateTime(1900, 1, 1, 0, 0, 0);
            }
        }

        public static DateTime NewTime(int h, int mi, int s) {
            try {
                return new DateTime(1900, 1, 1, h, mi, s);
            } catch {
                return new DateTime(1900, 1, 1, 0, 0, 0);
            }
        }

        public static DateTime NewDateTime(int y, int mo, int d, int h, int mi, int s) {
            try {
                return new DateTime(y, mo, d, h, mi, s);
            } catch {
                return new DateTime(1900, 1, 1, 0, 0, 0);
            }
        }

        public static DateTime AddDays(DateTime dt, int n) {
            try {
                return dt.AddDays(Convert.ToDouble(n));
            } catch { // here we could return the original dt, but I think it is better this way
                return new DateTime(1900, 1, 1, 0, 0, 0);
            }
        }

        public static DateTime AddMonths(DateTime dt, int n) {
            try {
                return dt.AddMonths(n);
            } catch { // here we could return the original dt, but I think it is better this way
                return new DateTime(1900, 1, 1, 0, 0, 0);
            }
        }

        public static DateTime AddYears(DateTime dt, int n) {
            try {
                return dt.AddYears(n);
            } catch { // here we could return the original dt, but I think it is better this way
                return new DateTime(1900, 1, 1, 0, 0, 0);
            }
        }

        public static DateTime AddHours(DateTime dt, int n) {
            try {
                return dt.AddHours(Convert.ToDouble(n));
            } catch { // here we could return the original dt, but I think it is better this way
                return new DateTime(1900, 1, 1, 0, 0, 0);
            }
        }

        public static DateTime AddMinutes(DateTime dt, int n) {
            try {
                return dt.AddMinutes(Convert.ToDouble(n));
            } catch { // here we could return the original dt, but I think it is better this way
                return new DateTime(1900, 1, 1, 0, 0, 0);
            }
        }

        public static DateTime AddSeconds(DateTime dt, int n) {
            try {
                return dt.AddSeconds(Convert.ToDouble(n));
            } catch { // here we could return the original dt, but I think it is better this way
                return new DateTime(1900, 1, 1, 0, 0, 0);
            }
        }

        // Diff functions had to match with the correspondent sql functions
        public static int DiffDays(DateTime dt, DateTime dt2) {
            try {
                DateTime d = DateTimeToDate(dt);
                DateTime d2 = DateTimeToDate(dt2);
                return d2.Subtract(d).Days;
            } catch {
                return 0;
            }
        }

        public static int DiffHours(DateTime dt, DateTime dt2) {
            try {
                DateTime d = dt.AddMinutes(-dt.Minute).AddSeconds(-dt.Second).AddMilliseconds(-dt.Millisecond);
                DateTime d2 = dt2.AddMinutes(-dt2.Minute).AddSeconds(-dt2.Second).AddMilliseconds(-dt2.Millisecond);
                return (int)d2.Subtract(d).TotalHours;
            } catch {
                return 0;
            }
        }

        public static int DiffMinutes(DateTime dt, DateTime dt2) {
            try {
                DateTime d = dt.AddSeconds(-dt.Second).AddMilliseconds(-dt.Millisecond);
                DateTime d2 = dt2.AddSeconds(-dt2.Second).AddMilliseconds(-dt2.Millisecond);
                return (int)d2.Subtract(d).TotalMinutes;
            } catch {
                return 0;
            }
        }

        public static int DiffSeconds(DateTime dt, DateTime dt2) {
            try {
                DateTime d = dt.AddMilliseconds(-dt.Millisecond);
                DateTime d2 = dt2.AddMilliseconds(-dt2.Millisecond);
                return (int)d2.Subtract(d).TotalSeconds;
            } catch {
                return 0;
            }
        }

        public static bool TryParseISO8601DateTime(string t, out DateTime dt) {
            return DateTime.TryParse(t, CultureInfo.InvariantCulture, DateTimeStyles.None, out dt);
        }

        // Type Conversion
        public static int TextToInteger(string t) {
            int result;
            if (Int32.TryParse(t, NumberStyles.Integer, FormatInfoLogic.Number, out result)) {
                return result;
            } else {
                return 0;
            }
        }

        public static long TextToLongInteger(string t) {
            long result;
            if (Int64.TryParse(t, NumberStyles.Integer, FormatInfoLogic.Number, out result)) {
                return result;
            } else {
                return 0;
            }
        }

        public static bool TextToLongIntegerValidate(string t) {
            long ignore;
            return Int64.TryParse(t, NumberStyles.Integer, FormatInfoLogic.Number, out ignore);
        }

        public static bool TextToIntegerValidate(string t) {
            int ignore;
            return Int32.TryParse(t, NumberStyles.Integer, FormatInfoLogic.Number, out ignore);
        }

        /// <summary>
        /// Parse integer input boxes - MUST throw an excetion on parse error
        /// </summary>
        /// <param name="textInteger">text integer to parse</param>
        /// <returns>integer parsed</returns>
        public static int TextToIntegerInput(string textInteger) {
            textInteger = TextToNumberInputGroupSeparatorClear(textInteger);
            return Int32.Parse(textInteger, NumberStyles.Integer, FormatInfoLogic.InputNumber);
        }

        public static long TextToLongIntegerInput(string textLongInteger) {
            textLongInteger = TextToNumberInputGroupSeparatorClear(textLongInteger);
            return Int64.Parse(textLongInteger, NumberStyles.Integer, FormatInfoLogic.InputNumber);
        }

        public static bool TextToLongIntegerInputValidate(string textLongInteger) {
            long ignore;
            textLongInteger = TextToNumberInputGroupSeparatorClear(textLongInteger);
            return Int64.TryParse(textLongInteger, NumberStyles.Integer, FormatInfoLogic.InputNumber, out ignore);
        }

        public static bool TextToIntegerInputValidate(string textInteger) {
            int ignore;
            textInteger = TextToNumberInputGroupSeparatorClear(textInteger);
            return Int32.TryParse(textInteger, NumberStyles.Integer, FormatInfoLogic.InputNumber, out ignore);
        }

        public static decimal TextToDecimal(string t) {
            decimal result;
            if (Decimal.TryParse(t, NumberStyles.Number, FormatInfoLogic.Number, out result)) {
                return result;
            } else {
                return 0.0M;
            }
        }

        public static bool TextToDecimalValidate(string textDecimal) {
            decimal ignore;
            return Decimal.TryParse(textDecimal, NumberStyles.Number, FormatInfoLogic.Number, out ignore);
        }

        /// <summary>
        /// Parse decimal/currency input boxes - MUST throw an excetion on parse error
        /// </summary>
        /// <param name="textDecimal">text decimal to parse</param>
        /// <returns>decimal parsed</returns>
        public static decimal TextToDecimalInput(string textDecimal) {
            textDecimal = TextToNumberInputGroupSeparatorClear(textDecimal);
            return Decimal.Parse(textDecimal, NumberStyles.Number, FormatInfoLogic.InputNumber);
        }

        public static bool TextToDecimalInputValidate(string textDecimal) {
            decimal ignore;
            textDecimal = TextToNumberInputGroupSeparatorClear(textDecimal);
            return Decimal.TryParse(textDecimal, NumberStyles.Number, FormatInfoLogic.InputNumber, out ignore);
        }

        private static string TextToNumberInputGroupSeparatorClear(string textNumber) {
            if (FormatInfoLogic.InputNumber.NumberGroupSeparator.Length > 0) {
                textNumber = textNumber.Replace(FormatInfoLogic.InputNumber.NumberGroupSeparator, "");
            }
            return textNumber;
        }

        public static DateTime TextToDateTime(string t) {
            // support for date text to date time text implicit conversion
            DateTime result;
            int i = t.IndexOf(":");
            var splitPos = t.ToUpperInvariant().IndexOf("T");
            if (splitPos > 0) {
                // assume ISO 8601 date and disregard date/time specifiers
                if (TryParseISO8601DateTime(t, out result)) {
                    return result;
                }
            } else {
                splitPos = t.IndexOf(" ");
            }
            if (splitPos < 0) {
                if (i < 0) {
                    if (DateTime.TryParseExact(t + " 00:00:00", FormatInfoLogic.defaultDateTimeFormats, FormatInfoLogic.defaultHeCultureInfo, DateTimeStyles.None, out result)) {
                        return result;
                    } else {
                        return NullDate();
                    }
                } else {
                    // We should't accept just a time!
                    return NullDate();
                }
            } else {
                if (t.IndexOf(":", i + 1) < 0) {
                    if (DateTime.TryParseExact(t + ":00", FormatInfoLogic.defaultDateTimeFormats, FormatInfoLogic.defaultHeCultureInfo, DateTimeStyles.None, out result)) {
                        return result;
                    } else {
                        return NullDate();
                    }
                } else {
                    if (DateTime.TryParseExact(t, FormatInfoLogic.defaultDateTimeFormats, FormatInfoLogic.defaultHeCultureInfo, DateTimeStyles.None, out result)) {
                        return result;
                    } else {
                        return NullDate();
                    }
                }
            }
        }

        public static bool TextToDateTimeValidate(string t) {
            DateTime ignore;
            int i = t.IndexOf(":");
            var splitPos = t.ToUpperInvariant().IndexOf("T");
            if (splitPos > 0) {
                // assume ISO 8601 date and disregard date/time specifiers
                return TryParseISO8601DateTime(t, out ignore);
            } else {
                splitPos = t.IndexOf(" ");
            }
            if (splitPos < 0) {
                if (i < 0)
                    return DateTime.TryParseExact(t + " 00:00:00", FormatInfoLogic.defaultDateTimeFormats, FormatInfoLogic.defaultHeCultureInfo, DateTimeStyles.None, out ignore);
                else {
                    // We should't accept just a time!
                    return false;
                }
            } else {
                if (t.IndexOf(":", i + 1) < 0) {
                    return DateTime.TryParseExact(t + ":00", FormatInfoLogic.defaultDateTimeFormats, FormatInfoLogic.defaultHeCultureInfo, DateTimeStyles.None, out ignore);
                } else {
                    return DateTime.TryParseExact(t, FormatInfoLogic.defaultDateTimeFormats, FormatInfoLogic.defaultHeCultureInfo, DateTimeStyles.None, out ignore);
                }
            }
        }

        public static DateTime TextToDate(string t) {
            DateTime result;
            var splitPos = t.ToUpperInvariant().IndexOf("T");
            if (splitPos < 0) splitPos = t.IndexOf(" ");
            if (splitPos < 0) {
                if (DateTime.TryParseExact(t + " 00:00:00", FormatInfoLogic.defaultDateTimeFormats, FormatInfoLogic.defaultHeCultureInfo, DateTimeStyles.None, out result)) {
                    return result;
                } else {
                    return new DateTime(1900, 1, 1, 0, 0, 0);
                }
            } else {
                if (DateTime.TryParseExact(t.Substring(0, splitPos) + " 00:00:00", FormatInfoLogic.defaultDateTimeFormats, FormatInfoLogic.defaultHeCultureInfo, DateTimeStyles.None, out result)) {
                    return result;
                } else {
                    return new DateTime(1900, 1, 1, 0, 0, 0);
                }
            }
        }

        public static bool TextToDateValidate(string t) {
            DateTime ignore;
            var splitPos = t.ToUpperInvariant().IndexOf("T");
            if (splitPos < 0) splitPos = t.IndexOf(" ");
            if (splitPos < 0) {
                return DateTime.TryParseExact(t + " 00:00:00", FormatInfoLogic.defaultDateTimeFormats, FormatInfoLogic.defaultHeCultureInfo, DateTimeStyles.None, out ignore);
            } else {
                return DateTime.TryParseExact(t.Substring(0, splitPos) + " 00:00:00", FormatInfoLogic.defaultDateTimeFormats, FormatInfoLogic.defaultHeCultureInfo, DateTimeStyles.None, out ignore);
            }
        }

        public static DateTime TextToTime(string t) {
            DateTime result;
            int i = t.IndexOf(":");

            if (i < 0) {
                return new DateTime(1900, 1, 1, 0, 0, 0);
            }

            var splitPos = t.ToUpperInvariant().IndexOf("T");
            if (splitPos > 0) {
                // assume ISO 8601 date and disregard date/time specifiers
                if (TryParseISO8601DateTime(t, out result)) {
                    result.Subtract(result - NullDate());
                    return result;
                }
            } else {
                splitPos = t.IndexOf(" ");
            }
            if (splitPos < 0) {
                if (t.IndexOf(":", i + 1) < 0) {
                    if (DateTime.TryParseExact("1900-01-01 " + t + ":00", FormatInfoLogic.defaultDateTimeFormats, FormatInfoLogic.defaultHeCultureInfo, DateTimeStyles.None, out result)) {
                        return result;
                    } else {
                        return new DateTime(1900, 1, 1, 0, 0, 0);
                    }
                } else {
                    if (DateTime.TryParseExact("1900-01-01 " + t, FormatInfoLogic.defaultDateTimeFormats, FormatInfoLogic.defaultHeCultureInfo, DateTimeStyles.None, out result)) {
                        return result;
                    } else {
                        return new DateTime(1900, 1, 1, 0, 0, 0);
                    }
                }
            } else {
                if (t.IndexOf(":", i + 1) < 0) {
                    if (DateTime.TryParseExact("1900-01-01 " + t.Substring(splitPos + 1) + ":00", FormatInfoLogic.defaultDateTimeFormats, FormatInfoLogic.defaultHeCultureInfo, DateTimeStyles.None, out result)) {
                        return result;
                    } else {
                        return new DateTime(1900, 1, 1, 0, 0, 0);
                    }
                } else {
                    if (DateTime.TryParseExact("1900-01-01 " + t.Substring(splitPos + 1), FormatInfoLogic.defaultDateTimeFormats, FormatInfoLogic.defaultHeCultureInfo, DateTimeStyles.None, out result)) {
                        return result;
                    } else {
                        return new DateTime(1900, 1, 1, 0, 0, 0);
                    }
                }
            }
        }

        public static bool TextToTimeValidate(string t) {
            DateTime ignore;
            int i = t.IndexOf(":");

            if (i < 0) {
                return false;
            }

            if (t.ToUpperInvariant().IndexOf("T") > 0) {
                // assume ISO 8601 date and disregard date/time specifiers
                return TryParseISO8601DateTime(t, out ignore);
            }
            if (t.IndexOf(" ") < 0) {
                if (t.IndexOf(":", i + 1) < 0) {
                    return DateTime.TryParseExact("1900-01-01 " + t + ":00", FormatInfoLogic.defaultDateTimeFormats, FormatInfoLogic.defaultHeCultureInfo, DateTimeStyles.None, out ignore);
                } else {
                    return DateTime.TryParseExact("1900-01-01 " + t, FormatInfoLogic.defaultDateTimeFormats, FormatInfoLogic.defaultHeCultureInfo, DateTimeStyles.None, out ignore);
                }
            } else {
                if (t.IndexOf(":", i + 1) < 0) {
                    return DateTime.TryParseExact("1900-01-01 " + t.Substring(t.IndexOf(" ") + 1) + ":00", FormatInfoLogic.defaultDateTimeFormats, FormatInfoLogic.defaultHeCultureInfo, DateTimeStyles.None, out ignore);
                } else {
                    return DateTime.TryParseExact("1900-01-01 " + t.Substring(t.IndexOf(" ") + 1), FormatInfoLogic.defaultDateTimeFormats, FormatInfoLogic.defaultHeCultureInfo, DateTimeStyles.None, out ignore);
                }
            }
        }

        public static string IntegerToText(int i) {
            try {
                return i.ToString(FormatInfoLogic.Number);
            } catch {
                return string.Empty;
            }
        }

        public static decimal IntegerToDecimal(int i) {
            try {
                return Convert.ToDecimal(i);
            } catch {
                return 0.0M;
            }
        }

        public static bool IntegerToBoolean(int i) {
            try {
                return Convert.ToBoolean(i);
            } catch {
                return false;
            }
        }

        public static string DecimalToText(decimal d) {
            try {
                string text = Convert.ToString(d, FormatInfoLogic.Number);

                // Remove trailing zeros
                return text.IndexOf(FormatInfoLogic.DecimalSeparator) == -1 ? text : text.TrimEnd('0').TrimEnd(FormatInfoLogic.DecimalSeparator);
            } catch {
                return string.Empty;
            }
        }

        public static int DecimalToInteger(decimal d) {
            try {
                return Convert.ToInt32(d);
            } catch {
                return 0;
            }
        }

        public static bool DecimalToIntegerValidate(decimal d) {
            try {
                Convert.ToInt32(d);
                return true;
            } catch {
                return false;
            }
        }

        public static long DecimalToLongInteger(decimal d) {
            try {
                return Convert.ToInt64(d);
            } catch {
                return 0;
            }
        }

        public static bool DecimalToLongIntegerValidate(decimal d) {
            try {
                Convert.ToInt64(d);
                return true;
            } catch {
                return false;
            }
        }

        public static bool DecimalToBoolean(decimal d) {
            try {
                return Convert.ToBoolean(d);
            } catch {
                return false;
            }
        }

        public static string LongIntegerToText(long b) {
            try {
                return b.ToString(FormatInfoLogic.Number);
            } catch {
                return string.Empty;
            }
        }

        public static int LongIntegerToInteger(long b) {
            try {
                return Convert.ToInt32(b);
            } catch {
                return 0;
            }
        }

        public static bool LongIntegerToIntegerValidate(long b) {
            try {
                Convert.ToInt32(b);
                return true;
            } catch {
                return false;
            }
        }

        public static string BooleanToText(bool b) {
            try {
                return b.ToString();
            } catch {
                return string.Empty;
            }
        }

        public static int BooleanToInteger(bool b) {
            try {
                return Convert.ToInt32(b);
            } catch {
                return 0;
            }
        }

        public static string DateTimeToText(DateTime dt) {
            try {
                return dt.ToString(FormatInfoLogic.GetOutputDateTimeFormatString(), FormatInfoLogic.defaultHeCultureInfo);
            } catch {
                return string.Empty;
            }
        }

        public static DateTime DateTimeToDate(DateTime dt) {
            try {
                return dt.Date;
            } catch {
                return new DateTime(1900, 1, 1, 0, 0, 0);
            }
        }

        public static DateTime DateTimeToTime(DateTime dt) {
            try {
                return new DateTime(1900, 1, 1, dt.Hour, dt.Minute, dt.Second);
            } catch {
                return new DateTime(1900, 1, 1, 0, 0, 0);
            }
        }

        public static string DateToText(DateTime d) {
            try {
                return d.ToString(FormatInfoLogic.GetOutputDateFormatString(), FormatInfoLogic.defaultHeCultureInfo);
            } catch {
                return string.Empty;
            }
        }

        public static DateTime DateToDateTime(DateTime d) {
            return d;
        }

        public static string TimeToText(DateTime t) {
            try {
                return t.ToString("HH:mm:ss", FormatInfoLogic.DateTime);
            } catch {
                return string.Empty;
            }
        }

        public static int IdentifierToInteger(int id) {
            return id;
        }

        public static int IntegerToIdentifier(int i) {
            return i;
        }

        public static long IdentifierToLongInteger(long id) {
            return id;
        }

        public static long LongIntegerToIdentifier(long b) {
            return b;
        }

        public static string IdentifierToText(string id) {
            return id;
        }

        public static string TextToIdentifier(string t) {
            return t;
        }

        public static int NullIdentifier() {
            return 0;
        }

        public static string NullTextIdentifier() {
            return string.Empty;
        }

        public static DateTime NullDate() {
            return new DateTime(1900, 1, 1);
        }

        public static DateTime MaxDate() {
            return new DateTime(9999, 12, 31, 23, 59, 59);
        }

        public static object NullObject() {
            return null;
        }

        public static string NewLine() {
            return "\r\n";
        }


        public static byte[] NullBinary() {
            return new byte[0];
        }

        public static object ToObject(object obj) {
            return obj;
        }

        // Formatting
        public static string FormatCurrency(decimal val, string symbol, int decimal_digits, string decimal_separator, string group_separator) {
            try {
                if (decimal_digits < 0) {
                    return "";
                }

                if (decimal_separator.Length > 1) {
                    decimal_separator = decimal_separator.Substring(0, 1);
                }

                if (group_separator.Length > 1) {
                    group_separator = group_separator.Substring(0, 1);
                }

                NumberFormatInfo nfi = new NumberFormatInfo();
                nfi.CurrencySymbol = symbol;
                nfi.CurrencyDecimalDigits = decimal_digits;
                if (decimal_digits != 0) { //issue #9077
                    nfi.CurrencyDecimalSeparator = decimal_separator;
                }
                nfi.CurrencyGroupSeparator = group_separator;
                nfi.CurrencyGroupSizes[0] = 3;
                nfi.CurrencyNegativePattern = 2; // #1191818 - remove space between symbol and value
                nfi.CurrencyPositivePattern = 0; // #1191818 - remove space between symbol and value
                return val.ToString("C", nfi);
            } catch {
                return string.Empty;
            }
        }

        public static string FormatDecimal(decimal val, int decimal_digits, string decimal_separator, string group_separator) {
            try {
                if (decimal_digits < 0) {
                    return "";
                }

                if (decimal_separator.Length > 1) {
                    decimal_separator = decimal_separator.Substring(0, 1);
                }

                if (group_separator.Length > 1) {
                    group_separator = group_separator.Substring(0, 1);
                }

                NumberFormatInfo nfi = new NumberFormatInfo();
                nfi.NumberDecimalDigits = decimal_digits;
                if (decimal_digits != 0) { //issue #9077
                    nfi.NumberDecimalSeparator = decimal_separator;
                }
                nfi.NumberGroupSeparator = group_separator;
                nfi.NumberGroupSizes[0] = 3;
                nfi.NumberNegativePattern = 1;
                return val.ToString("N", nfi);
            } catch {
                return string.Empty;
            }
        }

        public static string FormatPercent(decimal val, int decimal_digits, string decimal_separator) {
            try {
                if (decimal_digits < 0) {
                    return "";
                }

                if (decimal_separator.Length > 1) {
                    decimal_separator = decimal_separator.Substring(0, 1);
                }

                NumberFormatInfo nfi = new NumberFormatInfo();
                nfi.PercentDecimalDigits = decimal_digits;
                if (decimal_digits != 0) { //issue #9077
                    nfi.PercentDecimalSeparator = decimal_separator;
                }
                nfi.PercentGroupSeparator = string.Empty;
                nfi.PercentGroupSizes[0] = 0;
                nfi.PercentNegativePattern = 1;
                nfi.PercentPositivePattern = 1;
                nfi.PercentSymbol = "%";
                return val.ToString("P", nfi);
            } catch {
                return string.Empty;
            }
        }

        public static string FormatPhoneNumber(
            string val,
            int int_code_digits,
            int area_code_digits,
            int phone_digits,
            string int_separator,
            string area_separator,
            string phone_separator) {
            try {
                foreach (char c in val)
                    if (!char.IsDigit(c))
                        return val;
                if (val.Length != (int_code_digits + area_code_digits + phone_digits))
                    return val;
                return int_separator + val.Substring(0, int_code_digits) + area_separator +
                    val.Substring(int_code_digits, area_code_digits) + phone_separator +
                    val.Substring(int_code_digits + area_code_digits, phone_digits);
            } catch {
                return string.Empty;
            }
        }

        private const string SupportedDateTimeFormatCharacters = "dhHmMstyzfF";
        private const string EscapeUnsupportedDateTimeFormatRegexPattern = @"(?:\\(.))|([^" + SupportedDateTimeFormatCharacters + "])";
        public static string FormatDateTime(DateTime dt, string format) {
            try {
                format = Regex.Replace(format, EscapeUnsupportedDateTimeFormatRegexPattern, "\\$1$2"); // escape characters that we don't want support
                if (format.Length == 1) {
                    format = "%{0}".F(format);
                }
                return dt.ToString(format, new DateTimeFormatInfo());
            } catch {
                return string.Empty;
            }
        }

        public static string FormatShortDateTime(DateTime dt, string date_separator, string time_separator) {
            try {
                DateTimeFormatInfo dtfi = new DateTimeFormatInfo();
                dtfi.DateSeparator = date_separator;
                dtfi.TimeSeparator = time_separator;
                return dt.ToString("yyyy/MM/dd HH:mm:ss", dtfi);
            } catch {
                return string.Empty;
            }
        }

        public static string FormatFullDateTime(DateTime dt, string date_separator, string time_separator) {
            try {
                DateTimeFormatInfo dtfi = new DateTimeFormatInfo();
                dtfi.DateSeparator = date_separator;
                dtfi.TimeSeparator = time_separator;
                return dt.ToString("dd/MMMM/yyyy HH:mm:ss", dtfi);
            } catch {
                return string.Empty;
            }
        }

        public static string FormatFullDate(DateTime d, string date_separator) {
            try {
                DateTimeFormatInfo dtfi = new DateTimeFormatInfo();
                dtfi.DateSeparator = date_separator;
                return d.ToString("dd/MMMM/yyyy", dtfi);
            } catch {
                return string.Empty;
            }
        }

        public static string FormatTime(DateTime t, string time_separator) {
            try {
                DateTimeFormatInfo dtfi = new DateTimeFormatInfo();
                dtfi.TimeSeparator = time_separator;
                return t.ToString("HH:mm:ss", dtfi);
            } catch {
                return string.Empty;
            }
        }

        public static string FormatMonthDayDate(DateTime d, string date_separator) {
            try {
                DateTimeFormatInfo dtfi = new DateTimeFormatInfo();
                dtfi.DateSeparator = date_separator;
                return d.ToString("dd/MMMM", dtfi);
            } catch {
                return string.Empty;
            }
        }

        public static string FormatShortDate(DateTime d, string date_separator) {
            try {
                DateTimeFormatInfo dtfi = new DateTimeFormatInfo();
                dtfi.DateSeparator = date_separator;
                return d.ToString("yyyy/MM/dd", dtfi);
            } catch {
                return string.Empty;
            }
        }

        public static string FormatYearMonthDate(DateTime d, string date_separator) {
            try {
                DateTimeFormatInfo dtfi = new DateTimeFormatInfo();
                dtfi.DateSeparator = date_separator;
                return d.ToString("MMMM/yyyy", dtfi);
            } catch {
                return string.Empty;
            }
        }

        public static string FormatText(string val, int min_chars, int max_chars, bool left_padding,
            string padding_char) {
            try {
                if (val.Length < min_chars) {
                    if (left_padding)
                        return val.PadLeft(min_chars, padding_char[0]);
                    else
                        return val.PadRight(min_chars, padding_char[0]);
                }
                if (val.Length > max_chars) {
                    if (left_padding)
                        return val.Substring(val.Length - max_chars, max_chars);
                    else
                        return val.Substring(0, max_chars);
                }
                return val;
            } catch {
                return string.Empty;
            }
        }

        // #906491 - Support Surrogate Pairs
        public static string FormatTextSC(string val, int min_chars, int max_chars, bool left_padding, string padding_char) {
            try {
                int valLength = StringUtils.LengthWithSC(val);

                string firstTextElement = StringUtils.SubstringWithSC(padding_char, 0, 1);
                StringBuilder sb = new StringBuilder();

                if (valLength < min_chars) {
                    if (left_padding) {
                        sb.Append(StringUtils.Repeat(firstTextElement, min_chars - valLength));
                        sb.Append(val);
                        return sb.ToString();
                    } else {
                        sb.Append(val);
                        sb.Append(StringUtils.Repeat(firstTextElement, min_chars - valLength));
                        return sb.ToString();
                    }
                }
                if (valLength > max_chars) {
                    if (left_padding) {
                        return StringUtils.SubstringWithSC(val, valLength - max_chars, max_chars);
                    } else {
                        return StringUtils.SubstringWithSC(val, 0, max_chars);
                    }
                }
                return val;
            } catch {
                return string.Empty;
            }
        }

        public static bool EmailAddressValidate(string address) {
            return ScriptableEmailFunctions.IsValid(address);
        }
    }
}