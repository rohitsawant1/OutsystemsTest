/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace OutSystems.RuntimeCommon {
    
    public static class StringUtils {

        /// <summary>
        /// Remove accents from strings
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static string WithoutDiacritics(this string value) {
            value = value.Normalize(NormalizationForm.FormD);
            StringBuilder sb = new StringBuilder(value.Length);
            foreach (char c in value) {
                if (CharUnicodeInfo.GetUnicodeCategory(c) != UnicodeCategory.NonSpacingMark) {
                    sb.Append(c);
                }
            }
            return sb.ToString();
        }

        /// <summary>
        /// Removes any invalid char with '_'. The resulting string should be a valid identifier.
        /// </summary>
        /// <param name="s"></param>
        /// <returns></returns>
        public static string WithoutInvalidChars(this string s) {
            return WithoutInvalidChars(s, '_');
        }

        /// <summary>
        /// Replaces all the branding, changing {C} for Company Name, {P} for Platform Name,
        /// {S} for Support Email and {U} for company URL.
        /// The replacement string are located on LabelingResources.resx
        /// </summary>
        /// <param name="s">The string to be replaced</param>
        /// <returns></returns>
        public static string ReplaceBranding(this string s) {
            if (Labeling.CompanyName == Labeling.PlatformName) {
                // When product and company name are the same use just one
                s = s.Replace("{C} {P}", Labeling.CompanyName);
            }
            return s.Replace("{C}", Labeling.CompanyName)
                    .Replace("{P}", Labeling.PlatformName)
                    .Replace("{S}", Labeling.SupportEmailAddress)
                    .Replace("{U}", Labeling.CompanyBaseURL);
        }

        /// <summary>
        /// Removes any invalid char with replaceChar. The resulting string should be a valid identifier.
        /// </summary>
        /// <param name="s"></param>
        /// <returns></returns>
        public static string WithoutInvalidChars(this string s, char? replaceChar) {
            return WithoutInvalidChars(s, replaceChar, IsValidChar);
        }

        private static readonly HashSet<char> CharsToRemoveInsteadOfReplacing = new HashSet<char>() { ' ', '-', '&' };

        public static string WithoutInvalidChars(this string s, char? replaceChar, Func<char, bool> isValidChar) {
            var result = new StringBuilder();

            foreach (char c in s.WithoutDiacritics()) {
                if (isValidChar(c)) {
                    result.Append(c);
                } else if (replaceChar.HasValue && !CharsToRemoveInsteadOfReplacing.Contains(c)) {
                    result.Append(replaceChar.Value);
                }
            }

            return result.ToString();
        }

        public static bool IsValidChar(char c) {
            return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c == '_';
        }

        public static bool ContainsIgnoreCase(this string str, string subStr) {
            return str.IndexOf(subStr, StringComparison.OrdinalIgnoreCase) != -1;
        }

        public static string SuffixIfNotEmpty(this string s, string suffix) {
            return string.IsNullOrEmpty(s) ? s : s + suffix;
        }

        private static Regex blockCommentsRegex;
        private static Regex CommentsRegex {
            get {
                if (blockCommentsRegex == null) {
                    blockCommentsRegex = new Regex(@"/\*(?>(?:(?>[^*]+)|\*(?!/))*)\*/", RegexOptions.Compiled);
                }
                return blockCommentsRegex;
            }
        }

        private static Regex lineCommentsRegex;
        private static Regex LineCommentsRegex {
            get {
                if (lineCommentsRegex == null) {
                    lineCommentsRegex = new Regex(@"(\/\/.*$)", RegexOptions.Compiled | RegexOptions.Multiline);
                }
                return lineCommentsRegex;
            }
        }

        private static Regex stringsRegex;
        private static Regex StringsRegex {
            get {
                if (stringsRegex == null) {
                    stringsRegex = new Regex(@"""([^""\\]|\\.)*""|'([^'\\]|\\.)*'", RegexOptions.Compiled);
                }
                return stringsRegex;
            }
        }

        private static string validQueryForCountPattern = @"^(\s|\()*SELECT\b";
        private static RegexOptions commonOptions = RegexOptions.Compiled | RegexOptions.IgnoreCase | RegexOptions.ExplicitCapture;

        private static Regex validQueryForCountSingleLineRegex;
        public static Regex ValidQueryForCountSingleLineRegex {
            get {
                if (validQueryForCountSingleLineRegex == null) {
                    return validQueryForCountSingleLineRegex = new Regex(validQueryForCountPattern, commonOptions | RegexOptions.Singleline);
                }
                return validQueryForCountSingleLineRegex;
            }
        }

        private static Regex validQueryForCountMultiLineRegex;
        public static Regex ValidQueryForCountMultiLineRegex {
            get {
                if (validQueryForCountMultiLineRegex == null) {
                    return validQueryForCountMultiLineRegex = new Regex(validQueryForCountPattern, commonOptions | RegexOptions.Multiline);
                }
                return validQueryForCountMultiLineRegex;
            }
        }

        /// <summary>
        /// Returns a string without block comments
        /// Note: nested comments are not supported
        /// </summary>
        public static string WithoutBlockComments(string text) {
            return WithoutBlockComments(text, match => string.Empty);
        }

        /// <summary>
        /// Returns a string without block comments
        /// Note: nested comments are not supported
        /// </summary>
        public static string WithoutBlockComments(string text, MatchEvaluator eval) {
            return CommentsRegex.Replace(text, eval);
        }

        /// <summary>
        /// Executes a delegate for each match of a block comment found
        /// Note: nested comments are not supported
        /// </summary>
        public static void ForEachBlockComment(string text, Action<Match> eval) {
            foreach (Match match in CommentsRegex.Matches(text)) {
                eval(match);
            }
        }

        /// <summary>
        /// Returns a string without line comments
        /// Note: If there are any urls like http:// they will be removed also. Consider removing/replacing them before
        /// </summary>
        public static string WithoutLineComments(string text) {
            return LineCommentsRegex.Replace(text, match => string.Empty);
        }

        /// <summary>
        /// Returns a string with each string replaced by the result of the evaluator
        /// </summary>
        public static string ReplaceStringLiterals(string text, MatchEvaluator eval) {
            return StringsRegex.Replace(text, eval);
        }

        public static string Left(this string s, int length) {
            if (s.Length <= length) {
                return s;
            } else return s.Substring(0, length);
        }

        public static string LeftCut(this string s, int length) {
            return s.Substring(length);
        }

        public static string Right(this string s, int length) {
            if (s.Length <= length) {
                return s;
            } else return s.Substring(s.Length - length, length);
        }

        public static string RightCut(this string s, int cutLength) {
            return s.Substring(0, s.Length - cutLength);
        }

        [DebuggerNonUserCode]
        public static bool IsEmpty(this string s) {
            return string.IsNullOrEmpty(s);
        }

        private static Regex invalidPrefixRegex;
        public static string FixName(this string name, bool extended) {
            return FixName(name, extended, -1);
        }

        public static string FixName(this string name, bool extended, int nameLimit) {
            if (!extended && invalidPrefixRegex == null) {
                invalidPrefixRegex = new Regex("^[0-9_]+", RegexOptions.Compiled);
            }
            var result = name == null ? string.Empty :
                extended ? name.Trim() :
                invalidPrefixRegex.Replace(name.WithoutInvalidChars(), string.Empty);
            if (nameLimit != -1 && result.Length > nameLimit) {
                result = result.Left(nameLimit);
            }

            return result;
        }
        
        private static Regex invalidFileNameCharsRegex;
        public static string FixFileName(this string fileName) {
            if (invalidFileNameCharsRegex == null) {
                invalidFileNameCharsRegex = new Regex("[" + Regex.Escape(Path.GetInvalidFileNameChars().StrCat("")) + "]", RegexOptions.Compiled);
            }
            return fileName == null ? string.Empty : invalidFileNameCharsRegex.Replace(fileName, "_");
        }

        public static string ToPascalCase(this string value) {
            string s = value.Trim();
            if (s.Length == 0) {
                return value;
            }
            string[] ar;
            if (s.IndexOf('_') > -1) {
                ar = s.Split('_');
            } else if (s.IndexOf(' ') > -1) {
                ar = s.Split(' ');
            } else if (s.IndexOf('-') > -1) {
                ar = s.Split('-');
            } else {
                ar = new[] { s };
            }
            s = string.Empty;
            for (int i = 0; i < ar.Length; i++) {
                if (ar[i].Trim().Length > 0) {
                    s += ar[i].Substring(0, 1).ToUpper() + ar[i].Substring(1);
                }
            }
            return s;
        }

        public static string ToLabel(this string name) {
            if (name.IsEmpty()) {
                return name;
            }
            string label = name.ToLabelAllowingIdSuffix();
            if (label.EndsWith(" id", StringComparison.OrdinalIgnoreCase)) {
                label = label.Substring(0, label.Length - 3);
            }
            return label;
        }

        public static string ToLabelAllowingIdSuffix(this string name) {
            string label = name.Replace('_', ' ');
            for (int i = 0; i < label.Length - 1; ++i) {
                if (
                    // case: Stati[c|E]ntity -> Static Entity
                    char.IsLower(label[i]) && char.IsUpper(label[i + 1]) && !label.Substring(0, i + 1).IsOneOf("e", "i") ||
                    // case: AP[I|Me]thod -> API Method
                    i + 2 < label.Length && char.IsUpper(label[i]) && char.IsUpper(label[i + 1]) && char.IsLower(label[i + 2]) ||
                    // case: Entit[y|1] -> Entity 1
                    !char.IsDigit(label[i]) && char.IsDigit(label[i + 1])
                ) {
                    label = label.Substring(0, i + 1) + " " + label.Substring(i + 1);
                    i += 1; // We added a space
                }
            }
            return label;
        }

        /// <summary>
        /// Splits a Pascal case word into a standard css class name. E.g. SlideFromLeft -> slide-from-left
        /// </summary>
        /// <param name="cssClass"></param>
        /// <returns></returns>
        public static string ToCSSValue(this string cssClass) {
            return Regex.Replace(cssClass, "[a-z][A-Z]", m => m.Value[0] + "-" + m.Value[1]).ToLowerInvariant();
        }

        public static string F(this string format, params object[] args) {
            return string.Format(format, args);
        }

        public static string[] SafeSplit(this string s, char separator) {
            return s.IsEmpty() ? EmptyArray<string>.Instance : s.Split(separator);
        }

        public static string NormalizeNewLines(this string s) {
            return s.Replace("\r", null);
        }

        public static string RemoveNewLines(this string s) {
            s = s.Replace("\r", null);
            while (s.Contains("\n\n")) {
                s = s.Replace("\n\n", "\n");
            }
            s = s.Replace("\n", " ");
            return s;
        }

        public static string RemoveIfStartsWith(this string s, string toRemove) {
            if (s.StartsWith(toRemove)) {
                return s.Substring(toRemove.Length);
            }
            return s;
        }

        public static string RemoveIfEndsWith(this string s, string toRemove) {
            if (s.EndsWith(toRemove)) {
                return s.Substring(0, s.Length - toRemove.Length);
            }
            return s;
        }

        public static string WithoutTrailingDigits(this string s) {
            return s.TrimEnd('0', '1', '2', '3', '4', '5', '6', '7', '8', '9');
        }

        public static string WithoutWhiteSpace(this string s) {
            return s.Replace(" ", null).Replace("\n", null).Replace("\r", null).Replace("\t", null);
        }

        public static string TrimStart(this string s) {
            int i;
            for (i = 0; i < s.Length; i++) {
                if (!char.IsWhiteSpace(s[i])) {
                    break;
                }
            }
            return s.Substring(i);
        }

        public static string TrimEnd(this string s) {
            int i;
            for (i = s.Length - 1; i >= 0; i--) {
                if (!char.IsWhiteSpace(s[i])) {
                    break;
                }
            }
            return s.Substring(0, i);
        }

        public static string Capitalize(this string s) {
            if (s.IsEmpty()) {
                return s;
            }
            return s[0].ToString().ToUpper() + s.Substring(1);
        }

        public static string DecapitalizeFirstWord(this string s) {
            if (s.IsEmpty()) {
                return s;
            }

            if (char.IsLower(s[0])) {
                throw new InvalidOperationException("String '" + s + "' is not in the correct case");
            }
            string result = string.Empty;
            int pos = 0;
            while (pos < s.Length && char.IsUpper(s[pos])) {
                result += char.ToLower(s[pos++]);
            }
            if (pos == 1) {
                return result + s.Substring(pos);
            } else if (pos == s.Length) {
                return result;
            } else {
                return result.Substring(0, pos - 1) + s.Substring(pos - 1);
            }
        }

        public static bool EqualsIgnoreCase(this string str, string other) {
            return (str ?? string.Empty).Equals(other ?? string.Empty, StringComparison.OrdinalIgnoreCase);
        }

        public static bool StartsWithIgnoreCase(this string str, string other) {
            return (str ?? string.Empty).StartsWith(other ?? string.Empty, StringComparison.OrdinalIgnoreCase);
        }

        public static bool EndsWithIgnoreCase(this string str, string other) {
            return (str ?? string.Empty).EndsWith(other ?? string.Empty, StringComparison.OrdinalIgnoreCase);
        }

        public static int IndexOfIgnoreCase(this string str, string subStr) {
            return str.IndexOf(subStr, StringComparison.OrdinalIgnoreCase);
        }

        public static int IndexOfIgnoreCase(this string str, string subStr, int startIndex) {
            return str.IndexOf(subStr, startIndex, StringComparison.OrdinalIgnoreCase);
        }

        public static int CountOccurrences(this string str, string subStr) {
            int startIndex = 0;
            int count = 0;
            int pos;
            while ((pos = str.IndexOf(subStr, startIndex)) != -1) {
                count += 1;
                startIndex = pos + subStr.Length;
            }
            return count;
        }

        public static int CountOccurrencesIgnoringCase(this string str, string subStr) {
            int startIndex = 0;
            int count = 0;
            int pos;
            while ((pos = str.IndexOfIgnoreCase(subStr, startIndex)) != -1) {
                count += 1;
                startIndex = pos + subStr.Length;
            }
            return count;
        }

        public static string FixEmptyStringAndNormalizeNewLines(this string str) {
            return str.IsEmpty() ? null : str.NormalizeNewLines();
        }

        public static string FixEmptyStringAndRemoveNewLines(this string str) {
            return str.IsEmpty() ? null : str.RemoveNewLines();
        }

        /// <summary>
        /// Does NOT replace ' with &apos;
        /// </summary>
        public static string EscapeXml(this string s) {
            if (s != null) {
                s = s.Replace("&", "&amp;");
                s = s.Replace("<", "&lt;");
                s = s.Replace(">", "&gt;");
                s = s.Replace("\"", "&quot;");
            }
            return s;
        }

        /// <summary>
        /// Does NOT replace &apos; with '
        /// </summary>
        public static string UnescapeXml(this string s) {
            if (s != null) {
                s = s.Replace("&lt;", "<");
                s = s.Replace("&gt;", ">");
                s = s.Replace("&quot;", "\"");
                s = s.Replace("&amp;", "&");
            }
            return s;
        }

        //all leading and trailing spaces should be converted to &nbsp;
        //sequences of more than one space in the middle should be converted to &nbsp; except for the last space in that sequence
        //instead of &nbsp; we use #160 (\xA0), to save space in the final html and to ease the algorithm
        public static string FixHtmlSpaces(this string s) {
            if (s.IsEmpty()) {
                return s;
            }
            char[] chars = new char[s.Length];
            if (s[0] == ' ') {
                chars[0] = '\xA0';
            } else {
                chars[0] = s[0];
            }
            for (int i = 1; i < s.Length - 1; ++i) {
                if (s[i] == ' ' && (s[i - 1] == '\n' || s[i + 1] == ' ')) {
                    chars[i] = '\xA0';
                } else {
                    chars[i] = s[i];
                }
            }
            if (s.Length != 1) {
                if (s[s.Length - 1] == ' ') {
                    chars[s.Length - 1] = '\xA0';
                } else {
                    chars[s.Length - 1] = s[s.Length - 1];
                }
            }
            return new string(chars);
        }

        /// <summary>
        /// Escape CSharp and Java literals
        /// </summary>
        public static string EscapeStringLiteral(this string s) {
            return s.Replace("\\", "\\\\")
                    .Replace("\"", "\\\"")
                    .Replace("\'", "\\\'")
                    .Replace("\n", "\\n")
                    .Replace("\r", "\\r")
                    .Replace("\t", "\\t");
        }

        public static string SafeEscapeString(this string s) {
            return s.Replace("\\\t", "\\t")
                    .Replace("\t", "\\t")
                    .Replace("\\\r", "\\r")
                    .Replace("\r", "\\r")
                    .Replace("\\\n", "\\n")
                    .Replace("\n", "\\n");
        }

        public static string ToSourceCode(this string s) {
            if (s == null) {
                return "null";
            } else {
                return "\"" + s.EscapeStringLiteral() + "\"";
            }
        }

        public static string PrefixIfNotEmpty(this string s, string prefix) {
            return s.IsEmpty() ? s : prefix + s;
        }

        public static string SurroundedInQuotes(this string s) {
            return SurroundedInQuotes(s, '"');
        }

        public static string SurroundedInQuotes(this string s, char quoteChar) {
            return quoteChar.ToString() + s.WithoutSurroundingQuotes(quoteChar) + quoteChar.ToString();
        }

        public static string WithoutSurroundingQuotes(this string s) {
            return WithoutSurroundingQuotes(s, '"');
        }

        public static string WithoutSurroundingQuotes(this string s, params char[] quoteChars) {
            if (s.Length > 1) {
                foreach (char c in quoteChars) {
                    if (s.StartsWith(c.ToString()) && s.EndsWith(c.ToString())) {
                        return s.Substring(1, s.Length - 2);
                    }
                }
            }
            return s;
        }

        public static bool StartsWithSegment(this string str, string segment) {

            if (str.EqualsIgnoreCase(segment)) {
                return true;
            }

            if ((str.StartsWith(segment) || str.StartsWith(segment.ToLower())) && (char.IsUpper(str[segment.Length]) || !char.IsLetter(str[segment.Length]))) {
                return true;
            }

            if (str.StartsWith(segment.ToUpper()) && (char.IsLower(str[segment.Length]) || !char.IsLetter(str[segment.Length]))) {
                return true;
            }

            return false;
        }

        public static bool EndsWithSegment(this string str, string segment) {

            if (str.EqualsIgnoreCase(segment)) {
                return true;
            }

            if ((str.EndsWith(segment) || str.EndsWith(segment.ToLower())) && (char.IsUpper(str[str.Length - segment.Length]) || !char.IsLetter(str[str.Length - segment.Length]))) {
                return true;
            }

            if (str.EndsWith(segment.ToUpper()) && (char.IsLower(str[str.Length - segment.Length]) || !char.IsLetter(str[str.Length - segment.Length]))) {
                return true;
            }

            return false;
        }

        public static bool ContainsSegment(this string str, string segment) {

            if (str.StartsWithSegment(segment)) {
                return true;
            }

            var index = str.IndexOfIgnoreCase(segment);
            if (index <= 0) {
                return false;
            }

            if (char.IsLetter(str[index - 1])) {
                if (char.IsLower(str[index - 1]) == char.IsLower(str[index])) {
                    return false;
                }
            }

            if (str.Length > index + segment.Length) {
                if (char.IsLetter(str[index + 1])) {
                    if (char.IsLower(str[index + 1]) == char.IsLower(str[index])) {
                        return false;
                    }
                }
                if (char.IsLetter(str[index + segment.Length])) {
                    if (char.IsLower(str[index + segment.Length])) {
                        return false;
                    }
                }
            }

            return true;
        }

        public static StringWriter CreateUtf8StringWriter() {
            return new CustomEncodingStringWriter(Encoding.UTF8);
        }

        public static StringWriter CreateStringWriter(Encoding encoding) {
            return new CustomEncodingStringWriter(encoding);
        }

        private sealed class CustomEncodingStringWriter : StringWriter {
            private readonly Encoding encoding;
            public CustomEncodingStringWriter(Encoding encoding) {
                this.encoding = encoding;
            }
            public override Encoding Encoding {
                get { return encoding; }
            }
        }

        public static string TrimWithEllipsis(this string s, int length) {
            if (s.Length > length && (length + 3) <= s.Length) {
                return s.Substring(0, length) + "...";
            }
            return s;
        }

        public static string GetStringWithoutBOM(this Encoding encoding, byte[] strBytes) {
            using (var sr = new StreamReader(new MemoryStream(strBytes), encoding)) {
                return sr.ReadToEnd();
            }
        }
        
        public static string Repeat(this string s, int n) {
            return new String(Enumerable.Range(0, n).SelectMany(x => s).ToArray());
        }

        private static int SurrogatePairCount(this string t, int endIndex) {
            // Looking for surrogate pairs.
            // We search only for the first code point value (between uD800 and uDBFF) and skip the following character.
            // This approach is faster than using the regex ([\uD800-\uDBFF].|.)
            int count = 0, i = 0;
            while (i < endIndex && (i + count < t.Length)) {
                if (char.IsHighSurrogate(t, i + count)) {
                    count++;
                }
                i++;
            }
            return count;
        }

        private static int Index(this string t, string s, int startIndex, StringComparison comparisonType, bool searchFromEnd) {
            try {
                // Using t.Length instead of LengthWithSC(t), which would be more precise, for performance sake.
                // The former will filter out most scenarios without penalizing the performance of the expected case.
                if (s.Length == 0 || startIndex < 0 || startIndex > t.Length) { // for consistency with sql Index (also vb behaviour when t=s=string.Empty)
                    return -1;
                }

                if (startIndex > 0) {
                    // Shift start index to its correct position.
                    startIndex += t.SurrogatePairCount(startIndex);
                }

                var index = searchFromEnd ? t.LastIndexOf(s, startIndex > 0 ? startIndex : t.Length, comparisonType) :
                    t.IndexOf(s, startIndex > 0 ? startIndex : 0, comparisonType);

                if (index < 0) {
                    return -1;
                }
                return LengthWithSC(t.Substring(0, index));
            } catch {
                return -1;
            }
        }

        public static int IndexOfWithSC(this string t, string s, int startIndex, StringComparison comparisonType) {
            return t.Index(s, startIndex, comparisonType, /*searchFromEnd*/ false);
        }

        public static int IndexOfWithSC(this string str, string value, StringComparison comparisonType) {
            return IndexOfWithSC(str, value, 0, comparisonType);
        }

        public static int LastIndexOfWithSC(this string str, string value, int startIndex, StringComparison comparisonType) {
            return str.Index(value, startIndex, comparisonType, /*searchFromEnd*/ true);
        }

        public static int LastIndexOfWithSC(this string str, string value, StringComparison comparisonType) {
            return LastIndexOfWithSC(str, value, str.LengthWithSC() - 1, comparisonType);
        }
        
        public static string SubstringWithSC(this string str, int startIndex, int length) {
            if (str.IsNullOrEmpty()) {
                return String.Empty;
            }
            StringInfo strInfo = new StringInfo(str);
            return strInfo.SubstringByTextElements(startIndex, length);
        }
        
        public static int LengthWithSC(this string str) {
            StringInfo strInfo = new StringInfo(str);
            return strInfo.LengthInTextElements;
        }

        public static string JoinText(string separator, params string[] parts) {
            return string.Join(separator, parts.Where(p => !p.IsEmpty()));
        }

        public static int IndexOf(this string str, Regex regex, int startIndex = 0) {
            var matches = regex.Matches(str ?? string.Empty, startIndex);
            if (matches.Count == 0) {
                return -1;
            } else {
                return matches[0].Index;
            }
        }
    }
}
