/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading;
using OutSystems.RuntimeCommon.Utils;

namespace OutSystems.RuntimeCommon {

    /// <summary>
    /// Class that contains the definitions for the OutSystems trace.
    /// </summary>
    public class OSTrace {

        private enum TraceCategory {
            ERROR,
            WARNING,
            Info,
            TimerStart,
            TimerEnd,
            Debug,
            Data,
        }

        private static class TraceCategoryExtensions {
            public static TraceLevel ToTraceLevel(TraceCategory category) {
                switch (category) {
                    case TraceCategory.ERROR:
                        return TraceLevel.Error;
                    case TraceCategory.WARNING:
                        return TraceLevel.Warning;
                    case TraceCategory.Info:
                        return TraceLevel.Info;
                    case TraceCategory.TimerStart:
                    case TraceCategory.TimerEnd:
                    case TraceCategory.Debug:
                        return TraceLevel.Verbose;
                    case TraceCategory.Data:
                        return  TraceLevel.Verbose;
                    default: // No category should fall here, but not throwing exception to avoid exception propagation in java
                        return TraceLevel.Verbose;
                }
            }
        }

        public class TimerObject : IDisposable {
            private string timerName;

            void IDisposable.Dispose() {
                End();
            }

            internal TimerObject(string timerName) {
                TimerStart(timerName);
                this.timerName = timerName;
            }

            public void End() {
                TimerEnd(timerName);
            }
        }

        internal static readonly TraceSwitch logLevel = new TraceSwitch("LogLevel", "Entire Application");
        public static TraceSwitch LogLevel { get { return logLevel; } }

        private static Dictionary<string, DateTime> ongoingTimers = new Dictionary<string, DateTime>();
        public static readonly int TimerFlushStartThreshold = 200;
        public static readonly TimeSpan TimerFlushTimeout = new TimeSpan(1, 0, 0); // 1 hour


        private static void insertIntoListeners() {
            if (!Debugger.IsAttached) {
                Trace.Listeners.Insert(0, new OSTraceListener());
            }
        }

        static OSTrace() {
            insertIntoListeners();
            Info("***** Starting log *****");
        }

        private static void FlushOldTimers() {
            Hashtable keysToKill = new Hashtable();
            string flushReport = "";

            lock (ongoingTimers) {
                foreach (var entry in ongoingTimers) {
                    if (DateTime.Now.Subtract(entry.Value) > TimerFlushTimeout) {
                        keysToKill.Add(entry.Key, null);
                    }
                }

                if (keysToKill.Count > 0) {
                    foreach (string key in keysToKill.Keys) {
                        flushReport += key + "\n";
                        ongoingTimers.Remove(key);
                    }

                    Debug("The following old Timers were flushed:\n{0}", flushReport);
                }
            }
        }
        
        static void writeLine(string message, TraceCategory category) {
            Trace.WriteLine(string.Format("{0} [{1}] [{2}] {3}",
                DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.ffff"),
                Thread.CurrentThread.ManagedThreadId,
                category.ToString(),
                message));
        }

        static void writeLine(string[] messages, TraceCategory category) {
            foreach (string message in messages) {
                writeLine(message, category);
            }
        }

        static void write(string message, TraceCategory category) {
            if (message.Contains("\n")) {
                message = message.Replace("\r\n", "\n");
                string[] lines = message.Split('\n');
                writeLine(lines, category);
            } else {
                writeLine(message, category);
            }
        }

        static string FormatException(Exception e) {
            string errorString = e.Message + "\n" + ExceptionUtils.GetExceptionStack(e);
            return errorString.Replace("\n", "\n\t");
        }
    
        private static void Log(TraceCategory level, string message) {
            write(message, level);
        }

        private static void Log(TraceCategory level, string message, params object[] args) {
            write(string.Format(message, args), level);
        }

        private static void Log(TraceCategory level, string message, Exception e) {
            write(message + '\n' + FormatException(e), level);
        }


        public static void Debug(string message) {
            if (logLevel.TraceVerbose) {
                Log(TraceCategory.Debug, message);
            }
        }

        public static void Debug(string format, params object[] args) {
            if (logLevel.TraceVerbose) {
                Log(TraceCategory.Debug, format, args);
            }
        }

        public static void Debug(string message, Exception e) {
            if (logLevel.TraceVerbose) {
                Log(TraceCategory.Debug, message, e);
            }
        }

        public static void Info(string message) {
            if (logLevel.TraceInfo) {
                Log(TraceCategory.Info, message);
            }
        }

        public static void Info(string format, params object[] args) {
            if (logLevel.TraceInfo) {
                Log(TraceCategory.Info, format, args);
            }
        }

        public static void Info(string message, Exception e) {
            if (logLevel.TraceInfo) {
                Log(TraceCategory.Info, message, e);
            }
        }

        public static void Warning(string message) {
            if (logLevel.TraceWarning) {
                Log(TraceCategory.WARNING, message);
            }
        }

        public static void Warning(string format, params object[] args) {
            if (logLevel.TraceWarning) {
                Log(TraceCategory.WARNING, format, args);
            }
        }

        public static void Warning(string message, Exception e) {
            if (logLevel.TraceWarning) {
                Log(TraceCategory.WARNING, message, e);
            }
        }

        public static void Error(string message) {
            if (logLevel.TraceError) {
                Log(TraceCategory.ERROR, message);
            }
        }

        public static void Error(string format, params object[] args) {
            if (logLevel.TraceError) {
                Log(TraceCategory.ERROR, format, args);
            }
        }

        public static void Error(string message, Exception e) {
            if (logLevel.TraceError) {
                Log(TraceCategory.ERROR, message, e);
            }
        }

        public static void Data(string data) {
            if (logLevel.TraceVerbose) {
                Log(TraceCategory.Data, data);
            }
        }

        public static void Data(string format, params object[] args) {
            if (logLevel.TraceVerbose) {
                Log(TraceCategory.Data, format, args);
            }
        }

        public static void TimerStart(string timerName) {
            if (TimersActivated) {
                lock (ongoingTimers) {
                    if (ongoingTimers.ContainsKey(timerName)) {
                        Debug("TimerStart '{0}' called again without first calling TimerEnd", timerName);
                    }
                    ongoingTimers[timerName] = DateTime.Now;
                    write(string.Format("Timer '{0}' started", timerName), TraceCategory.TimerStart);

                    // When a timer ends it gets deleted, so really OngoingTimers should only have ongoing entries in it
                    // Should there be a bug somewhere (Starts w/o Ends) we start throwing away old ones after they stack up
                    if (ongoingTimers.Count > TimerFlushStartThreshold) {
                        FlushOldTimers();
                    }
                }
            }
        }

        public static void TimerStart(string format, params object[] args) {
            if (TimersActivated) {
                TimerStart(string.Format(format, args));
            }
        }

        public static TimerObject Timer(string timerName) {
            return new TimerObject(timerName);
        }

        public static TimerObject Timer(string format, params object[] args) {
            return Timer(string.Format(format, args));
        }

        public static void TimerEnd(string timerName) {
            if (TimersActivated) {
                string message = string.Format("Timer '{0}' ended", timerName);

                lock (ongoingTimers) {
                    if (ongoingTimers.ContainsKey(timerName)) {
                        TimeSpan ts = DateTime.Now.Subtract(ongoingTimers[timerName]);
                        message += " (duration:" + ts.TotalMilliseconds + "ms -> ";
                        if (ts.Days > 0) {
                            message += "" + ts.Days + " days, ";
                        }
                        if (ts.Days > 0 || ts.Hours > 0) {
                            message += "" + ts.Hours + " hours, ";
                        }
                        if (ts.Days > 0 || ts.Hours > 0 || ts.Minutes > 0) {
                            message += "" + ts.Minutes + " minutes, ";
                        }
                        if (ts.Days > 0 || ts.Hours > 0 || ts.Minutes > 0 || ts.Seconds > 0) {
                            message += "" + ts.Seconds + " seconds and ";
                        }

                        message += "" + ts.Milliseconds + " miliseconds)";

                        ongoingTimers.Remove(timerName);
                    } else {
                        Debug("TimerEnd '{0}' called without first calling TimerStart", timerName);
                    }
                }
                write(message, TraceCategory.TimerEnd);
            }
        }

        public static void TimerEnd(string format, params object[] args) {
            if (TimersActivated) {
                TimerEnd(string.Format(format, args));
            }
        }

        public static TraceSwitch getRealLogLevel() {
            return logLevel;
        }

        public static void setRealLogLevel(TraceLevel newLevel) {
            logLevel.Level = newLevel;
        }

        /// <summary>
        /// Auxiliar listener that converts a Fail into an exception.
        /// </summary>
        private class OSTraceListener : DefaultTraceListener {
            public override void Fail(string message, string detailMessage) {
                //Do not call here base.fail (that will cause a popup on server side / leave a compiler process hanged - eternal concurrent publishing)
                throw new HEMessageException(new HEMessage("OSTraceFail", "Internal Error", string.Format("Internal trace failure: {0}.", message), 2063, "", HEMessageType.Error, true));
            }
        }

        public static bool TimersActivated { get { return logLevel.TraceVerbose; } }

        public static void SetLogLevel(TraceLevel level) {
            if (level == TraceLevel.Off) {
                Info("Trace Level turned off");
            }
            logLevel.Level = level;
            if (level != TraceLevel.Off) {
                Info("Trace Level set to " + level);
            }
        }
    }
}
