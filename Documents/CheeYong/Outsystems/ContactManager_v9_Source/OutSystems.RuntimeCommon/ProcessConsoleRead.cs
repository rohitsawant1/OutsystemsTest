/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Threading;

namespace OutSystems.RuntimeCommon {

    internal class ProcessConsoleRead {
        public static void ReadToEnd(Process p, int timeout, out string errString, out string outString, out bool aborted) {
            ReadToEnd(p, timeout, out errString, out outString, out aborted, /*streamEnconding*/null);
        }

        public static void ReadToEnd(Process p, int timeout, out string errString, out string outString, out bool aborted, Encoding streamEnconding) {
            aborted = false;
            
            using (StreamHandle outWrapper = new ReadToEndHandle(GetStandardOutputStreamReader(p, streamEnconding))) {
                using (StreamHandle errWrapper = new ReadToEndHandle(GetStandardErrorStreamReader(p, streamEnconding))) {

                    if (!ProcessEnded(p, timeout)) {
                        p.Kill();
                        aborted = true;
                    }
                
                    errString = errWrapper.Result;
                    outString = outWrapper.Result;
                }
            }
        }

        public static void ReadProgressive(Process p, out StreamHandle errHandler, out StreamHandle outHandler) {
            ReadProgressive(p, out errHandler, out outHandler, /*streamEnconding*/null);
        }

        public static void ReadProgressive(Process p, out StreamHandle errHandler, out StreamHandle outHandler, Encoding streamEnconding) {
            errHandler = new ReadProgressiveHandle(GetStandardErrorStreamReader(p, streamEnconding));
            outHandler = new ReadProgressiveHandle(GetStandardOutputStreamReader(p, streamEnconding));
        }


        private static StreamReader GetStandardOutputStreamReader(Process p, Encoding streamEnconding) {
            StreamReader currentReader = p.StandardOutput;
            if (streamEnconding != null) {
                if (currentReader.CurrentEncoding != streamEnconding) {
                    return new StreamReader(currentReader.BaseStream, streamEnconding);
                }
            }
            return currentReader;
        }
        
        private static StreamReader GetStandardErrorStreamReader(Process p, Encoding streamEnconding) {
            StreamReader currentReader = p.StandardError;
            if (streamEnconding != null) {
                if (currentReader.CurrentEncoding != streamEnconding) {
                    return new StreamReader(currentReader.BaseStream, streamEnconding);
                }
            }
            return currentReader;
        }
        
        private static StreamReader GetStreamReaderForEnconding(StreamReader currentReader, Encoding streamEnconding) {
            if (streamEnconding != null) {
                if (currentReader.CurrentEncoding != streamEnconding) {
                    return new StreamReader(currentReader.BaseStream, streamEnconding);
                }
            }
            return currentReader;
        }


        // copied from RuntimePlatformUtils, since I can't reference it here
        private static bool ProcessEnded(Process process, int maxTime) {
            return process.WaitForExit(maxTime);
        }


        private class ReadToEndHandle : StreamHandle {
            string result = null;

            public ReadToEndHandle(StreamReader stream) : base(stream) {
                Start();
            }

            public override string Result {
                get {
                    if (readThread == null) {
                        return null; // No reader started?
                    } else {
                        readThread.Join();
                        return result;
                    }
                }
            }

            protected override void Reader() {
                try {
                    result = Stream.ReadToEnd();
                } catch (Exception ex) { // can't let any exceptions kill the thread or the program will crash
                    result = ex.ToString();
                }
            }
        }
        
        public class ReadProgressiveHandle : StreamHandle {
            private const int bufferSize = 1024;
            private StringBuilder progressiveStringBuilder;
            
            public ReadProgressiveHandle(StreamReader stream) : base(stream) {
                progressiveStringBuilder = new StringBuilder(bufferSize);
                Start();
            }
            public override string Result {
                get {
                    Thread.Sleep(0); // Yield to make sure we give the reader thread a chance to read
                    lock (this) {
                        return progressiveStringBuilder.ToString();
                    }
                }
            }

            public override void Clear() {
                lock (this) {
                    progressiveStringBuilder = new StringBuilder(bufferSize);
                }
            }
            
            protected override void Reader() {
                var buffer = new char[bufferSize];
                try {
                    while (true) {
                        int readCount = Stream.Read(buffer, 0, buffer.Length);
                        if (readCount <= 0) {
                            return;
                        }
                        lock (this) {
                            progressiveStringBuilder.Append(buffer, 0, readCount);
                        }
                    }
                } catch (Exception ex) { // can't let any exceptions kill the thread or the program will crash
                    lock (this) {
                        progressiveStringBuilder.Append(ex.ToString());
                    }
                }
            }
        }
    }

    public abstract class StreamHandle : IDisposable {
        protected Thread readThread;

        private StreamReader stream;
        protected StreamReader Stream {
            get { return stream; }
        }

        protected StreamHandle(StreamReader stream) {
            this.stream = stream;
        }

        public abstract string Result { get; }

        public virtual void Clear() {
            throw new NotSupportedException("This type of reader does not support Clear().");
        }

        protected abstract void Reader();
        protected void Start() {
            if (readThread == null) {
                readThread = new Thread(Reader);
                readThread.Priority = ThreadPriority.AboveNormal;
                readThread.Start();
            }
        }

        #region IDisposable Members

        public void Dispose() {
            try {
                if (readThread != null && readThread.IsAlive) {
                    readThread.Abort();
                }
            } catch { }
            try {
                if (stream != null) {
                    stream.Dispose();
                }
            } catch { }
        }

        #endregion
    }

}