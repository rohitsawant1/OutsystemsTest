/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections;
using System.Collections.Generic;
using OutSystems.RuntimeCommon;

#if MODEL_DEFINITION
namespace CodeGeneration {
#endif

public class OrderRespectingDictionary<KeyType, ValueType> : IDictionary<KeyType, ValueType> {

    private IEqualityComparer<KeyType> comparer;
    private Dictionary<KeyType, ValueType> dictionary;
    private List<KeyType> keysList;

    public OrderRespectingDictionary() {
        Clear();
    }

    public OrderRespectingDictionary(IEqualityComparer<KeyType> comparer) {
        this.comparer = comparer;
        Clear();
    }

    private void AddInternal(KeyType key, ValueType value) {
        dictionary.Add(key, value);
        keysList.Add(key);
    }

    public void Add(KeyType key, ValueType value) {
        AddInternal(key, value);
    }

    public void Add(KeyValuePair<KeyType, ValueType> item) {
        AddInternal(item.Key, item.Value);
    }

    public bool Remove(KeyType key) {
        bool removed = dictionary.Remove(key);
        keysList.Remove(key);
        return removed;
    }

    public bool Remove(KeyValuePair<KeyType, ValueType> item) {
        return Contains(item) && Remove(item.Key);
    }

    public void Clear() {
        if (comparer != null) {
            dictionary = new Dictionary<KeyType, ValueType>(comparer);
        } else {
            dictionary = new Dictionary<KeyType, ValueType>();
        }
        keysList = new List<KeyType>();
    }

    public bool TryGetValue(KeyType key, out ValueType value) {
        return dictionary.TryGetValue(key, out value);
    }

    public ICollection<KeyType> Keys {
        get { return keysList.AsReadOnly(); }
    }

    private IEnumerable<ValueType> ValuesEnumerable {
        get {
            foreach (KeyType key in keysList) {
                yield return dictionary[key];
            }
        }
    }

    public ICollection<ValueType> Values {
        get {
            return new ValuesCollection(this);
        }
    }

    public int Count {
        get {
            return dictionary.Count;
        }
    }

    public ValueType this[KeyType index] {
        get { return dictionary[index]; }
        set {
            if (dictionary.ContainsKey(index)) {
                dictionary[index] = value;
            } else {
                AddInternal(index, value);
            }
        }
    }

    public bool ContainsKey(KeyType key) {
        return dictionary.ContainsKey(key);
    }

    public bool Contains(KeyValuePair<KeyType, ValueType> item) {
        ValueType value;
        if (TryGetValue(item.Key, out value)) {
            return object.Equals(value, item.Value);
        } else {
            return false;
        }
    }

    public bool IsEmpty() {
        return dictionary.Count == 0;
    }

    public IEnumerable<KeyValuePair<KeyType, ValueType>> Members {
        get {
            for (int i = 0; i < keysList.Count; i++) {
                KeyType key = keysList[i];
                yield return new KeyValuePair<KeyType, ValueType>(key, dictionary[key]);
            }
        }
    }

    public void CopyTo(KeyValuePair<KeyType, ValueType>[] array, int arrayIndex) {
        dictionary.CopyTo(array, arrayIndex);
    }

    public bool IsReadOnly {
        get { return false; }
    }

    public IEnumerator<KeyValuePair<KeyType, ValueType>> GetEnumerator() {
        return Members.GetEnumerator();
    }

    IEnumerator System.Collections.IEnumerable.GetEnumerator() {
        return Members.GetEnumerator();
    }

    private sealed class ValuesCollection : ICollection<ValueType> {

        private readonly OrderRespectingDictionary<KeyType, ValueType> dict;

        public ValuesCollection(OrderRespectingDictionary<KeyType, ValueType> dict) {
            this.dict = dict;
        }

        public void Add(ValueType item) {
            throw new NotSupportedException();
        }

        public bool Remove(ValueType item) {
            throw new NotSupportedException();
        }

        public void Clear() {
            dict.Clear();
        }

        public bool Contains(ValueType item) {
            foreach (ValueType v in dict.ValuesEnumerable) {
                if (object.Equals(v, item)) {
                    return true;
                }
            }
            return false;
        }

        public void CopyTo(ValueType[] array, int arrayIndex) {
            dict.dictionary.Values.CopyTo(array, arrayIndex);
        }

        public int Count {
            get { return dict.Count; }
        }

        public bool IsReadOnly {
            get { return true; }
        }

        public IEnumerator<ValueType> GetEnumerator() {
            return dict.ValuesEnumerable.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator() {
            return dict.ValuesEnumerable.GetEnumerator();
        }
    }
}

#if MODEL_DEFINITION
}
#endif