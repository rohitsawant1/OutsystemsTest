/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.AccessControl;
using System.Security.Principal;
using System.Text.RegularExpressions;

namespace OutSystems.RuntimeCommon {

    public static class FileSystemUtils {

        public const int ErrorCode_DirectoryNotEmpty = -2147024751;

        public static char PathSeparatorChar {
            get { return Path.DirectorySeparatorChar; }
        }

        public static string PathSeparator {
            get { return PathSeparatorChar.ToString(); }
        }

        public static List<string> GetAllFiles(string directoryPath, bool recursive) {
            var filesPath = new List<string>();
            if (!Directory.Exists(directoryPath)) {
                return filesPath;
            }
            // Adds files...
            filesPath.AddRange(Directory.GetFiles(directoryPath));
            // Adds files in sub directories...
            if (recursive) {
                foreach (string subDirectoryPath in Directory.GetDirectories(directoryPath)) {
                    filesPath.AddRange(GetAllFiles(subDirectoryPath, recursive));
                }
            }
            return filesPath;
        }

        public static IEnumerable<string> GetAllFilesWithExtension(string directoryPath, string extension, bool recursive) {
            var extensionsList = new ArrayList() { extension };
            var filesPath = GetAllFiles(directoryPath, recursive)
                .Where(filePath => FilePathHasExtension(filePath, extensionsList));
            
            return filesPath;
        }

        public static bool FilePathHasExtension(string filePath, ArrayList extensionsList) {
            string fileExtension = Path.GetExtension(filePath);
            foreach (string extension in extensionsList) {
                if (extension == fileExtension) {
                    return true;
                }
            }
            return false;
        }

        public static bool FilePathHasFile(string filePath, ArrayList filesList) {
            string fileName = Path.GetFileName(filePath);
            foreach (string file in filesList) {
                if (file == fileName) {
                    return true;
                }
            }
            return false;
        }

        public static string GetClashedFileName(string fileName) {
            var filenameWithoutExtension = Path.ChangeExtension(fileName, null);
            var extension = Path.GetExtension(fileName);
            var fullname = filenameWithoutExtension + extension;
            int i = 0;
            while (File.Exists(fullname)) {
                fullname = filenameWithoutExtension + "(" + ++i + ")" + extension;
            }
            return fullname;
        }

        public static string GetTemporaryDirectory() {
            string directory = Path.GetTempPath();
            if (!directory.EndsWith(PathSeparator) && !directory.EndsWith("\\") && !directory.EndsWith("/")) {
                directory += PathSeparator;
            }
            return directory;
        }

        public static string CreateTemporaryDirectory() {
            // source: https://stackoverflow.com/a/278457
            string tempDirectory = Path.Combine(GetTemporaryDirectory(), Path.GetRandomFileName());
            Directory.CreateDirectory(tempDirectory);
            return tempDirectory;
        }

        public static string GetTemporaryFile() {
            return GetTemporaryFile("tmp");
        }

        public static string GetTemporaryFile(string extension) {
            string file = string.Empty;
            do {
                file = GetTemporaryDirectory() + Guid.NewGuid() + "." + extension;
            } while (File.Exists(file));
            File.Create(file).Close();
            return file;
        }

        private static void SetPermissionsToEveryone(string path, bool directory) {
            var sid = new SecurityIdentifier(WellKnownSidType.WorldSid, null);
            var account = sid.Translate(typeof(NTAccount)) as NTAccount;
            var strEveryoneAccount = account.ToString();

            FileSystemSecurity fileSystemSecurity = null;
            if (directory) {
                fileSystemSecurity = Directory.GetAccessControl(path);
            } else {
                fileSystemSecurity = File.GetAccessControl(path);
            }
            fileSystemSecurity.AddAccessRule(new FileSystemAccessRule(strEveryoneAccount, FileSystemRights.FullControl, AccessControlType.Allow));
            if (directory) {
                Directory.SetAccessControl(path, (DirectorySecurity)fileSystemSecurity);
            } else {
                File.SetAccessControl(path, (FileSecurity)fileSystemSecurity);
            }
        }

        public static void SetFilePermissionsToEveryone(string path) {
            SetPermissionsToEveryone(path, /*directory*/false);
        }

        public static void SetDirectoryPermissionsToEveryone(string path) {
            SetPermissionsToEveryone(path, /*directory*/true);
        }

        public static DirectoryInfo GetDirectoryInfo(string path, bool createIfDoesntExist) {
            var dirInfo = new DirectoryInfo(path);
            if (!dirInfo.Exists) {
                dirInfo.Create();
                SetDirectoryPermissionsToEveryone(path);
            }
            return dirInfo;
        }

        public static string BuildPath(params string[] folders) {
            string result = string.Empty;
            foreach (var folder in folders) {
                if (!folder.IsEmpty()) {
                    result = Path.Combine(result, folder);
                }
            }
            return result;
        }

        public static void WriteToFile(string filename, string content) {
            using (var writer = new StreamWriter(filename)) {
                writer.Write(content);
                writer.Flush();
            }
        }
    }
}
