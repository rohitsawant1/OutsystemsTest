/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Reflection;

namespace OutSystems.RuntimeCommon.Extensibility.Plugins {

    public delegate void PluginProviderLogErrorDelegate(Exception ex, string error);

    public interface IPluginProvider {
        void LoadPlugins(PluginProviderLogErrorDelegate logError);
    }

    public abstract class AbstractPluginProvider<KeyType, PluginType>: IPluginProvider {
        protected const string PluginsFolderName = "plugins";


        protected abstract IEnumerable<DirectoryInfo> PluginDirectories { get; }

        /// <summary>
        /// Auxiliary method used to calculate the default directories for a provider.
        /// It covers both scenarios where the assembly is inside a /plugins/subFolderName/, same directory or late load directly.
        /// It's not recommended to use this if the PluginsNameMask property is not redefined to a more restrictive pattern. 
        /// </summary>
        /// <typeparam name="ProviderClass">IPluginProvider class implementation trying to lookup for directories.</typeparam>
        /// <typeparam name="isRuntimePlugin">true if the plugin is to be used in applications runtime. false to only lookup /plugin/* folders.</typeparam>
        /// <param name="subFolderName"></param>
        /// <returns></returns>
        protected IEnumerable<DirectoryInfo> DefaultPluginDirectories<ProviderClass>(string subFolderName, bool isRuntimePlugin = false)
            where ProviderClass : IPluginProvider {

            var currentDir = new DirectoryInfo(Path.GetDirectoryName(new Uri(typeof(ProviderClass).Assembly.CodeBase).LocalPath));

            var pluginsDir = new DirectoryInfo(Path.Combine(currentDir.FullName, PluginsFolderName, subFolderName));
            if (pluginsDir.Exists) { // if the plugins path exists, only use that
                yield return pluginsDir;
            } else if (isRuntimePlugin) {
                yield return currentDir;
            }
        }

        protected virtual string PluginsNameMask {
            get {
                return "*.dll";
            }
        }

        protected ConcurrentDictionary<KeyType, PluginType> implementations = new ConcurrentDictionary<KeyType, PluginType>();

        public IEnumerable<PluginType> Implementations {
            get { return implementations.Values; }
        }

        protected bool RegisterImplementation(PluginType obj) {
            if (IsEnabled(obj)) {
                implementations.TryAdd(GetKey(obj), obj);
                return true;
            }
            return false;
        }

        protected virtual PluginType OnMissingPluginImplementation(KeyType providerKey) {
            throw new InvalidOperationException("No provider registered for key " + providerKey);
        }

        public PluginType GetImplementation(KeyType providerKey) {
            return GetImplementation(providerKey, OnMissingPluginImplementation);
        }

        public PluginType GetImplementation(KeyType providerKey, Func<KeyType, PluginType> OnMissingPluginImplementationOverride) {
            PluginType impl;
            if (!implementations.TryGetValue(providerKey, out impl)) {
                return OnMissingPluginImplementationOverride(providerKey);
            }
            return impl;
        }

        protected PluginType GetInstance(Type type) {
            return (PluginType)Activator.CreateInstance(type);
        }

        protected abstract KeyType GetKey(PluginType obj);
        protected virtual bool IsEnabled(PluginType obj) {
            return true;
        }

        protected virtual IEnumerable<PluginType> DiscoverTypesInAssembly(Assembly assembly) {
            var discoveredTypes = new List<PluginType>();
            foreach (var type in assembly.GetTypes()) {
                var instance = ScanType(type);
                if (!object.Equals(instance, default(PluginType))) {
                    discoveredTypes.Add(instance);
                }
            }
            return discoveredTypes;
        }

        protected virtual bool ScanFilter(Type type) {
            return type.BaseType != null
                   && !type.IsGenericTypeDefinition
                   && !type.IsAbstract
                   && typeof(PluginType).IsAssignableFrom(type);
        }

        private PluginType ScanType(Type type) {
            if (ScanFilter(type)) {
                var implementation = GetInstance(type);
                if (RegisterImplementation(implementation)) {
                    return implementation;
                }
            }
            return default(PluginType);
        }

        public virtual void LoadPlugins(PluginProviderLogErrorDelegate logError) {

            var toScan = new List<Assembly>();

            foreach (var PluginsDirectory in PluginDirectories) {

                if (PluginsDirectory.Exists) {
                    foreach (var file in PluginsDirectory.GetFiles(PluginsNameMask)) {
                        String name = Path.GetFileNameWithoutExtension(file.Name);
                        try {
                            toScan.Add(Assembly.LoadFrom(file.FullName));
                        } catch (Exception ex) {
                            logError(ex, "Error loading plugin :" + name);
                        }
                    }
                }
            }

            foreach (var asm in toScan) {
                try {
                    var typesDiscovered = DiscoverTypesInAssembly(asm);
                    OnAfterTypesDiscoveredInAssembly(typesDiscovered);
                } catch (ReflectionTypeLoadException rtle) {
                    rtle.LoaderExceptions.Apply(e => logError(e, "Error loading types from plugin:" + asm.GetName()));
                } catch (Exception e) {
                    logError(e, "Error loading types from plugin:" + asm.GetName());
                }
            }

            AppDomain.CurrentDomain.AssemblyResolve += new ResolveEventHandler(CurrentDomain_AssemblyResolve);
        }


        // this finds assemblies that were already loaded
        // this is just so Visual Studio can find the assemblies
        private static Assembly CurrentDomain_AssemblyResolve(object sender, ResolveEventArgs args) {
            foreach (Assembly anAssembly in AppDomain.CurrentDomain.GetAssemblies()) {
                if (anAssembly.FullName == args.Name) {
                    return anAssembly;
                }
            }
            return null;
        }

        protected virtual void OnAfterTypesDiscoveredInAssembly(IEnumerable<PluginType> typesDiscovered) {

        }
    }
}

