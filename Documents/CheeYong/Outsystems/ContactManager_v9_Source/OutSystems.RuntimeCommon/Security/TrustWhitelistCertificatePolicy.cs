/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Security;
using System.Security.Cryptography.X509Certificates;

namespace OutSystems.RuntimeCommon.Security {
    
    public static class TrustWhitelistCertificatePolicy {
        private static readonly Dictionary<string, RemoteCertificateValidationCallback> whitelist = 
            new Dictionary<string, RemoteCertificateValidationCallback>();

        private static readonly HashSet<string> invalidHosts = new HashSet<string>();

        static TrustWhitelistCertificatePolicy() {
            ServicePointManager.ServerCertificateValidationCallback += ValidateServerCertificate;
        }

        public static bool HostWasValid(string hostName) {
            lock (invalidHosts) {
                return !invalidHosts.Contains(hostName.ToLowerInvariant());
            }
        }

        public static void RemoveAddress(string partialAddr) {
            lock (whitelist) {
                whitelist.Remove(partialAddr);
            }
        }

        /// <summary>
        /// Adds an address to the whitelist without extra validations.
        /// 
        /// It will match requests that start with the partialAddr string.
        /// </summary>
        /// <returns>true if it was added to the whitelist, false if was already present</returns>
        public static bool AddAddress(string partialAddr) {
            lock (whitelist) {
                if (whitelist.ContainsKey(partialAddr)) {
                    return false;
                }

                whitelist[partialAddr] = AcceptCallback;
            }

            return true;
        }
        
        private static bool AcceptCallback(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors) {
            return true;
        }

        /// <summary>
        /// Adds an address to the whitelist without an extra validation.
        /// 
        /// It will match requests that start with the partialAddr string.
        /// </summary>
        /// <returns>true if it was added to the whitelist, false if was already present with the same callback</returns>
        public static bool AddAddress(string partialAddr, RemoteCertificateValidationCallback extraCallback) {
            RemoteCertificateValidationCallback currentCallback;

            lock (whitelist) {
                if (whitelist.TryGetValue(partialAddr, out currentCallback)) {
                    if (currentCallback == extraCallback) {
                        return false;
                    }
                }
            
                whitelist[partialAddr] = AcceptCallback;
            }

            return true;
        }

        private static bool ValidateServerCertificate(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors) {
            if (sslPolicyErrors == SslPolicyErrors.None) {
                return true;
            }

            WebRequest req = sender as WebRequest;
            if (req != null) {
                Uri requestUri = req.RequestUri;

                lock (invalidHosts) {
                    invalidHosts.Add(requestUri.Authority.ToLowerInvariant());
                }

                string reqUri = requestUri.OriginalString;
                string reqAbsoluteUri = requestUri.AbsoluteUri;

                lock (whitelist) {
                    foreach (var kvp in whitelist) {
                        if (reqUri.StartsWith(kvp.Key) || reqAbsoluteUri.StartsWith(kvp.Key)) {
                            return kvp.Value(sender, certificate, chain, sslPolicyErrors);
                        }
                    }
                }
            }

            return false;
        }
    }
}
