/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections.Generic;
using OutSystems.HubEdition.RuntimePlatform.Internal;
using OutSystems.RuntimeCommon;
using OutSystems.RuntimeCommon.Caching;

namespace OutSystems.HubEdition.RuntimePlatform {
    internal static class AppCache {
        private static Dictionary<string, object> allCaches = new Dictionary<string, object>();

        private static bool reentrantCall = false;

        private static void InsertESpaceCache(string cacheName, int eSpaceId) {
            RuntimeCache.Instance.Listen(
                            new CacheKey(cacheName),
                            new EspaceTenantDependency(eSpaceId, 0),
                            () => CacheRemovedCallback(cacheName));
        }

        private static void InsertESpaceCache(string cacheName, AppInfo appInfo) {
            InsertESpaceCache(cacheName, appInfo.eSpaceId);
        }

        private static void InsertTenantCache(string cacheName, Pair<int, int> eSpaceTenantIdPair) {
            RuntimeCache.Instance.Listen(
                            new CacheKey(cacheName),
                            new EspaceTenantDependency(eSpaceTenantIdPair.First, eSpaceTenantIdPair.Second),
                            () => CacheRemovedCallback(cacheName));
        }

        private static void CacheRemovedCallback(string key) {
            lock (allCaches) {
                allCaches.Remove(key);
            }
        }

        private static ValueType InnerGetCachedValue<KeyType, ValueType, ExtraIdType>(KeyType key, string cacheName, Func<KeyType, ValueType> Getter, Action<string, ExtraIdType> CacheInsertMethod, ExtraIdType cacheExtraId) {
            cacheName += cacheExtraId.ToString();
            object cache;
            lock (allCaches) {
                if (reentrantCall) {
                    throw new InvalidOperationException("Reentrant call in AppCache for key: " + cacheName);
                }

                if (!allCaches.TryGetValue(cacheName, out cache)) {
                    try {
                        reentrantCall = true;
                        allCaches.Add(cacheName, cache = new Dictionary<KeyType, ValueType>());
                    } catch (ArgumentException e) {
                        throw new ArgumentException("DuplicateKey was: " + cacheName + ", map contents was: " + allCaches.ToString() + ", TryGetValue was: " + allCaches.TryGetValue(cacheName, out cache), e);
                    } finally {
                        reentrantCall = false;
                    }
                    CacheInsertMethod(cacheName, cacheExtraId);
                }
            }

            ValueType result;
            lock (cache) {
                Dictionary<KeyType, ValueType> dicCache = (Dictionary<KeyType, ValueType>)cache;
                if (!dicCache.TryGetValue(key, out result)) {
                    dicCache.Add(key, result = Getter(key));
                }
                return result;
            }
        }   
   
        /// <summary>
        /// Gets a cached value that is calculated with a specific key and it's invalidation is bound to the eSpace.
        /// </summary>
        public static ValueType GetESpaceCachedValue<KeyType, ValueType>(KeyType key, string cacheName, int eSpaceId, Func<KeyType, ValueType> Getter) {
            return InnerGetCachedValue(key, cacheName, Getter, InsertESpaceCache, eSpaceId);
        }
        
        /// <summary>
        /// Gets a cached value that is calculated with a specific key and it's invalidation is bound to the tenant.
        /// </summary>
        public static ValueType GetTenantCachedValue<KeyType, ValueType>(KeyType key, string cacheName, int eSpaceId, int tenantId, Func<KeyType, ValueType> Getter) {
            return InnerGetCachedValue(key, cacheName, Getter, InsertTenantCache, Pair.Create(eSpaceId, tenantId));
        }

        private static ValueType InnerGetCachedValue<ValueType, ExtraIdType>(string cacheName, Func<ValueType> Getter, Action<string, ExtraIdType> CacheInsertMethod, ExtraIdType cacheExtraId) {
            object cachedValue;
            lock (allCaches) {
                if (reentrantCall) {
                    throw new InvalidOperationException("Reentrant call in AppCache for key: " + cacheName);
                }

                if (!allCaches.TryGetValue(cacheName, out cachedValue)) {
                    try {
                        reentrantCall = true;
                        allCaches.Add(cacheName, cachedValue = Getter());
                    } catch (ArgumentException e) {
                        throw new ArgumentException("DuplicateKey was: " + cacheName + ", map contents was: " + allCaches.ToString() + ", TryGetValue was: " + allCaches.TryGetValue(cacheName, out cachedValue), e);
                    } finally {
                        reentrantCall = false;
                    }
                    CacheInsertMethod(cacheName, cacheExtraId);
                }
            }

            return (ValueType)cachedValue;
        }
        
        /// <summary>
        /// Gets a cached value that it's invalidation is bound to the eSpace.
        /// </summary>
        public static ValueType GetESpaceCachedValue<ValueType>(string cacheName, int eSpaceId, Func<ValueType> Getter) {
            return InnerGetCachedValue(cacheName, Getter, InsertESpaceCache, eSpaceId);
        }
        
        /// <summary>
        /// Gets a cached value that it's invalidation is bound to the tenant.
        /// </summary>
        public static ValueType GetTenantCachedValue<ValueType>(string cacheName, int eSpaceId, int tenantId, Func<ValueType> Getter) {
            return InnerGetCachedValue(cacheName, Getter, InsertTenantCache, Pair.Create(eSpaceId, tenantId));
        }

        private static ValueType InnerGetCachedValue<ValueType, ExtraIdType>(string cacheName, Func<ExtraIdType, ValueType> Getter, Action<string, ExtraIdType> CacheInsertMethod, ExtraIdType cacheExtraId) {
            object cachedValue;
            lock (allCaches) {
                if (reentrantCall) {
                    throw new InvalidOperationException("Reentrant call in AppCache for key: " + cacheName);
                }

                if (!allCaches.TryGetValue(cacheName, out cachedValue)) {
                    try {
                        reentrantCall = true;
                        allCaches.Add(cacheName, cachedValue = Getter(cacheExtraId));
                    } catch (ArgumentException e) {
                        throw new ArgumentException("DuplicateKey was: " + cacheName + ", map contents was: " + allCaches.ToString() + ", TryGetValue was: " + allCaches.TryGetValue(cacheName, out cachedValue), e);
                    } finally {
                        reentrantCall = false;
                    }
                    CacheInsertMethod(cacheName, cacheExtraId);
                }
            }

            return (ValueType)cachedValue;
        }

        /// <summary>
        /// Gets a cached value that depends on the eSpaceId, and it's invalidation is also bound to the eSpace.
        /// </summary>
        public static ValueType GetESpaceCachedValue<ValueType>(string cacheName, int eSpaceId, Func<int, ValueType> Getter) {
            return InnerGetCachedValue(cacheName, Getter, InsertESpaceCache, eSpaceId);
        }

        /// <summary>
        /// Gets a cached value that depends on the eSpaceId, and it's invalidation is also bound to the eSpace.
        /// </summary>
        public static ValueType GetESpaceCachedValue<ValueType>(string cacheName, AppInfo appInfo, Func<AppInfo, ValueType> Getter) {
            return InnerGetCachedValue(cacheName, Getter, InsertESpaceCache, appInfo);
        }

        /// <summary>
        /// Gets a cached value that depends on the tenantId, and it's invalidation is also bound to the tenant.
        /// </summary>
        public static ValueType GetTenantCachedValue<ValueType>(string cacheName, int eSpaceId, int tenantId, Func<Pair<int, int>, ValueType> Getter) {
            return InnerGetCachedValue(cacheName, Getter, InsertTenantCache, Pair.Create(eSpaceId, tenantId));
        }
    }
}
