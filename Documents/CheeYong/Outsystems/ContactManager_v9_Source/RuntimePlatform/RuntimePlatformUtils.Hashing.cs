/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using OutSystems.RuntimeCommon;
using OutSystems.RuntimeCommon.Cryptography;
using OutSystems.RuntimeCommon.Cryptography.VersionedAlgorithms;

namespace OutSystems.HubEdition.RuntimePlatform {
    // This class needs to be outside of RuntimePlatformUtils because of the Sharptranslator
    public abstract class SHA512Hash<THash>: SingletonVersionedCryptographyAlgorithm<THash>, RuntimePlatformUtils.Hashing.IHash 
            where THash: SHA512Hash<THash>, new() {

        bool RuntimePlatformUtils.Hashing.IHash.CheckHash(string password, string hash) {
            return HashSHA512Helper.ValidateHashWithSalt(password, hash);
        }
        
        protected abstract int SaltSizeInBytes { get; }

        protected override string InnerApplyAlgorithm(string password) {
            return HashSHA512Helper.HashWithSalt(SaltSizeInBytes, password);
        }
    }
            
    partial class RuntimePlatformUtils {
        public static class Hashing {
            public interface IHash: IVersionedCryptographyAlgorithm {
                bool CheckHash(string password, string hash);
            }

            public class MD5Hash: SingletonVersionedCryptographyAlgorithm<MD5Hash>, IHash {
                bool IHash.CheckHash(string password, string hash) {
                    if (RuntimePlatformSettings.Authentication.ForceSecureAlgorithmsInAuthentication.GetValue()) {
                        return false;   // Since we are forcing the use of the secure algorithm, the MD5 never accepts any saved hash...
                    }

                    return InnerApplyAlgorithm(password) == hash;
                }
                
                protected override string InnerApplyAlgorithm(string password) {
                    return CryptMethods.MD5HashWithPrivateSalt(password);
                }
            }

            public class SHA512HashWithSalt32: SHA512Hash<SHA512HashWithSalt32> {
                protected override int SaltSizeInBytes { get { return 32; } }
            }

            /// <summary>
            /// List of hashes by order of security. A more secure hash should always be added to the end of this list.
            /// </summary>
            private static readonly VersionedCryptographyAlgorithms<IHash> hashes = new VersionedCryptographyAlgorithms<IHash> (
                MD5Hash.Instance, 
                SHA512HashWithSalt32.Instance
            );
            
            /// <summary>
            /// Creates a salted password hash using a strong one-way hashing algorithm.
            /// </summary>
            /// <param name="password">The password being hashed</param>
            /// <returns>The hash of the given password</returns>
            public static string GeneratePasswordHashWithBestAlgorithm(string password) {
                return hashes.ApplyBestAlgorithm(password);
            }

            /// <summary>
            /// Creates a salted password hash using a strong one-way hashing algorithm.
            /// </summary>
            /// <param name="password">The password being hashed</param>
            /// <param name="hashAlgorithm">Algorithm to use to generate the hash</param>
            /// <returns>The hash of the given password</returns>
            public static string GeneratePasswordHashWithAlgorithm(string password, IHash hashAlgorithm) {
                // The MD5 hash don't add any separators to keep the same behavior as before... So simply invoke its ApplyAlgorithm method...
                return (hashAlgorithm == MD5Hash.Instance)? hashAlgorithm.ApplyAlgorithm(password): 
                    hashes.ApplySpecificAlgorithm(password, hashAlgorithm);
            }

            /// <summary>
            /// Creates a salted password hash using a strong one-way hashing algorithm.
            /// </summary>
            /// <param name="password">The password being hashed</param>
            /// <param name="hashAlgorithmIndex">Index of the algorithm to use to generate the hash</param>
            /// <returns>The hash of the given password</returns>
            public static string GeneratePasswordHashWithAlgorithm(string password, int hashAlgorithmIndex) {
                return (hashAlgorithmIndex == -1) ? GeneratePasswordHashWithBestAlgorithm(password) :
                    hashes.ApplySpecificAlgorithm(password, hashAlgorithmIndex);
            }
            
            /// <summary>
            /// Checks if the given password corresponds to the given hash.
            /// </summary>
            /// <param name="password">The password being validated.</param>
            /// <param name="hash">The hash the password corresponds to.</param>
            /// <return>True if the password is valid for the given hash.</return>
            public static bool ValidatePasswordAgainstHash(string password, string hash) {
                return hashes.ProcessAlgorithmResult(hash, (algorithm, hashToValidate) => algorithm.CheckHash(password, hashToValidate));
            }

            /// <summary>
            /// Checks if the given hash was generated using the given algorithm.
            /// </summary>
            /// <param name="passwordHash">The hash being validated.</param>
            /// <param name="algorithmToCheck">The algorithm to check</param>
            /// <return>True if the hash was generated using the given hash algorithm.</return>
            public static bool IsPasswordHashGeneratedWithAlgorithm(string passwordHash, IHash algorithmToCheck) {
                return hashes.ProcessAlgorithmResult(passwordHash, (algorithm, _) => algorithm == algorithmToCheck);
            }

            public static int GetAlgorithmIndexForPasswordHash(string passwordHash) {
                return hashes.GetAlgorithmIndexForAlgorithmResult(passwordHash);
            }

            public static int BestAlgorithmIndex { get { return hashes.BestAlgorithmIndex; } }
        }
    }
}
