/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using OutSystems.HubEdition.RuntimePlatform.Log;
using OutSystems.Internal.Db;

namespace OutSystems.HubEdition.RuntimePlatform {

    public class LoginExtendedAction {

        public static void AutoLogin(HeContext heContext) {
            if (heContext == null || heContext.AppInfo == null || heContext.AppInfo.IsMobileRuntime) {
                return; // This method should never be called for Mobile Runtime modules as those do not use the same cookie mechanims.
            }

            if (heContext.Session.UserId == 0) {

                String persistentLoginValue = CookieActions.GetPersistentLoginValue(heContext);
                if (!String.IsNullOrEmpty(persistentLoginValue)) {

                    using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {

                        int userId = 0;
                        int tenantId = 0;
                        int existingPersistentLoginId = 0;
                        DateTime expirationDateTime;

                        CookieActions.GetPersistentLoginInfo(heContext, trans, persistentLoginValue, out userId, out tenantId, out existingPersistentLoginId, out expirationDateTime, "AutoLogin");

                        if (userId == 0 || existingPersistentLoginId == 0) {
                            CookieActions.DeletePersistentLoginCookie(heContext);
                        } else {

                            string username;
                            string hashInDb;
                            if (!DBRuntimePlatform.Instance.GetUserInfoForLogin(trans, tenantId, userId, /*fetchDbHash*/false, out username, out hashInDb, "AutoLogin")) {
                                return;
                            }

                            heContext.Session.TenantId = tenantId;
                            heContext.Session.SetUser(userId, username);
                            heContext.AppInfo.InjectionCache.RunCallbacks(heContext.AppInfo, heContext.Session, Callbacks.CallbackEvent.Login);
                            
                            if (!heContext.IsReadOnlySessionRequest) {
                                // Add the generic session fixation protection cookie
                                CookieActions.AddSessionFixationProtectionCookie(heContext);

                                // Refresh Persistent Login cookie on successful Auto Login - this avoids "session fixation"-like problems for the Persistent Login cookie!
                                CookieActions.RefreshPersistentLoginCookie(heContext, existingPersistentLoginId, expirationDateTime, "AutoLogin");
                            }

                            if (RuntimePlatformSettings.Authentication.UpdateUserLastLogin.GetValue()) {
                                // update login date
                                // #798465, #1006905 Use a committable transaction to update the last login to avoid locking concurrent logins
                                try {
                                    using (Transaction committableTrans = DatabaseAccess.ForRuntimeDatabase.GetCommitableTransaction()) {
                                        if (DBRuntimePlatform.Instance.TryUpdateLastLoginAndPasswordIfNeeded(committableTrans, userId, tenantId, /*upgradePassword*/false, /*newDbHash*/null, "AutoLogin")) {
                                            committableTrans.Commit();
                                        }
                                    }
                                } catch (Exception e) {
                                    ErrorLog.LogApplicationError(e, e.StackTrace, heContext, "LOGIN");
                                }
                            }
                        }
                    }
                }
            }
        }


        public static void AttemptLogin(HeContext heContext, int inParamUserId, string inParamPassword, bool inParamPersistent, bool checkPassword) {
            string functionName = "Login" + (checkPassword ? "Password" : String.Empty);
            int tenantId = heContext.Session.TenantId;

            string username;
            string hashedPassword;

            if (!TryGetUsernameAndPassword(tenantId, inParamUserId, checkPassword, out username, out hashedPassword, functionName)) {
                throw new InvalidLoginException("Invalid username or password");
            }

            if (checkPassword && !RuntimePlatformUtils.Hashing.ValidatePasswordAgainstHash(inParamPassword, hashedPassword)) {
                throw new InvalidLoginException("Invalid username or password");
            }

            heContext.Session.ClearPermissions();

            // set session variables
            heContext.Session.SetUser(inParamUserId, username);
            heContext.AppInfo.InjectionCache.RunCallbacks(heContext.AppInfo, heContext.Session, Callbacks.CallbackEvent.Login);
 
            if (!heContext.AppInfo.IsMobileRuntime) {

                if (!heContext.IsReadOnlySessionRequest) {
                    CookieActions.AddSessionFixationProtectionCookie(heContext);

                    // if it is a persistent login, refresh the entry and refresh the cookie
                    if (inParamPersistent) {
                        CookieActions.AddOrRefreshPersistentLoginCookie(heContext, inParamUserId, functionName);
                    } else {
                        // always delete any persistent login entries, if a persistent cookie was sent and we did a regular login
                        CookieActions.DeletePersistentLoginEntryAndCookie(heContext, functionName);
                    }
                }

            } else {
                MobileRuntime.SetLoginInfo(heContext, inParamUserId, tenantId, inParamPersistent, username);
            }

            var upgradePassword = WillUpgradePassword(heContext, checkPassword, inParamPassword, hashedPassword);
            UpdateLastLoginAndPasswordIfNecessary(heContext, inParamUserId, tenantId, inParamPassword, upgradePassword, functionName);
        }


        private static bool TryGetUsernameAndPassword(int tenantId, int userId, bool fetchDbHash, out string username, out string hashInDb, string functionName) {
            username = null;
            hashInDb = null;
            using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                return DBRuntimePlatform.Instance.GetUserInfoForLogin(trans, tenantId, userId, /*fetchDbHash*/fetchDbHash, out username, out hashInDb, functionName);
            }
        }

        private static bool WillUpgradePassword(HeContext heContext, bool checkPassword, string inParamPassword, string hashedPassword) {

            // update login date and upgrade password if necessary
            bool isNotServiceCenterTenant = true;
            return checkPassword && isNotServiceCenterTenant
                && (inParamPassword != null) && RuntimePlatformSettings.Authentication.PasswordUpgradeOnLogin.GetValue()
                && RuntimePlatformUtils.Hashing.GetAlgorithmIndexForPasswordHash(hashedPassword) < RuntimePlatformUtils.Hashing.BestAlgorithmIndex;
        }

        private static void UpdateLastLoginAndPasswordIfNecessary(HeContext heContext, int userId, int tenantId, string inParamPassword, bool upgradePassword, string functionName) {
            if (upgradePassword || RuntimePlatformSettings.Authentication.UpdateUserLastLogin.GetValue()) {
                try {
                    // update login date
                    // #798465, #1006905 Use a committable transaction to update the last login to avoid locking concurrent logins
                    using (Transaction committableTrans = DatabaseAccess.ForRuntimeDatabase.GetCommitableTransaction()) {
                        var newDbHash = upgradePassword ? RuntimePlatformUtils.Hashing.GeneratePasswordHashWithBestAlgorithm(inParamPassword) : null;
                        if (DBRuntimePlatform.Instance.TryUpdateLastLoginAndPasswordIfNeeded(committableTrans, userId, tenantId, /*upgradePassword*/upgradePassword, newDbHash, functionName)) {
                            committableTrans.Commit();
                        }
                    }
                } catch (Exception e) {
                    ErrorLog.LogApplicationError(e, e.StackTrace, heContext, "LOGIN");
                }
            }
        }

        public class MobileRuntime {
            public static void SetLoginInfo(HeContext heContext, int inParamUserId, int tenantId, bool inParamPersistent, string username) {
                heContext.Session.NewRuntimeLoginInfo.Login(inParamUserId, tenantId, username, inParamPersistent, heContext.Session.HasNewRuntimeSessionStorage);
            }
        }
    }
}
