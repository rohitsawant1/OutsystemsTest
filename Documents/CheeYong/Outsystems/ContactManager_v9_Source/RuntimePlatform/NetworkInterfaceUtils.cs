/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.NetworkInformation;
using System.Net.Sockets;
using OutSystems.RuntimeCommon;
using System.Web;

namespace OutSystems.HubEdition.RuntimePlatform {

    public class NetworkInterfaceUtils {
        public static IEnumerable<IPAddress> GetAllIpAddresses() {
            List<IPAddress> result = new List<IPAddress>();

            NetworkInterface[] nic = NetworkInterface.GetAllNetworkInterfaces();
            for (int i = 0; i < nic.Length; i++) {
                foreach (UnicastIPAddressInformation uni in nic[i].GetIPProperties().UnicastAddresses) {
                    if (!IsLoopbackAddress(uni.Address.ToString())) {
                        result.Add(uni.Address);
                    }
                }
            }

            return result;
        }

        public static string RemoveScopeIdFromIp(string ip) {
            int indexOfScopeId = ip.IndexOf('%');
            if (indexOfScopeId > 0) {
                ip = ip.Substring(0, indexOfScopeId);
            }
            return ip;
        }

        static volatile string cachedInternalAddress;
        public static bool IsLoopbackAddress(string hostnameOrIp) {
            hostnameOrIp = RemoveScopeIdFromIp(hostnameOrIp).Trim().ToLower();

            string internalAddress;
            if (HttpContext.Current == null) {
                // Can't cache this in services because settings change as diferent sandboxes are served
                internalAddress = RuntimePlatformSettings.Misc.InternalAddress.GetValue();
            } else {
                if (cachedInternalAddress == null) {
                    internalAddress = cachedInternalAddress = RuntimePlatformSettings.Misc.InternalAddress.GetValue();
                } else {
                    internalAddress = cachedInternalAddress;
                }
            }
            var toRetrun = hostnameOrIp.IsOneOf("127.0.0.1", "::1", "localhost", internalAddress);
            OSTrace.Debug("IsLoopbackAddress - hostnameOrIp: " + hostnameOrIp + " - internalAddress: " + internalAddress + " result: " + toRetrun);
            return toRetrun;
        }

        public static bool IsLocalMachineAddress(string hostnameOrIP) {
            bool error;
            return IsLocalMachineAddress(hostnameOrIP, out error);
        }

        public static bool IsLocalMachineAddress(string hostnameOrIP, out bool error) {
            error = false;
            if (IsLoopbackAddress(hostnameOrIP)) {
                return true;
            }
            try {
                IPAddress[] hostnameIPs = Dns.GetHostAddresses(hostnameOrIP.Trim());
                IPAddress[] localhostIPs = Dns.GetHostAddresses(Dns.GetHostName());
                // Short-circuit early if possible because GetAllIpAddresses is an expensive call (assessed via profiling)
                if (ContainsAnyIpAddress(localhostIPs, hostnameIPs)) {
                    return true;
                }
                // #617204 ensure we also include the IP addresses configured for the interfaces, when detecting if an address is local or not
                return ContainsAnyIpAddress(GetAllIpAddresses(), hostnameIPs);
            } catch (Exception e) {
                OSTrace.Error("Checking if address is local address", e);
                error = true;
                return true;
            }
        }

        private static bool ContainsAnyIpAddress(IEnumerable<IPAddress> addressList, IEnumerable<IPAddress> addressesToFind) {
            return addressList.Any(ip => addressesToFind.Contains(ip, IPV6ComparerWithoutScopeId.Instance));
        }

        private class IPV6ComparerWithoutScopeId : IEqualityComparer<IPAddress> {

            internal static IPV6ComparerWithoutScopeId Instance { get; } = new IPV6ComparerWithoutScopeId();

            private IPV6ComparerWithoutScopeId() { }

            public bool Equals(IPAddress x, IPAddress y) {
                return x.GetAddressBytes().SequenceEqual(y.GetAddressBytes());
            }

            public int GetHashCode(IPAddress obj) {
                return string.Join(".", obj.GetAddressBytes().Select(part => part.ToString())).GetHashCode();
            }
        }

        public static List<IPAddress> GetIps() {
            List<IPAddress> rtnIps = new List<IPAddress>();
            IPHostEntry host = Dns.GetHostEntry(Dns.GetHostName());
            string IPAddress = string.Empty;
            foreach (IPAddress ip in host.AddressList) {
                if (ip.AddressFamily == AddressFamily.InterNetwork) {
                    rtnIps.Add(ip);
                }
            }
            return rtnIps;
        }

        public class IPAddressRange {
            public string Name { get; set; }

            private readonly AddressFamily addressFamily;
            private readonly byte[] lowerBytes;
            private readonly byte[] upperBytes;

            public IPAddressRange(IPAddress lower, IPAddress upper) {
                this.addressFamily = lower.AddressFamily;
                this.lowerBytes = lower.GetAddressBytes();
                this.upperBytes = upper.GetAddressBytes();
            }

            public IPAddressRange(IPAddress ip, int netmask) {
                uint mask = ~(uint.MaxValue >> netmask);

                // Convert the IP address to bytes.
                byte[] ipBytes = ip.GetAddressBytes();

                // BitConverter gives bytes in opposite order to GetAddressBytes().
                byte[] maskBytes = BitConverter.GetBytes(mask).Reverse().ToArray();

                byte[] startIPBytes = new byte[ipBytes.Length];
                byte[] endIPBytes = new byte[ipBytes.Length];

                // Calculate the bytes of the start and end IP addresses.
                for (int i = 0; i < ipBytes.Length; i++) {
                    startIPBytes[i] = (byte)(ipBytes[i] & maskBytes[i]);
                    endIPBytes[i] = (byte)(ipBytes[i] | ~maskBytes[i]);
                }

                this.addressFamily = ip.AddressFamily;
                this.lowerBytes = startIPBytes;
                this.upperBytes = endIPBytes;
            }

            public bool IsInRange(IPAddress address) {
                if (address.AddressFamily != addressFamily) {
                    return false;
                }

                byte[] addressBytes = address.GetAddressBytes();

                bool lowerBoundary = true, upperBoundary = true;

                for (int i = 0; i < this.lowerBytes.Length &&
                    (lowerBoundary || upperBoundary); i++) {
                    if ((lowerBoundary && addressBytes[i] < lowerBytes[i]) ||
                        (upperBoundary && addressBytes[i] > upperBytes[i])) {
                        return false;
                    }

                    lowerBoundary &= (addressBytes[i] == lowerBytes[i]);
                    upperBoundary &= (addressBytes[i] == upperBytes[i]);
                }

                return true;
            }
        }

        public static bool IsStringAnIP(string ip) {
            IPAddress ipAddress;
            return IPAddress.TryParse(ip, out ipAddress);
        }

        public static List<IPAddress> DnsLookup(string address) {

            IPAddress[] ip_list = null;

            try {
                ip_list = Dns.GetHostEntry(address).AddressList;
            } catch (Exception e) {
                OSTrace.Error("Dns Lookup", e);
            }

            if (ip_list != null && ip_list.Length > 0) {
                return ip_list.ToList();
            }

            // Dns.GetHostEntry performs a more thorough lookup (reverse dns lookup in addition to the forward dns lookup)
            // which will fail to retrieve the ip address in some scenarios where the GetHostAddresses will succeed.

            try {
                ip_list = Dns.GetHostAddresses(address);
            } catch (Exception e) {
                OSTrace.Error("Dns Lookup Extended", e);
            }

            if (ip_list != null && ip_list.Length > 0) {
                return ip_list.ToList();
            }

            throw new Exception("Unable to resolve address:" + address);
        }
    }
}
