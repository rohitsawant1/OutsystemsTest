/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Security.Principal;
using System.Threading;
using System.Web;
using OutSystems.HubEdition.RuntimePlatform.Log;
using OutSystems.HubEdition.RuntimePlatform.Processes;
using OutSystems.HubEdition.RuntimePlatform.Web;
using OutSystems.Internal.Db;
using OutSystems.ObjectKeys;
using OutSystems.RuntimeCommon;
using OutSystems.RuntimeCommon.Caching;
using OutSystems.RuntimeCommon.ObfuscationProperties;

// TODO: Prefix for Runtime table names are hardcoded

namespace OutSystems.HubEdition.RuntimePlatform {

    public class GenericExtendedActions {

        public static bool Check(HeContext heContext, ObjectKey key, int userId, int eSpaceId) {
            bool hasRole;

            int tenantId = heContext.Session.TenantId;

            if (userId == 0) {
                userId = heContext.Session.UserId;
            }

            if (userId == heContext.Session.UserId) {

                return heContext.Session.CheckRole(heContext.GetRoleIdFromKey(key.ToString(ObjectKey.DatabaseFormat), eSpaceId));

            } else {
                // Check userID exists in DB
                using (Transaction tran = DatabaseAccess.ForRuntimeDatabase.GetReadOnlyTransaction()) {
                    if (Convert.ToInt32(DBRuntimePlatform.Instance.GetNumUsersWithId(tran, userId)) != 1) {
                        throw new InvalidOperationException("Invalid User Id");
                    }

                    // see if user has permission
                    hasRole = DBRuntimePlatform.Instance.CheckRole(tran, userId, eSpaceId, key, tenantId);
                }
            }
            return hasRole;
        }

        public static void Grant(HeContext heContext, ObjectKey key, bool isPersistent, int userId, int eSpaceId) {

            int tenantId = heContext.Session.TenantId;

            if (userId == 0) {
                userId = heContext.Session.UserId;
            }

            if (userId == heContext.Session.UserId) {
                // update session state
                heContext.Session.AddRole(heContext.GetRoleIdFromKey(key.ToString(ObjectKey.DatabaseFormat), eSpaceId), null);
            }

            if (isPersistent) {
                int roleId;

                if (userId != 0) {
                    // Check userID exists in DB
                    using (Transaction tran = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                        if (Convert.ToInt32(DBRuntimePlatform.Instance.GetNumUsersWithId(tran, userId)) != 1) {
                            throw new InvalidOperationException("Invalid User Id");
                        }

                        roleId = Convert.ToInt32(DBRuntimePlatform.Instance.GetRoleId(tran, eSpaceId, key));

                        // Check for a previous grant
                        int grantCount = Convert.ToInt32(DBRuntimePlatform.Instance.CheckRole(tran, userId, roleId, tenantId));

                        if (grantCount == 0) {
                            DBRuntimePlatform.Instance.CreateUserRole(tran, userId, tenantId, roleId);
                        }
                    }
                }
            }
        }

        public static void Revoke(HeContext heContext, ObjectKey key, bool isPersistent, int userId, int eSpaceId) {

            int tenantId = heContext.Session.TenantId;

            if (userId == 0) {
                userId = heContext.Session.UserId;
            }

            if (userId == heContext.Session.UserId) {
                heContext.Session.RemoveRole(heContext.GetRoleIdFromKey(key.ToString(ObjectKey.DatabaseFormat), eSpaceId));
            }

            if (isPersistent && userId != 0) {
                using (Transaction tran = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                    // Check userID exists in DB
                    if (Convert.ToInt32(DBRuntimePlatform.Instance.GetNumUsersWithId(tran, userId)) != 1) {
                        throw new InvalidOperationException("Invalid User Id");
                    }

                    DBRuntimePlatform.Instance.DeleteUserRole(tran, userId, eSpaceId, key, tenantId);
                }
            }
        }

        [Obsolete("Deprecated. Use ESpaceInvalidateCache or TenantInvalidateCache instead.")]
        public static void TenantDeploy(HeContext heContext, int tenantId) {
            // This code was unnecessary for detached source code purposes and it was removed.
        }

        public static int CreateTenant(HeContext heContext, string espaceName, string tenantName) {
            // This code was unnecessary for detached source code purposes and it was removed.
            return 0;
        }

        [Obsolete("Deprecated. Use TenantInvalidate instead.")]
        public static void TenantRedeploy(HeContext heContext, int tenantId) {
            // This code was unnecessary for detached source code purposes and it was removed.
        }

        public static void TenantInvalidate(HeContext heContext, int tenantId) {
            // default value => get tenant id in use by caller
            if (tenantId == 0)
                tenantId = heContext.AppInfo.Tenant.Id;
            EspaceInvalidate(heContext, 0, tenantId);
        }

        [Obsolete("Please use EspaceInvalidate(heContext, eSpaceId, tenantId)")]
        public static void EspaceInvalidate(HeContext heContext) {
            EspaceInvalidate(heContext, heContext.AppInfo.eSpaceId, 0);
        }


        public static void EspaceInvalidate(HeContext heContext, int espaceId, int tenantId) {
            try {
                RuntimeCache.Instance.Invalidate(new EspaceTenantInvalidationKey(espaceId, tenantId));

                if (heContext != null) {
                    AppInfo appInfo = heContext.AppInfo;
                    if (appInfo != null) {
                        // #RRCT-2055 review this 'extraInfo' logic
                        string extraInfo = "Invalidated by espace '" + appInfo.eSpaceName + "'";
                        GeneralLog log = RuntimePlatformUtils.GenerateEspaceInvalidateMessage(heContext.SessionID, espaceId, tenantId, heContext.Session.UserId, appInfo.eSpaceId, appInfo.Tenant.Id, extraInfo);
                        log.Write();
                    }
                }
            } catch (Exception e) {
                Log.ErrorLog.LogApplicationError(e, heContext, "INVALIDATECACHE");
            }
        }

        public static void TenantSwitch(HeContext heContext, int tenantId) {
            if (!heContext.AllowTenantSwitch && heContext.Session.TenantId != tenantId) {
                throw new InvalidOperationException("TenantSwitch operation is not supported in this context.");
            }
            heContext.Session.TenantId = tenantId;
        }

        public static readonly string ReqAuditCountSessionName = "__reqAuditCount__";

        [Obsolete("Deprecated. Please use LogMessage(heContext, message, moduleName)")]
        public static void Audit(HeContext heContext, string ssMessage, string ssModuleName) {
            LogMessage(heContext, ssMessage, ssModuleName);
        }

        public static void LogMessage(HeContext heContext, string ssMessage, string ssModuleName) {

            // If audit is disabled, go away.
            if (!heContext.AppInfo.Properties.AllowAuditing)
                return;

            int maxAuditsPerRequest = RuntimePlatformSettings.Misc.MaxLogsPerRequestAudit.GetValue();
            int auditCount;

            if (heContext.Session[ReqAuditCountSessionName] == null)
                heContext.Session[ReqAuditCountSessionName] = 0;
            auditCount = Convert.ToInt32(heContext.Session[ReqAuditCountSessionName]);

            if (auditCount > maxAuditsPerRequest) {
                return; // error already logged in a previous call
            } else if (auditCount == maxAuditsPerRequest) { //replace user message
                ssMessage = "The maximum number (" + maxAuditsPerRequest + ") of allowed Audits per request has been exceeded. No more Audit messages will be logged in current request.";
            }

            GeneralLog log = new GeneralLog();
            log.Write(DateTime.Now,
                heContext.Session.SessionID,
                heContext.AppInfo.eSpaceId,
                heContext.AppInfo.Tenant.Id,
                heContext.Session.UserId,
                ssMessage,
                GeneralLogType.USER.ToString(),
                ssModuleName,
                "");

            heContext.Session[ReqAuditCountSessionName] = auditCount + 1;
        }

        [Obsolete("Deprecated. Please use CreateOrUpdateSiteProperty without passing the context")]
        public static void UpdateSiteProperty(HeContext heContext, int definitionId, bool isShared, string serializedValue) {
            int tenantId = heContext.AppInfo.Tenant.Id;
            using (Transaction tran = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                UpdateSiteProperty(tran, tenantId, definitionId, isShared, serializedValue);
            }
        }

        [DoNotObfuscate()]
        internal static bool UpdateSiteProperty(Transaction tran, int tenantId, int definitionId, bool isShared, string serializedValue) {
            return DBRuntimePlatform.Instance.UpdateSiteProperty(tran, definitionId, isShared, tenantId, serializedValue);
        }

        [DoNotObfuscate()]
        internal static bool CreateSiteProperty(Transaction tran, int tenantId, int definitionId, bool isShared, string serializedValue) {
            return DBRuntimePlatform.Instance.CreateSiteProperty(tran, definitionId, isShared, tenantId, serializedValue);
        }

        public static bool CreateOrUpdateSiteProperty(int tenantId, int definitionId, bool isShared, string serializedValue) {
            using (Transaction tran = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                return CreateOrUpdateSiteProperty(tran, tenantId, definitionId, isShared, serializedValue);
            }
        }

        public static bool CreateOrUpdateSiteProperty(Transaction tran, int tenantId, int definitionId, bool isShared, string serializedValue) {
            bool updateSuccess = UpdateSiteProperty(tran, tenantId, definitionId, isShared, serializedValue);
            if (!updateSuccess) {
                return CreateSiteProperty(tran, tenantId, definitionId, isShared, serializedValue);
            }
            return updateSuccess;
        }

        [Obsolete("Deprecated. Please use UpdateSiteProperty.")]
        public static void ChangeSiteProperty(HeContext heContext, ObjectKey propKey, string name, object val) {
            string propValue;
            string[] nameparts = name.Split('.');

            int tenantId = heContext.AppInfo.Tenant.Id;
            int eSpaceId;

            using (Transaction tran = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                if (nameparts.Length == 1 || nameparts[0] == heContext.AppInfo.eSpaceName) {
                    eSpaceId = heContext.AppInfo.eSpaceId;
                } else {
                    //it's a consumed one, use producer IDs
                    eSpaceId = DBRuntimePlatform.Instance.GetEspaceId(tran, nameparts[0]);
                }

                propValue = RuntimePlatformUtils.ConvertToString(val);

                // Get the site property id
                bool isShared;
                int propId = DBRuntimePlatform.Instance.GetSitePropertyId(tran, propKey, eSpaceId, out isShared);

                if (propId == 0) {
                    throw (new ArgumentException("Could not find property '" + propKey + "' or non customizable entity."));
                }

                DBRuntimePlatform.Instance.UpdateSiteProperty(tran, propId, isShared, tenantId, propValue);
            }
        }

        public static bool IntegratedSecurityCheckRole(HeContext heContext, string roleName) {
            if (!heContext.Context.Request.IsAuthenticated) {
                return false;
            }
            if (!(heContext.Context.User is WindowsPrincipal)) {
                return false;
            }
            return ((WindowsPrincipal)heContext.Context.User).IsInRole(roleName);
        }

        public static void IntegratedSecurityGetDetails(HeContext heContext, out string Username, out bool isGuest, out bool isSystem, out bool isAnonymous, out bool isAuthenticated) {
            Username = "";
            isGuest = false;
            isSystem = false;
            isAnonymous = false;
            isAuthenticated = false;

            if (!heContext.Context.Request.IsAuthenticated) {
                return;
            }

            if (!(heContext.Context.User is WindowsPrincipal)) {
                return;
            }

            WindowsPrincipal wp = ((WindowsPrincipal)heContext.Context.User);
            if (wp == null) {
                return;
            }
            if (!(wp.Identity is WindowsIdentity)) {
                return;
            }
            WindowsIdentity wi = ((WindowsIdentity)wp.Identity);
            if (wi == null) {
                return;
            }
            Username = wi.Name;
            isAuthenticated = wi.IsAuthenticated;
            isGuest = wi.IsGuest;
            isSystem = wi.IsSystem;
            isAnonymous = wi.IsAnonymous;
        }

        [Obsolete("Deprecated on 11.0.0.0. No SMS support.")]
        public static void InboundSmsGetDetails(
            HeContext heContext,
            out string MSISDN,
            out string LargeAccount,
            out string Message,
            out string BinaryMessage,
            out string UDH,
            out string MessageId,
            out int Priority,
            out string Encoding,
            out string Connection,
            out string OperatorCode,
            out DateTime Sent,
            out string Custom1,
            out string Custom2,
            out string Custom3) {
            MSISDN = "";
            LargeAccount = "";
            Message = "";
            BinaryMessage = "";
            UDH = "";
            MessageId = "";
            Priority = 0;
            Encoding = "";
            Connection = "";
            OperatorCode = "";
            Sent = new DateTime(1900, 1, 1, 0, 0, 0);
            Custom1 = "";
            Custom2 = "";
            Custom3 = "";
        }

        public static void ClientCertificateGetDetails(
            HeContext heContext,
            out string cookie,
            out int flags,
            out bool isPresent,
            out string issuer,
            out bool isValid,
            out string serialNumber,
            out string serverIssuer,
            out string serverSubject,
            out string subject,
            out DateTime validFrom,
            out DateTime validUntil) {
            cookie = "";
            flags = 0;
            isPresent = false;
            issuer = "";
            isValid = false;
            serialNumber = "";
            serverIssuer = "";
            serverSubject = "";
            subject = "";
            validFrom = BuiltInFunction.NullDate();
            validUntil = BuiltInFunction.NullDate();
            System.Web.HttpClientCertificate cert = System.Web.HttpContext.Current.Request.ClientCertificate;
            cookie = cert.Cookie;
            flags = cert.Flags;
            isPresent = cert.IsPresent;
            issuer = cert.Issuer;
            isValid = cert.IsValid;
            serialNumber = cert.SerialNumber;
            serverIssuer = cert.ServerIssuer;
            serverSubject = cert.ServerSubject;
            subject = cert.Subject;
            validFrom = cert.ValidFrom;
            validUntil = cert.ValidUntil;
        }

        public static string ClientCertificateGetValue(HeContext heContext, string key) {
            try {
                return (string)System.Web.HttpContext.Current.Request.ClientCertificate[key];
            } catch {
                return "";
            }
        }

        // Multi-language
        public static void SetCurrentLocale(HeContext heContext, string locale) {
            if (locale == "default" || !AppInfo.GetAppInfo().MultilingualEnabled) {
                locale = "";
            }
            var wasSetLocale = false;
            if (heContext.CurrentLocale.ToLowerInvariant() != locale.ToLowerInvariant()) {
                new CultureInfo(locale);    //assures that the Locale is known by .Net/Java
                heContext.CurrentLocale = locale;
                wasSetLocale = true;
                if (!heContext.IsWebServiceRequest) {
                    heContext.AppInfo.InjectionCache.RunCallbacks(heContext.AppInfo, heContext.Session, Callbacks.CallbackEvent.ChangeLocale);
                }
            }

            // Traces
            if (RuntimePlatformSettings.Debug.DebugSetCurrentLocale.GetValue()) {
                try {
                    GeneralLog.StaticWrite(DateTime.Now, heContext.Session.SessionID, heContext.AppInfo.eSpaceId,
                        heContext.AppInfo.Tenant.Id, heContext.Session.UserId,
                        string.Format("did set current locale:{0}, locale:{1}\n{2}", wasSetLocale, locale, Environment.StackTrace),
                        "DEBUG", "OSLOCALE", "");
                } catch { }
            }
        }

        // Ajax NotifyWidget
        public static void Deprecated_NotifyWidget(HeContext heContext, string widgetId, string message) {
            // queue javascript in the current page
            heContext.QueueJavascript(JavaScriptManager.osAjaxNotifyWidget(widgetId, message));
        }

        public static void NotifyWidget_Deprecated(HeContext heContext, string widgetId, string message) {
            Deprecated_NotifyWidget(heContext, widgetId, message);
        }

        public static void NotifyWidget(HeContext heContext, string widgetId, string message) {
            NotifyWidget_Deprecated(heContext, widgetId, message);
        }

        public static void Deprecated_Notify(HeContext heContext, object webBlock, string message) {
            var wb = (INotifySender)webBlock;
            wb.OnNotifyCalled(message);
        }

        public static void Notify(HeContext heContext, object webBlock, string message) {
            Deprecated_Notify(heContext, webBlock, message);
        }

        public static void Deprecated_NotifyWidgetGetMessage(HeContext heContext, out string message) {
            // Support publish without refreshing name
            NotifyGetMessage(heContext, out message);
        }

        public static void NotifyWidgetGetMessage(HeContext heContext, out string message) {
            Deprecated_NotifyWidgetGetMessage(heContext, out message);
        }

        public static void NotifyGetMessage(HeContext heContext, out string message) {
            // Calls the built-in function
            message = BuiltInFunction.NotifyWidgetGetMessage();
        }

        public static string GenerateGuid(HeContext heContext) {
            return Guid.NewGuid().ToString();
        }

        // BPM
        public static void ActivityOpen(HeContext heContext, int Id, out string handlingUrl) {
            bool success;
            string failureMessage;
            InnerActivityOpen(heContext, Id, /*onlyGetUrl*/false, out success, out failureMessage, out handlingUrl, kind => kind.CanBeOpened(), "ActivityOpen");
            if (!success) {
                ProcessBase.ThrowSpecificException(failureMessage);
            }
        }

        // BPM
        public static void ActivityGetUrl(HeContext heContext, int Id, out string handlingUrl) {
            bool success;
            string failureMessage;
            // TODO MSM: Check this 
            InnerActivityOpen(heContext, Id, /*onlyGetUrl*/true, out success, out failureMessage, out handlingUrl, kind => kind.CanBeOpened(), "ActivityGetUrl");
            if (!success) {
                ProcessBase.ThrowSpecificException(failureMessage);
            }
        }

        private static void InnerActivityOpen(HeContext heContext, int activityId, bool onlyGetUrl, out bool success, out string failureMessage, out string handlingUrl, Func<ActivityKind, bool> activityKindCheck, string actionName) {
            string SSKey;
            string url;
            int tenantId;

            int processId;
            ActivityKind activityKind;
            string activityName;
            string espaceSSKey;
            BPMRuntime.GetActivityDataForWS(activityId, out processId, out activityKind, out activityName, out SSKey, out url, out tenantId, out espaceSSKey);

            int userId = tenantId == heContext.Session.TenantId ? heContext.Session.UserId : 0;

            if (!activityKindCheck(activityKind)) {
                throw new InvalidOperationException("Activity '" + activityName + "' (#" + activityId + ") cannot be opened.");
            }

            if (!onlyGetUrl) {
                if (userId == 0) {
                    throw new SecurityException(actionName + " requires a logged user");
                }

                using (Transaction tran = DatabaseAccess.ForRuntimeDatabase.GetReadOnlyTransaction()) {
                    int allowedActivity = BPMRuntime.GetAllowedActivities(heContext, tran, new int[] { activityId }, userId).FirstIfSingleOrDefault();
                    if (allowedActivity != activityId) {
                        throw new SecurityException("The user in session does not have the correct permissions to open the activity or the activity is already open by another user.");
                    }
                }
            }

            using (ActivityHandler activityHandler = new ActivityHandler(url, tenantId, userId, heContext.AppInfo.eSpaceUID, espaceSSKey)) {
                //ToDo: activityHandler.Timeout = (int)(1.2 * TimeoutInSec) * 1000;
                success = activityHandler.ExecuteOnOpen(SSKey, activityId, processId, tenantId, userId, BuiltInFunction.GetCurrentLocale(), heContext.Session.SessionID, heContext.Context.Request.IsSecureConnection, heContext.Context.Request.Url.Host, onlyGetUrl, out failureMessage, out handlingUrl);
                handlingUrl = BuiltInFunction.AddPersonalAreaToURLPath(handlingUrl);
            }
            handlingUrl = RuntimePlatformUtils.CheckUriSecurity(HttpContext.Current.Request, handlingUrl);
        }

        public static void ActivitySetGroup(HeContext heContext, int activityId, int groupId) {
            using (Transaction tran = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                DBRuntimePlatform.Instance.UpdateHumanActivityParams(tran, activityId, null, groupId, null, null, null);
            }
        }

        public static void ActivityReset(HeContext heContext, int activityId, bool resetActivityUser) {
            string SSKey;
            string url;
            int tenantId;

            bool success;
            string failureMessage;

            int processId;
            ActivityKind activityKind;
            string activityName;
            BPMRuntime.GetActivityDataForWS(activityId, out processId, out activityKind, out activityName, out SSKey, out url, out tenantId, out string espaceSSKey);

            int userId = tenantId == heContext.Session.TenantId ? heContext.Session.UserId : 0;
            using (ActivityHandler activityHandler = new ActivityHandler(url, tenantId, userId, heContext.AppInfo.eSpaceUID, espaceSSKey)) {
                //ToDo: activityHandler.Timeout = (int)(1.2 * TimeoutInSec) * 1000;
                success = activityHandler.ExecuteActivityReset(SSKey, activityId, processId, resetActivityUser, tenantId, userId, BuiltInFunction.GetCurrentLocale(), out failureMessage);
                if (!success) {
                    ProcessBase.ThrowSpecificException(failureMessage);
                }
            }
        }

        public static void ActivitySchedule(HeContext heContext, int activityId, DateTime startDate) {
            string SSKey;
            string url;
            int tenantId;

            bool success;
            string failureMessage;

            int processId;
            ActivityKind activityKind;
            string activityName;
            BPMRuntime.GetActivityDataForWS(activityId, out processId, out activityKind, out activityName, out SSKey, out url, out tenantId, out string espaceSSKey);

            int userId = tenantId == heContext.Session.TenantId ? heContext.Session.UserId : 0;
            using (ActivityHandler activityHandler = new ActivityHandler(url, tenantId, userId, heContext.AppInfo.eSpaceUID, espaceSSKey)) {
                //ToDo: activityHandler.Timeout = (int)(1.2 * TimeoutInSec) * 1000;
                success = activityHandler.ExecuteActivitySchedule(SSKey, activityId, processId, startDate, tenantId, userId, BuiltInFunction.GetCurrentLocale(), out failureMessage);
                if (!success) {
                    ProcessBase.ThrowSpecificException(failureMessage);
                }
            }
        }

        public static void ActivityStart(HeContext heContext, int processId, string activityssKey, string actionName, List<Pair<string, object>> inputs, out int nextHumanActivityId) {
            int activityId;

            using (Transaction tran = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                var retries = 0;
                do {
                    activityId = DBRuntimePlatform.Instance.GetActiveActivityInProcess(tran, processId, activityssKey, ActivityStatus.Listening);
                    if (activityId == BuiltInFunction.NullIdentifier()) {
                        if (RuntimePlatformSettings.Processes.ConditionalStartListenersCreatedOnDemand.GetValue()) {
                            using (Transaction priv = DatabaseAccess.ForRuntimeDatabase.GetCommitableTransaction()) {
                                DBRuntimePlatform.Instance.CreateMissingStartActivityInProcess(priv, processId, activityssKey);
                                activityId = DBRuntimePlatform.Instance.GetActiveActivityInProcess(tran, processId, activityssKey, ActivityStatus.Created);
                                priv.Commit();
                            }
                            // Needed to execute the onready as fast as possible (don't wait for the scheduler)
                            ActivityPushFromCreated(heContext, processId, activityssKey, activityId);
                            activityId = DBRuntimePlatform.Instance.GetActiveActivityInProcess(tran, processId, activityssKey, ActivityStatus.Listening);
                        }
                    }
                    retries++;
                    // Wait up to 30 seconds in case the scheduler captured the activity
                    if (activityId != BuiltInFunction.NullIdentifier() ||
                        retries >= RuntimePlatformSettings.Processes.StartActivityReadyWaitTimeInSeconds.GetValue()) {
                        break;
                    }
                    Thread.Sleep(1000);
                } while (true);

                if (activityId == BuiltInFunction.NullIdentifier()) {
                    throw new InvalidOperationException("There is no activity in process #" + processId + " that could be started using " + actionName + ".");
                }
            }

            ActivityStart(heContext, activityId, inputs, out nextHumanActivityId);
        }

        private static void ActivityPushFromCreated(HeContext heContext, int processId, string activityssKey, int activityId) {

            ActivityKind activityKind;
            string activityName;
            string ssKey;
            string url;
            int tenantId;

            BPMRuntime.GetActivityDataForWS(activityId, out processId, out activityKind, out activityName, out ssKey, out url, out tenantId, out string espaceSSKey);

            using (ActivityHandler activityHandler = new ActivityHandler(url, tenantId, heContext.Session.UserId, heContext.AppInfo.eSpaceUID, espaceSSKey)) {
                activityHandler.ExecuteActivityAction(activityssKey, activityId, processId, tenantId, ActivityStatus.Created);
            }
        }

        public static void ActivityStart(HeContext heContext, int activityId, out int nextHumanActivityId) {
            ActivityStart(heContext, activityId, new List<Pair<string, object>>(0), out nextHumanActivityId);
        }

        public static void ActivityStart(HeContext heContext, int activityId, List<Pair<string, object>> inputs, out int nextHumanActivityId) {
            nextHumanActivityId = InnerActivityClose(heContext, activityId, true, false, false, ActivityStartChecks, inputs);
        }

        private static void ActivityStartChecks(int activityId, string name, ActivityKind activityKind, string SSKey) {
            if (!activityKind.CanBeStarted()) {
                throw new InvalidOperationException("Activity '" + name + "' (#" + activityId + ") cannot be started.");
            }
        }

        public static void ActivitySkip(HeContext heContext, int activityId, out int nextHumanActivityId) {
            Action<int, string, ActivityKind, string> kindCheck = (id, name, kind, key) => ActivityCloseChecks(id, name, kind, key, string.Empty, "ActivitySkip", true);
            nextHumanActivityId = InnerActivityClose(heContext, activityId, true, true, false, kindCheck, new List<Pair<string, object>>(0));
        }

        public static void ActivityClose(HeContext heContext, int activityId, out int nextHumanActivityId) {
            ActivityClose(heContext, activityId, string.Empty, "ActivityClose", new List<Pair<string, object>>(0), out nextHumanActivityId);
        }

        public static void ActivityClose(HeContext heContext, int activityId, string requiredssKey, string actionName, List<Pair<string, object>> inputs, out int nextHumanActivityId) {
            Action<int, string, ActivityKind, string> kindCheck = (id, name, kind, key) => ActivityCloseChecks(id, name, kind, key, requiredssKey, actionName, false);
            nextHumanActivityId = InnerActivityClose(heContext, activityId, true, false, false, kindCheck, inputs);
        }

        public static void ActivityCloseAsynchronous(HeContext heContext, int activityId) {
            Action<int, string, ActivityKind, string> kindCheck = (id, name, kind, key) => ActivityCloseChecks(id, name, kind, key, string.Empty, "ActivityCloseAsynchronous", false);
            InnerActivityClose(heContext, activityId, false, false, false, kindCheck, new List<Pair<string, object>>(0));
        }

        private static void ActivityCloseChecks(int activityId, string name, ActivityKind activityKind, string SSKey, string requiredssKey, string actionName, bool skip) {
            if (!activityKind.CanBeClosed()) {
                throw new InvalidOperationException("Activity '" + name + "' (#" + activityId + ") cannot be " + (skip ? "skipped" : "closed") + ".");
            }
            if (!requiredssKey.IsEmpty() && SSKey != requiredssKey) {
                throw new InvalidOperationException("Invalid use of activity '" + name + "' identifier in action " + actionName);
            }
        }

        private static int InnerActivityClose(HeContext heContext, int activityId, bool advanceProcess, bool skip, bool skipAll, Action</*id*/int, /*name*/string, ActivityKind, /*key*/string> activityChecks, List<Pair<string, object>> inputs) {
            int userId;
            string SSKey;
            string url;
            int tenantId;
            List<Pair<int, ActivityKind>> nextActIds;

            ActivityKind activityKind;
            string activityName;
            int processId;
            BPMRuntime.GetActivityDataForWS(activityId, out processId, out activityKind, out activityName, out SSKey, out url, out tenantId, out string espaceSSKey);

            userId = tenantId == heContext.Session.TenantId ? heContext.Session.UserId : 0;

            activityChecks(activityId, activityName, activityKind, SSKey);

            using (ActivityHandler activityHandler = new ActivityHandler(url, tenantId, userId, heContext.AppInfo.eSpaceUID, espaceSSKey)) {
                string failureMessage;
                bool success = activityHandler.ExecuteOnClose(SSKey, activityId, processId, tenantId, userId, BuiltInFunction.GetCurrentLocale(), advanceProcess, skip, skipAll, inputs, out failureMessage, out nextActIds);

                if (!success) {
                    ProcessBase.ThrowSpecificException(failureMessage);
                }
            }

            if (advanceProcess) {
                using (Transaction tran = DatabaseAccess.ForRuntimeDatabase.GetReadOnlyTransaction()) {
                    return BPMRuntime.GetNextHumanActivity(heContext, tran, nextActIds, userId);
                }
            }

            return BuiltInFunction.NullIdentifier();
        }

        public static int ProcessLaunch(HeContext heContext, ObjectKey SSKey, ObjectKey espaceSSKey, int parentActivityId, int parentProcessId, List<Pair<string, object>> inputs, out int nextHumanActivity) {
            List<Pair<int, ActivityKind>> nextActIds;

            int newProcessId = ProcessLaunch(heContext, SSKey, espaceSSKey, parentActivityId, parentProcessId, inputs, out nextActIds);

            nextHumanActivity = BuiltInFunction.NullIdentifier();

            return newProcessId;
        }

        public static int ProcessLaunch(HeContext heContext, ObjectKey SSKey, ObjectKey espaceSSKey, int parentActivityId, int parentProcessId, List<Pair<string, object>> inputs, out List<Pair<int, ActivityKind>> nextActIds) {
            string ssKey = ObjectKeyUtils.DatabaseValue(SSKey);

            BPMRuntime.GetProcessDataForWS(heContext, SSKey, espaceSSKey, out string url);

            using (ActivityHandler activityHandler = new ActivityHandler(url, heContext.Session.TenantId, heContext.Session.UserId, heContext.AppInfo.eSpaceUID, ObjectKeyUtils.DatabaseValue(espaceSSKey))) {
                int newProcessId = activityHandler.ExecuteProcessLaunch(ssKey, heContext.Session.TenantId, heContext.Session.UserId, parentActivityId, parentProcessId, inputs, out nextActIds, out string failureMessage);
                if (!failureMessage.IsEmpty() || newProcessId == 0) {
                    ProcessBase.ThrowSpecificException(failureMessage);
                }
                return newProcessId;
            }
        }

        public static void ProcessTerminate(HeContext heContext, int processId) {
            BPMRuntime.GetProcessDataForWS(processId, out string SSKey, out string url, out int tenantId, out string consumerKey);

            int userId = tenantId == heContext.Session.TenantId ? heContext.Session.UserId : 0;
            using (ActivityHandler activityHandler = new ActivityHandler(url, tenantId, userId, heContext.AppInfo.eSpaceUID, consumerKey)) {
                bool success = activityHandler.ExecuteProcessTerminate(SSKey, processId, tenantId, userId, out string failureMessage);
                if (!success) {
                    ProcessBase.ThrowSpecificException(failureMessage);
                }
            }
        }

        public static void ProcessSuspend(HeContext heContext, int processId, bool suspend) {
            SetProcessSuspension(heContext, processId, true);
        }

        public static void ProcessRelease(HeContext heContext, int processId, bool suspend) {
            SetProcessSuspension(heContext, processId, false);
        }

        private static void SetProcessSuspension(HeContext heContext, int processId, bool suspend) {
            BPMRuntime.GetProcessDataForWS(processId, out string SSKey, out string url, out int tenantId, out string consumerKey);

            int userId = tenantId == heContext.Session.TenantId ? heContext.Session.UserId : 0;
            using (ActivityHandler activityHandler = new ActivityHandler(url, tenantId, userId, heContext.AppInfo.eSpaceUID, consumerKey)) {
                bool success = activityHandler.ExecuteSetProcessSuspension(SSKey, processId, suspend, tenantId, userId, out string failureMessage);
                if (!success) {
                    ProcessBase.ThrowSpecificException(failureMessage);
                }
            }
        }

        // TODO Unused session argument, remove in future version
        public static void AutoLogin(AppInfo info, SessionInfo session) {
            LoginExtendedAction.AutoLogin(info.OsContext);
        }

        public static void Login(HeContext heContext, int inParamUserId, bool inParamPersistent) {
            AttemptLogin(heContext, inParamUserId, null, inParamPersistent, false);
        }

        public static void LoginPassword(HeContext heContext, int inParamUserId, string inParamPassword, bool inParamPersistent) {
            AttemptLogin(heContext, inParamUserId, inParamPassword, inParamPersistent, true);
        }

        private static void AttemptLogin(HeContext heContext, int inParamUserId, string inParamPassword, bool inParamPersistent, bool checkPassword) {
            LoginExtendedAction.AttemptLogin(heContext, inParamUserId, inParamPassword, inParamPersistent, checkPassword);
        }
    }
}
