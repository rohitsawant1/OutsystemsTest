/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using OutSystems.HubEdition.RuntimePlatform.Callbacks;
using OutSystems.HubEdition.RuntimePlatform.Callbacks.Invoke;
using OutSystems.Internal.Db;
using OutSystems.ObjectKeys;
using OutSystems.RuntimeCommon;

namespace OutSystems.HubEdition.RuntimePlatform {

    public sealed class CodeInjectionFactory {

        public enum Locations { HeadTop /*we're assuming this is the first location - find uses*/, HeadBottom, BodyTop, BodyBottom };
        public static readonly CodeInjectionFactory Instance = new CodeInjectionFactory();
        private CodeInjectionFactory() {
        }

        public InjectionCache EmptyInjectionCache() {
            return new InjectionCache(Enumerable.Empty<ICodeInjectionElement>(), Enumerable.Empty<AbstractCallback.EventListener>());
        }

        public InjectionCache ReadInjectionElements(IDataReader reader, ObjectKey _eSpaceUID, bool hideInProvider) {
            List<ICodeInjectionElement> callbacks = new List<ICodeInjectionElement>();
            List<AbstractCallback.EventListener> listeners = new List<AbstractCallback.EventListener>();
            while (reader.Read()) {
                if (reader.SafeGet<string>("CallbackType").EqualsIgnoreCase("Dynamic") && !hideInProvider) {
                    listeners.Add(NewCallbackListener(reader, callbacks));                    
                } else {
                    callbacks.Add(CreateInjectedJavascript(reader));
                }
            }
            HashSet<AbstractCallback> onlyCallbacks = new HashSet<AbstractCallback>();
            HashSet<ICodeInjectionElement> calbacksToRemove = new HashSet<ICodeInjectionElement>();
            callbacks.OfType<AbstractCallback>().Apply(c => onlyCallbacks.Add(c));
            listeners.Apply(l => l.NormalizeCallback(onlyCallbacks));
            listeners = listeners.Distinct().ToList(); // clean repeated listeners
            callbacks = callbacks.Distinct().ToList(); //#886594 - We should have only one callback per listener.
            foreach (var callback in callbacks.OfType<AbstractCallback>()) {
                if (!listeners.Select(listener => listener.Callback).Contains(callback)) {
                    calbacksToRemove.Add(callback);
                }
            }
            callbacks.Except(calbacksToRemove);
            return new InjectionCache(callbacks, listeners);
        }

        private AbstractCallback.EventListener NewCallbackListener(IDataReader reader, List<ICodeInjectionElement> injectionElements) {
            AbstractCallbackInvoke invoke = CreateCallbackInvoke(reader);
            CodeInjectionFactory.Locations location = (CodeInjectionFactory.Locations)Enum.Parse(typeof(CodeInjectionFactory.Locations), reader.SafeGet<string>("CallbackLocation"));
            AbstractCallback callback = CreateCallback(reader, location, invoke) as AbstractCallback;

            callback.HideInProvider = (reader["HIDE_IN_PROVIDER"] != DBNull.Value ? Convert.ToBoolean(reader["HIDE_IN_PROVIDER"]) : false);
            callback.IsLocalizable = (reader["IS_LOCALIZED"] != DBNull.Value ? Convert.ToBoolean(reader["IS_LOCALIZED"]) : false);
            injectionElements.Add(callback);

            return CreateCallbackEventListener(reader, callback);
        }

        private ICodeInjectionElement CreateInjectedJavascript(IDataReader reader) {
            if (!Enum.IsDefined(typeof(Locations), reader.SafeGet<string>("CallbackLocation"))) {
                throw new ArgumentException("Invalid enum type.");
            }
            return new InjectedJavascript(
                        reader.SafeGet<string>("CALLBACKNAME"),
                        reader.SafeGet<string>("URL"),
                        reader.SafeGet<string>("SCRIPT"),
                        (CodeInjectionFactory.Locations)Enum.Parse(typeof(CodeInjectionFactory.Locations), reader.SafeGet<string>("CallbackLocation")),
                        reader.SafeGet<int>("ORDER"),
                        reader.SafeGet<string>("DESCRIPTION"),
                        reader.SafeGet<bool>("IsActive"));
        }

        private ICodeInjectionElement CreateCallback(IDataReader reader, CodeInjectionFactory.Locations locationId, AbstractCallbackInvoke invoke) {
            int id = DataReaderUtils.SafeGet<int>(reader["ID"]);
            if (Convert.ToString(reader["PROVIDERNAME"]) == "ECT_Provider") {
                return CreateEctCallback(reader, locationId, (WebServiceCallbackInvoke) invoke);
            } else if (Convert.ToBoolean(reader["IS_VOLATILE"]) == true) {
                return new VolatileContentCallback(id, locationId, (AbstractStringCallbackInvoke) invoke);
            } else if (Convert.ToBoolean(reader["IS_STATIC"]) == true) {
                return new StaticContentCallback(id, locationId, (AbstractStringCallbackInvoke) invoke);
            } else {
                return new DummyCallback(id, locationId, invoke);
            }
        }

        private ICodeInjectionElement CreateEctCallback(IDataReader reader, CodeInjectionFactory.Locations locationId, WebServiceCallbackInvoke invoke) {
            int id = DataReaderUtils.SafeGet<int>(reader["ID"]);
            switch (Convert.ToString(reader["METHODNAME"])) {
            case "GetHtml":
                    return new Callbacks.ECT.ECTGetHtmlCallback(id, locationId, invoke);
            case "ShowFeedback":
                    return new Callbacks.ECT.ECTShowFeedbackCallback(id, locationId, invoke);
            default:
                return null;
            }
        }

        private AbstractCallbackInvoke CreateCallbackInvoke(IDataReader reader) {
            int id = DataReaderUtils.SafeGet<int>(reader["ID"]);
            string url = Convert.ToString(reader["URL"]);
            string serviceName = Convert.ToString(reader["SERVICENAME"]);
            string providerName = Convert.ToString(reader["PROVIDERNAME"]);
            string methodName = Convert.ToString(reader["METHODNAME"]);
            string toLowerUrl = url.ToLowerInvariant();
            if (toLowerUrl.TrimStart().StartsWith("http://") || toLowerUrl.TrimStart().StartsWith("https://")) {
                return new WebServiceCallbackInvoke(url, serviceName, providerName, methodName);
            } else {
                return new LibraryCallbackInvoke(url, serviceName, providerName, methodName);
            }
        }

        private AbstractCallback.EventListener CreateCallbackEventListener(IDataReader reader, AbstractCallback callback) {
            CallbackEvent evt = (CallbackEvent) Enum.Parse(typeof(CallbackEvent), Convert.ToString(reader["CALLBACKNAME"]));
            int espaceId = (reader["ESPACEID"] == DBNull.Value? 0 : Convert.ToInt32(reader["ESPACEID"]));
            int tenantId = (reader["TENANTID"] == DBNull.Value? 0 : Convert.ToInt32(reader["TENANTID"]));

            if (evt == CallbackEvent.GetHtmlForUser &&
                !(callback is Callbacks.ECT.ECTShowFeedbackCallback) &&
                !(callback is Callbacks.ECT.ECTGetHtmlCallback)) {
                throw new InvalidOperationException("GetHtmlForUser must be used for ECT Callbacks only");
            }

            if (evt.AffectsApplication()) {
                tenantId = 0;
            }

            return callback.BuildEventListener(evt, espaceId, tenantId);
        }
    }
}