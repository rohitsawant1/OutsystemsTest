/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Web;
using OutSystems.HubEdition.RuntimePlatform.Cache;
using OutSystems.HubEdition.RuntimePlatform.IPAddressRangeLib;
using OutSystems.HubEdition.RuntimePlatform.Log;
using OutSystems.HubEdition.RuntimePlatform.SessionState;
using OutSystems.HubEdition.RuntimePlatform.WebReference;
using OutSystems.Internal.Db;
using OutSystems.ObjectKeys;
using OutSystems.RuntimeCommon;

namespace OutSystems.HubEdition.RuntimePlatform {
    public partial class RuntimePlatformUtils {

        [Obsolete("This is deprecated, use Constants.DefaultEncoding instead")]
        public static Encoding DefaultEncoding { get { return Constants.DefaultEncoding; } }

        public static bool FromBrowserRequest() {
            return !HttpContext.Current.Request.UserAgent.IsEmpty();
        }

        public static bool ShouldCreateCookieForRequest() {
            return !HttpContext.Current.Request.UserAgent.IsEmpty() &&
                !HttpContext.Current.Request.UserAgent.Contains("RichMail") &&
                !HttpContext.Current.Request.UserAgent.Contains("Apache-HttpClient") &&
                !RuntimePlatformSettings.Misc.DisableMetricsCollect.GetValue();
        }

        public static bool IsValidRequestForVisit() {
            return ShouldCreateCookieForRequest() && !NetworkInterfaceUtils.IsLoopbackAddress(HttpContext.Current.Request.UserHostAddress);
        }

        [DebuggerNonUserCode]
        private static HttpRequest SafeGetRequest(HttpContext context) {
            try {
                return context.Request;
            } catch {
                return null;
            }
        }

        public static string GetClientIpForLogging() {
            var context = HttpContext.Current;
            if (context != null && SafeGetRequest(context) != null) {
                try {
                    string address = context.Request.UserHostAddress;
                    string xForwardedFor = context.Request.ServerVariables["HTTP_X_FORWARDED_FOR"];
                    if (!xForwardedFor.IsEmpty()) {
                        xForwardedFor = xForwardedFor.SafeSplit(',').FirstOrDefault();
                        if (!xForwardedFor.IsEmpty() && xForwardedFor.ToLowerInvariant() != "unknown") {
                            return address + " X-Forwarded-For: " + xForwardedFor;
                        }
                    }
                    return address;
                } catch {
                    return null;
                }
            }
            return null;
        }

        public static string GetDeviceUuidForLogging() {
            string result = null;
            var context = HttpContext.Current;
            if (context != null && SafeGetRequest(context) != null) {
                result = context.Request.Headers["OutSystems-device-uuid"];
            }

            if (!result.IsNullOrEmpty()) {
                result = "DeviceUUID: " + result;
            }
            return result;
        }

        public static string GetRequestSourceForLogging() {

            var clientIp = GetClientIpForLogging();
            var deviceUuid = GetDeviceUuidForLogging();

            var result = new StringBuilder();

            if (!clientIp.IsNullOrEmpty()) {
                result.Append(clientIp);
            }

            if (!deviceUuid.IsNullOrEmpty()) {

                if (!clientIp.IsNullOrEmpty()) {
                    result.Append("; ");
                }

                result.Append(deviceUuid);
            }

            return result.ToString();

        }

        /// <summary>
        /// This is the extesion for the cache control files... those used by the tenant invalidate cache, etc...
        /// </summary>
        public const string CACHE_CONTROL_FILE_EXT = ".osc";

        private static string RetrievedSessionSize = "RetrievedSessionSize";
        public static int GetRetrievedSessionSize() {
            if (HttpContext.Current.Items[RetrievedSessionSize] == null) {
                return 0;
            } else {
                return (int)HttpContext.Current.Items[RetrievedSessionSize];
            }
        }

        public static void SetRetrievedSessionSize(HttpContext context, int val) {
            context.Items[RetrievedSessionSize] = val;
        }

        public static void IncrementRetrievedSessionSize(int val) {
            HttpContext.Current.Items[RetrievedSessionSize] = GetRetrievedSessionSize() + val;
        }

        private static string RetrievedSessionRequests = "RetrievedSessionRequests";

        public static int GetRetrievedSessionRequests() {
            if (HttpContext.Current.Items[RetrievedSessionRequests] == null) {
                return 1;
            } else {
                return (int)HttpContext.Current.Items[RetrievedSessionRequests];
            }
        }

        public static void IncrementRetrievedSessionRequests() {
            HttpContext.Current.Items[RetrievedSessionRequests] = GetRetrievedSessionRequests() + 1;
        }

        private static string ViewstateSize = "ViewstateSize";
        public static int GetViewstateSize() {
            if (HttpContext.Current.Items[ViewstateSize] == null) {
                return 0;
            } else {
                return (int)HttpContext.Current.Items[ViewstateSize];
            }
        }
        public static void SetViewstateSize(int val) {
            HttpContext.Current.Items[ViewstateSize] = val;
        }

        public static string ExecuteDataBind(EventHandler databind, object sender) {
            return ExecuteDataBind(databind, sender, null);
        }

        public static string ExecuteDataBind(EventHandler databind, object sender, EventArgs args) {
            databind(sender, args);
            return string.Empty;
        }

        private static long TicksFrom1900_3_1 = new DateTime(1900, 3, 1).Ticks;

        public static object ExcelFixWrongDateTimeVals(object val) {
            if (val is DateTime && ((DateTime)val).Ticks < TicksFrom1900_3_1) {
                val = ((DateTime)val).AddDays(-1);
            }
            return val;
        }

        public static string EncodeFilenameForDownload(string filename) {
            return HttpUtility.UrlEncode(filename).Replace("+", " ");
        }

        // #155815 Removed the regex aplied to the filename to alow more characters.
        // According to this (http://tools.ietf.org/html/rfc822#section-3.1) we can use double quotes to do that in the header.
        // Now it apply this regex [\*\|\\:\<">?/] to the original filename, writing the result of the regex.replace between double quotes.
        public static string EscapeFilenameForDownload(string filename) {
            return Regex.Replace(filename.Trim(), "[\\*\\|:<>\\\"\\\\?/\\r\\n]", "", RegexOptions.Singleline);
        }

        public static readonly string LateLoadBinariesDirectory = Constants.ApplicationsLateLoadLibDirectory;

        public static readonly string ExtensionBinariesDirectory = LateLoadBinariesDirectory;

        public static bool IsDefaultEncodingString(byte[] data) {
            if (data.Length > 2) {
                // The UTF-8 identifier is the Unicode byte order mark (0xFEFF) written in UTF-8 (0xEF 0xBB 0xBF).
                return (0xff & data[0]) == 0xEF && (0xff & data[1]) == 0xBB && (0xff & data[2]) == 0xBF;
            }
            return false;
        }


        public static List<IPAddress> GetMachineOwnAddresses() {
            var ranges = new List<IPAddress>();

            string hostname = Dns.GetHostName();
            var machineAddresses = Dns.GetHostEntry(hostname);

            foreach (var ipaddr in machineAddresses.AddressList) {
                ranges.Add(ipaddr);
            }
            ranges.Add(IPAddress.Parse("127.0.0.1"));
            ranges.Add(IPAddress.Parse("::1"));
            return ranges;
        }

        private static List<IPAddressRange> InitIPAddressRanges(string ipList) {
            var result = new List<IPAddressRange>();
            if (ipList != null) {
                IPAddressRange parsedIPRange = null;
                foreach (string ip in ipList.Split(';')) {
                    if (IPAddressRange.TryParse(ip.Trim(), out parsedIPRange)) {
                        result.Add(parsedIPRange);
                    }
                }
            }
            if (!result.IsEmpty()) {
                foreach (IPAddress addr in GetMachineOwnAddresses()) {
                    result.Add(new IPAddressRange(addr));
                }
            }
            return result;
        }


        private static CacheWithClear<List<IPAddressRange>> InternalIPAddressRanges = new CacheWithClear<List<IPAddressRange>>(InitInternalIPAddressRanges);
        private static List<IPAddressRange> InitInternalIPAddressRanges() {
            return InitIPAddressRanges(RuntimePlatformSettings.InternalNetwork.IPAdressList.GetValue());
        }


        private static CacheWithClear<List<IPAddressRange>> TrustedProxyAddressRanges = new CacheWithClear<List<IPAddressRange>>(InitTrustedProxyAddressRanges);
        private static List<IPAddressRange> InitTrustedProxyAddressRanges() {
            return InitIPAddressRanges(RuntimePlatformSettings.InternalNetwork.TrustedProxyAddresses.GetValue());
        }


        private static CacheWithClear<List<string>> InternalIPAddresses = new CacheWithClear<List<string>>(InitInternalIPAddresses);
        private static List<string> InitInternalIPAddresses() {
            var tmp = new List<string>();
            string ipList = RuntimePlatformSettings.InternalNetwork.IPAdresses.GetValue();
            if (ipList != null) {
                foreach (string ip in ipList.Split(';')) {
                    if (ip != string.Empty) {
                        if (IPAddressValidationLegacy(ip.Trim())) {
                            tmp.Add(ip.Trim());
                        }
                    }
                }
            }
            return tmp;
        }


        public static ApplicationServerStack getServerStack() {
            return ApplicationServerStack.Net;
        }

        //#49674
        public static readonly string SessionPrefixDotNET = "(S(";
        public static readonly string SessionSuffixDotNET = "))";

        public static string SessionPrefix {
            get {
                return SessionPrefixDotNET;
            }
        }

        public static string SessionSuffix {
            get {
                return SessionSuffixDotNET;
            }
        }

        [Obsolete("Please use GetLibFileExtension()")]
        public static string GetLibFileExtension(ApplicationServerKind serverKind) {
            return GetLibFileExtension();
        }

        public static string GetLibFileExtension() {
            return ".dll";
        }

        [Obsolete("Please use GetUIFileExtension()")]
        public static string GetUIFileExtension(ApplicationServerKind serverKind) {
            return GetUIFileExtension();
        }

        public static string GetUIFileExtension() {
            return ".ascx";
        }

        [Obsolete("Please use GetLibDirectoryName()")]
        public static string GetLibDirectoryName(ApplicationServerKind serverKind) {
            return GetLibDirectoryName();
        }

        public static string GetLibDirectoryName() {
            return Constants.ApplicationsLibDirectory;
        }

        [Obsolete("Please use GetUIDirectoryName()")]
        public static string GetUIDirectoryName(ApplicationServerKind serverKind) {
            return GetUIDirectoryName();
        }

        public static string GetUIDirectoryName() {
            return "";
        }

        [Obsolete("Please use GetWidgetsDirectoryName()")]
        public static string GetWidgetsDirectoryName(ApplicationServerKind serverKind) {
            return GetWidgetsDirectoryName();
        }

        public static string GetWidgetsDirectoryName() {
            return "Blocks";
        }

        public static string GetCodeBehindLibSuffix() {
            return "CodeBehind";
        }

        [Obsolete("Please use GetImagesDirectoryName()")]
        public static string GetImagesDirectoryName(ApplicationServerKind serverKind) {
            return GetImagesDirectoryName();
        }

        public static string GetImagesDirectoryName() {
            return "img";
        }

        public static string RemoveTrailingZeros(string str, NumberFormatInfo formatInfo) {
            int pos;
            if (str == null) {
                return str;
            }
            if (str.IndexOf(formatInfo.NumberDecimalSeparator) == -1) {
                return str;
            }
            pos = str.Length - 1;
            while (str[pos] == '0') {
                pos--;
            }
            // Remove the last .
            if (formatInfo.NumberDecimalSeparator.IndexOf(str[pos]) != -1) {
                pos--;
            }
            str = str.Substring(0, pos + 1);
            return str;
        }

        public static string JavaScriptEscString(string s) {
            return BuiltInFunction.EncodeJavascript(s);
        }

        public static string ConvertCRLFToWhitespace(string text) {
            text = text.Replace("\r\n", " ");
            text = text.Replace("\n", " ");
            text = text.Replace("\r", " ");
            return text;
        }

        public static string ExtendedHtmlEncode(string s) {
            return BuiltInFunction.EncodeHtml(s);
        }

        public static string GetSession(string eSpaceName, string tenantName, bool isMultitenant) {
            string url = "http://localhost/" + eSpaceName + "/_ping.aspx";
            var request = (HttpWebRequest)WebRequest.Create(url);
            request.Method = "HEAD";
            request.AllowAutoRedirect = false;
            HttpWebResponse response = null;
            string session = "";
            try {
                response = (HttpWebResponse)request.GetResponse();
                if (response.StatusCode == HttpStatusCode.Found) {
                    string[] splitRes = response.Headers["Location"].Split(new string[] { RuntimePlatformUtils.SessionPrefix, RuntimePlatformUtils.SessionSuffix }, StringSplitOptions.None); // #49674
                    if (splitRes.Length > 3) {
                        throw (new InvalidOperationException("Result contains parenthesis... " + response.Headers["Location"]));
                    }
                    session = splitRes[1];
                }
            } finally {
                try {
                    if (response != null) {
                        response.Close();
                    }
                } catch {
                }
            }
            return session;
        }

        public static bool TestAndSetTimerNextRun(HeContext heContext, ObjectKey timerKey, int producerEspaceId) {
            return TestAndSetTimerNextRun(heContext, timerKey, producerEspaceId, AppInfo.GetAppInfo().Tenant.Id);
        }

        public static bool TestAndSetTimerNextRun(HeContext heContext, ObjectKey timerKey, int producerEspaceId, int tenantId) {
            using (Transaction privTran = DatabaseAccess.ForRuntimeDatabase.GetCommitableTransaction()) {
                // Check if the timer is running. If so, do nothing and return false
                bool isShared;
                int cyclicJobId = DBRuntimePlatform.Instance.GetCyclicJobId(privTran, producerEspaceId, tenantId, timerKey, out isShared);
                DateTime isRunningSince, lastRun, nextRun;
                string schedule, isRunBy;
                bool result = false;
                if (DBRuntimePlatform.Instance.GetCyclicJobForUpdate(privTran, cyclicJobId, isShared, out isRunningSince, out schedule,
                    out lastRun, out nextRun, out isRunBy)) {

                    result = isRunningSince == BuiltInFunction.NullDate();
                    DBRuntimePlatform.Instance.UpdateCyclicJob(privTran, cyclicJobId, isShared);
                    privTran.Commit();
                }
                return result;
            }
        }

        [Obsolete("Deprecated. Please get tenantId and eSpaceId from session.")]
        public static void GetRunningIDs(int producerEspaceId, out int tenantId, out int eSpaceId) {
            var app = AppInfo.GetAppInfo();
            tenantId = app.Tenant.Id;
            eSpaceId = producerEspaceId;
        }

        public static bool CompareByteArrays(byte[] arr1, byte[] arr2) {
            if (arr1.Length != arr2.Length) {
                return false;
            }
            for (int i = 0; i < arr1.Length; i++) {
                if (arr1[i] != arr2[i]) {
                    return false;
                }
            }
            return true;
        }

        private static bool IPAddressValidation(string ipAddress, out IPAddress address) {
            return IPAddress.TryParse(ipAddress, out address);
        }

        public static bool IPAddressIsValidIPv4(string ipAddress) {
            var m = Regex.Match(
                ipAddress,
                "^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$",
                RegexOptions.IgnoreCase | RegexOptions.Singleline);
            return m.Success;
        }

        public static bool IPAddressIsValidIPv6(string ipAddress) {
            var m1 = Regex.Match(
                ipAddress,
                "\\A((?:[0-9A-Fa-f]{1,4}(?::[0-9A-Fa-f]{1,4})*)?) ::((?:[0-9A-Fa-f]{1,4}:)*)(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)(\\.(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)){3}(?:%[0-9A-Za-z]*)?\\z",
                RegexOptions.IgnoreCase | RegexOptions.Singleline);

            var m2 = Regex.Match(
                ipAddress,
                "\\A((?:[0-9A-Fa-f]{1,4}(?::[0-9A-Fa-f]{1,4})*)?) ::((?:[0-9A-Fa-f]{1,4}:)*)(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)(\\.(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)){3}(?:%[0-9A-Za-z]*)?\\z",
                RegexOptions.IgnoreCase | RegexOptions.Singleline);

            var m3 = Regex.Match(
                ipAddress,
                "\\A((?:[0-9A-Fa-f]{1,4}(?::[0-9A-Fa-f]{1,4})*)?)::((?:[0-9A-Fa-f]{1,4}(?::[0-9A-Fa-f]{1,4})*)?)(?:%[0-9A-Za-z]*)?\\z",
                RegexOptions.IgnoreCase | RegexOptions.Singleline);

            var m4 = Regex.Match(
                ipAddress,
                "\\A(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}(?:%[0-9A-Za-z]*)?\\z",
                RegexOptions.IgnoreCase | RegexOptions.Singleline);

            return m1.Success || m2.Success || m3.Success || m4.Success;
        }

        private static bool IPAddressValidationLegacy(string ipAddress) {
            var m = Regex.Match(
                ipAddress,
                @"(^(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])$)|" +
                    @"(^(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\.{0,1}$)|" +
                    @"(^(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\.{0,1}$)|" +
                    @"(^(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\.{0,1}$)",
                RegexOptions.IgnoreCase | RegexOptions.Singleline);
            return m.Success;
        }

        private static bool IPAddressValidation(string ipAddress) {
            IPAddress dummy;
            return IPAddressValidation(ipAddress, out dummy);
        }

        public static bool InternalAddressIdentification(HttpRequest request) {
            // If both features are disabled, we just use UserHostAddress which was the old behavior (dumped by the compiler).
            var requestAddress = request.UserHostAddress;

            if (RuntimePlatformSettings.InternalNetwork.EnableTrustedProxies.GetValue() ||
                RuntimePlatformSettings.InternalNetwork.EnableBehaviour.GetValue()) {
                requestAddress = GetRequestRealIP(request);
            }

            return InternalAddressIdentification(requestAddress);
        }

        public static void ClearInternalNetworkSettings() {
            InternalIPAddresses.Clear();
            InternalIPAddressRanges.Clear();
            TrustedProxyAddressRanges.Clear();
        }

        // Avoid using this method directly. Use the one that receives HttpRequest instead.
        public static bool InternalAddressIdentification(string ipAddress) {

            if (RuntimePlatformSettings.InternalNetwork.EnableBehaviour.GetValue()) {
                IPAddress ip = null;

                var internalIpAddressRanges = InternalIPAddressRanges.GetValue();

                if (IPAddressValidation(ipAddress, out ip)) {
                    foreach (var iprange in internalIpAddressRanges) {
                        if (iprange.Contains(ip)) {
                            return true;
                        }
                    }
                }

                return internalIpAddressRanges.Count == 0;

            } else {

                var addresses = InternalIPAddresses.GetValue();
                foreach (string ip in addresses) {
                    if (ipAddress.StartsWith(ip)) {
                        return true;
                    }
                }
                return (addresses.Count == 0);
            }
        }

        public static string BitToSSBoolean(object field) {
            return (Convert.ToBoolean(field)) ? "Yes" : "No";
        }

        /// <summary>
        /// Convert an object to string
        /// To be used for saving values in a database string field
        /// </summary>
        /// <param name="val">Object to be converted into a String.</param>
        /// <returns>A String representing the given object</returns>
        public static string ConvertToString(object val) {
            if (val is DateTime) {
                return ((DateTime)val).ToString(Constants.DateTimeFormat, Constants.DateTimeFormatProvider);
            } else if (val is decimal) {
                return BuiltInFunction.DecimalToText((decimal)val);
            } else if (val is bool) {
                return ((bool)val) ? "True" : "False";
            } else {
                return val.ToString();
            }
        }

        /// <summary>
        /// Convert an string to object.
        /// To be used for retrieve values from a database string field
        /// </summary>
        /// <param name="val">String to be converted</param>
        /// <param name="datatype">The runtime string representation of the desired datatype.</param>
        /// <returns>An object created from the given String based on the data type.</returns>
        public static object ConvertFromString(string val, string datatype) {
            switch (datatype) {
                case "rtText":
                case "rtPhoneNumber":
                case "rtEmail":
                    return val;
                case "rtInteger":
                    if (val == string.Empty) {
                        val = "0";
                    }
                    return Convert.ToInt32(val);
                case "rtLongInteger":
                    if (val == string.Empty) {
                        val = "0";
                    }
                    return Convert.ToInt64(val);
                case "rtDecimal":
                case "rtCurrency":
                    if (val == string.Empty) {
                        val = "0.0";
                    }
                    return ScriptableBuiltInFunction.TextToDecimal(val);
                case "rtBoolean":
                    if (val == string.Empty) {
                        val = "true";
                    }
                    return val.ToLower() == "true";
                case "rtDateTime":
                    if (val == "") {
                        val = "1900-01-01 00:00:00";
                    }
                    return ScriptableBuiltInFunction.TextToDateTime(val);
                case "rtDate":
                    if (val == "") {
                        val = "1900-01-01";
                    }
                    return ScriptableBuiltInFunction.TextToDate(val);
                case "rtTime":
                    if (val == "") {
                        val = "00:00:00";
                    }
                    return ScriptableBuiltInFunction.TextToTime(val);
                default:
                    throw (new ArgumentException("Don't know how to convert " + datatype));
            }
        }

        //TODO RRTC This should probably be deprecated but do we have an alternative for our clients?
        [Obsolete]
        public static string NoNull(string inStr) {
            return inStr ?? string.Empty;
        }

        [Obsolete("Use StringUtils.Left")]
        public static string Trunc(string s, int len) {
            return s.Left(len);
        }

        [Obsolete("Check for null value and use StringUtils.Left")]
        public static string TruncNoNull(string str, int maxSize) {
            return NoNull(str).Left(maxSize);
        }

        public static void RedirectAndroidDownloadToExternalPage(string url) {
            var context = HttpContext.Current;
            var response = context.Response;
            response.Clear();
            response.StatusCode = 302;
            url = response.ApplyAppPathModifier(url);
            response.StatusDescription = "Found";
            response.AddHeader("Location", url);
            response.CacheControl = "private";
            response.Write("<html><head><title>No title</title></head><body><h2>Object moved to <a href='" + HttpUtility.HtmlEncode(url) + "'>here</a>.</h2></body></html>\r\n");
            response.Flush();
        }

        private struct ActionAndBlockReferencesIds {
            public readonly int id, versionId;
            public ActionAndBlockReferencesIds(int id, int versionId) {
                this.id = id;
                this.versionId = versionId;
            }
        }

        private static void AddActionAndBlockReferencesEspaceIdsRecurse(int versionId, int eSpaceId, ArrayList visited, Transaction tran) {
            visited.Add(eSpaceId);

            LinkedList<ActionAndBlockReferencesIds> ids = new LinkedList<ActionAndBlockReferencesIds>();
            using (IDataReader reader = DBRuntimePlatform.Instance.GetActionAndBlockReferencesInfo(tran, versionId)) {
                ids.AddLast(new ActionAndBlockReferencesIds(Convert.ToInt32(reader["ID"]), Convert.ToInt32(reader["VERSION_ID"])));
            }

            foreach (ActionAndBlockReferencesIds id in ids) {
                int refEspaceId = id.id;
                int refVersionId = id.versionId;
                if (!visited.Contains(refEspaceId)) {
                    AddActionAndBlockReferencesEspaceIdsRecurse(refVersionId, refEspaceId, visited, tran);
                }
            }
        }

        public static int GetScriptTimeout()
        {
            return HttpContext.Current.Server.ScriptTimeout;
        }

        public static void SetScriptTimeout(int timeoutInSecs) {
            if (timeoutInSecs == 0) {
                throw new ArgumentOutOfRangeException("timeoutInSecs", "The timeout for HTTP requests should be different from 0 (zero).");
            }

            HttpContext.Current.Server.ScriptTimeout = timeoutInSecs;
        }

        public static void SetSessionItemTimeout(int timeoutInMins) {
            // obtain current session
            System.Web.SessionState.HttpSessionState session = HttpContext.Current.Session;
            // check if it is necessary to set the new timeout
            if (session != null && session.Timeout != timeoutInMins) {
                session.Timeout = timeoutInMins;
                SqlSessionStateStore.SetItemTimeout(session.SessionID, timeoutInMins);
            }
        }

        public static bool IsSocketException(Exception ex) {
            return ex is System.Net.Sockets.SocketException;
        }

        public static bool isWindows() {
            return true;
        }

        public static bool TestAndSetProducerSession(string eSpaceName) {
            if (HttpContext.Current.Session != null) {
                HeContext heContext = AppInfo.GetAppInfo().OsContext;
                return heContext.Session.TestAndSetNeedsSessionStart(eSpaceName);
            }
            return false;
        }

        public static string connectionStringJoin(string conStr, string parameters) {
            if (!conStr.TrimEnd().EndsWith(";")) {
                conStr += ";";
            }

            return conStr + (parameters ?? "");
        }

        public static bool RequestIsSecure(HttpRequest request) {
            return RequestIsSecure(request, true);
        }

        public static bool RequestIsSecure(HttpRequest request, bool allowInsecureRequestsForLoopbackAddr) {
            var appInfo = AppInfo.GetAppInfo();
            var isMobileRuntime = appInfo != null && appInfo.IsMobileRuntime;

            // when we mark servicecenter accessible as https only, we need to consider localhost requests as secure for scinstall to work
            if ((allowInsecureRequestsForLoopbackAddr || isMobileRuntime) && NetworkInterfaceUtils.IsLoopbackAddress(request.UserHostAddress)) {
                return true;
            }

            return RequestIsHttps(request);
        }


        // Returns the protocol for the current request, as seen in the browser.
        public static bool RequestIsHttps(HttpRequest request) {
            if (request.IsSecureConnection) {
                return true;
            }

            // Check if we have the special http to https header
            string httpToHttpsProxyHeader = RuntimePlatformSettings.Misc.HTTPtoHTTPSproxyHeader.GetValue();

            if (!httpToHttpsProxyHeader.IsEmpty()) {
                string[] headerParts = httpToHttpsProxyHeader.Split(new char[] { ':' }, 2);
                string requestHeaderValue = request.Headers[headerParts[0].Trim()];

                if (requestHeaderValue == null) {
                    return false;   // The header isn't present in the request
                } else if (headerParts.Length == 1) {
                    return true;    // The header is present and we didn't specify a value for it...
                } else {
                    // Check if the header value is the one we specified...
                    return requestHeaderValue.ToLowerInvariant().Trim() == headerParts[1].Trim();
                }
            }

            return false;
        }

        public static void AddNoCacheHeaders(HttpResponse response) {
            // see: http://stackoverflow.com/a/2068407
            response.AddHeader("Cache-Control", "no-cache, no-store, must-revalidate");	// HTTP 1.1
            response.AddHeader("Pragma", "no-cache"); // HTTP 1.0
            response.AddHeader("Expires", "0"); // Proxies
        }

        public static string GetURL(string url, BaseAppUtils appUtils, string overrideApplicationUrl) {
            string finalUrl = url;
            // Check if we have the special http to https header
            string httpToHttpsProxyHeader = RuntimePlatformSettings.Misc.HTTPtoHTTPSproxyHeader.GetValue();

            if (!httpToHttpsProxyHeader.IsEmpty() && !Uri.IsWellFormedUriString(url, UriKind.Absolute)) {
                var bookmarkableURI = new Uri(BuiltInFunction.GetBookmarkableURL());

                if (url.StartsWith("/")) {
                    finalUrl = bookmarkableURI.GetLeftPart(UriPartial.Authority) + url;
                } else if (appUtils != null) {
                    string applicationUrl = appUtils.getImagePath(/*internalAccess*/false, /*includeSessionIdIfNeeded*/false, overrideApplicationUrl);
                    finalUrl = bookmarkableURI.GetLeftPart(UriPartial.Authority) + applicationUrl + url;
                }
            }
            return finalUrl;
        }

        public static string GetRequestURL(HttpRequest request) {
            //the mapping of Request.Url was fixed to add queryString (to become equivalent to dotnet)
            // but this method is used in External Extensions that in Java already are considering that querystring is not returned and append it @ the end
            Uri requestUrl = request.Url;

            // Change the scheme of the request url to reflect the RequestIsSecure
            return (RequestIsHttps(request) ? "https" : "http") + requestUrl.ToString().Substring(requestUrl.Scheme.Length);
        }

        public static string CheckUriSecurity(HttpRequest request, string uri) {
            // DO NOT replace with one receiving an Uri .. the "new Uri(uri)" might change the uri
            if (RequestIsHttps(request) && uri.ToLower().StartsWith("http")) {
                return "https" + uri.Substring(uri.IndexOf(":"));
            }
            return uri;
        }

        public static Process LaunchProcess(string command, string commandParams, string path, ProcessPriorityClass priority, string username, string domain, string password) {
            return SystemProcess.Launch(command, commandParams, path, priority, username, domain, password).Process;
        }

        public static Process LaunchProcess(string command, string commandParams, string path, ProcessPriorityClass priority) {
            return SystemProcess.Launch(command, commandParams, path, priority).Process;
        }

        // launches a process
        public static Process LaunchProcess(string command, string commandParams, bool hidden, ProcessPriorityClass priority) {
            return SystemProcess.Launch(command, commandParams, hidden, priority).Process;
        }

        [Obsolete("Use LaunchProcess(String command, String commandParams, bool hidden, ProcessPriorityClass priority) instead.")]
        public static Process LaunchProcess(string command, string commandParams, bool hidden) {
            return SystemProcess.Launch(command, commandParams, hidden, ProcessPriorityClass.Normal).Process;
        }

        // waits for the end of a process maxTime time
        public static bool ProcessEnded(Process process, int maxTime) {
            return process.WaitForExit(maxTime);
        }

        public static string GetEspacePrettyNamePath(string eSpaceName, HeContext heContext) {
            if (heContext.OsISAPIFilter.IsEnabled) {
                string lCaseESpaceName = eSpaceName.ToLower();
                if (heContext.GetESpacePrettyNames.ContainsKey(lCaseESpaceName)) {
                    return (heContext.GetESpacePrettyNames[lCaseESpaceName]);
                }
            }
            return "/" + eSpaceName + "/";
        }

        public static List<string> GetPageRules(int eSpaceId, string PageName, HeContext heContext) {
            if (heContext.OsISAPIFilter.IsEnabled) {
                string lCasePageName = PageName.ToLower();
                if (heContext.GetPageRules(eSpaceId).ContainsKey(lCasePageName)) {
                    return heContext.GetPageRules(eSpaceId)[lCasePageName];
                }
                // Remove any flow prefix in the name and try again: WebFlow1.MyPage -> MyPage
                int NonPrefixedPos = lCasePageName.IndexOf('.');
                if (NonPrefixedPos != -1) {
                    lCasePageName = lCasePageName.Substring(NonPrefixedPos + 1);
                    if (heContext.GetPageRules(eSpaceId).ContainsKey(lCasePageName)) {
                        return heContext.GetPageRules(eSpaceId)[lCasePageName];
                    }
                }
            }
            return null;
        }

        public static string FixHostIPForIPV6(string host) {
            return RuntimeEnvironment.FixHostIPForIPV6(host);
        }

        private static string GetRequestRealIPOldBehaviour(HttpRequest request) {
            string requestIp = "";
            requestIp = request.Headers.Get("X-Forwarded-For");
            if (requestIp != null && requestIp.IndexOf(",") > 0)
                requestIp = requestIp.Substring(0, requestIp.IndexOf(",")).Trim();
            else if (string.IsNullOrEmpty(requestIp) || requestIp.ToLower() == "unknown")
                requestIp = request.UserHostAddress;
            return requestIp;
        }

        public static string GetRequestRealIP(HttpRequest request) {
            //Both GetRequestIPAddress from OMLProcessor.xif and GetIP from HTTPRequestHandler.xif call this method
            //Lifetime and ServiceCenter use the action from OMLProcessor and Users.oml uses the one from HTTPRequestHandler 

            string requestIp = "";
            string firstForwardedAddress = string.Empty;
            bool allForwardedAddressTrusted = false;

            if (RuntimePlatformSettings.InternalNetwork.EnableTrustedProxies.GetValue()) {
                if (IsFromTrustedProxy(request.UserHostAddress)) {
                    requestIp = GetTrustedAddressFromForwardHeader(request.Headers.Get("X-Forwarded-For"), out allForwardedAddressTrusted, out firstForwardedAddress);
                }

                if (requestIp.IsNullOrEmpty()) {
                    // RPD-3391 - request IP is null either when X-Forwarded-For header is empty or if all mentioned IPs in header X-Forwarded-For are Trusted Proxies
                    // However, if all IPs from X-Forwarded-For header are Trusted Proxies, then we want to return the "oldest" IP in the header as it might be an Internal Network address
                    if (allForwardedAddressTrusted && RuntimePlatformSettings.InternalNetwork.EnableFallbackToFirstTrustedWhenAllForwardedIPsTrusted.GetValue()) {
                        return firstForwardedAddress;
                    }
                    return request.UserHostAddress;
                } else {
                    return requestIp;
                }
            } else {
                return GetRequestRealIPOldBehaviour(request);
            }
        }

        public static string GetTrustedAddressFromForwardHeader(string header, out bool allForwardedAddressTrusted, out string firstForwardedAddress) {
            allForwardedAddressTrusted = false;
            firstForwardedAddress = string.Empty;
            if (header.IsNullOrEmpty()) {
                return null;
            }
            string requestIp = string.Empty;
            string[] headerAddresses = header.Split(',');
            Array.Reverse(headerAddresses);
            foreach (string headerAddress in headerAddresses) {
                string address = headerAddress.Trim();
                firstForwardedAddress = address;
                if (IsFromTrustedProxy(address)) {
                    continue;
                } else {
                    requestIp = address;
                    break;
                }
            }
            if (!requestIp.IsEmpty() && IPAddressValidation(requestIp)) {
                return requestIp;
            }
            allForwardedAddressTrusted = true;
            return null;
        }

        public static bool IsFromTrustedProxy(string requestIPAddress) {
            IPAddress requestIp;

            if (!IPAddressValidation(requestIPAddress, out requestIp)) {
                return false;
            }

            var trustedProxyAddresses = TrustedProxyAddressRanges.GetValue();
            foreach (var range in trustedProxyAddresses) {
                if (range.Contains(requestIp)) {
                    return true;
                }
            }

            return false;
        }
        public static byte[] TryGetResourceBinary(string resource) {
            return GetResourceBinary(resource, String.Empty, /*throwOnError*/false);
        }

        public static byte[] GetResourceBinary(string resource, string hiddenResource) {
            return GetResourceBinary(resource, hiddenResource, /*throwOnError*/true);
        }

        private static byte[] GetResourceBinary(string resource, string hiddenResource, bool throwOnError) {
            try {
                return GetResourceBinaryInternal(resource, hiddenResource, throwOnError);
            } catch (Exception e) {
                if (throwOnError) {
                    throw new InvalidOperationException("Could not access resource '{0}'. Make sure the referenced resource is not outdated.".F(resource), e);
                }
                return null;
            }
        }

        private static byte[] GetResourceBinaryInternal(string resource, string hiddenResource, bool throwOnError) {
            string filePathHidden = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, hiddenResource);
            if (File.Exists(filePathHidden)) {
                return File.ReadAllBytes(filePathHidden);
            }

            string filePath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, resource);
            if (!throwOnError && !File.Exists(filePath)) {
                return null;
            }
            return File.ReadAllBytes(filePath);
        }

        private static readonly Dictionary<string, string> extensionsToMimeTypes = new Dictionary<string, string>() {
            { "bmp", "image/bmp" },
            { "gif", "image/gif" },
            { "jpg", "image/jpg" },
            { "jpeg", "image/jpeg" },
            { "png", "image/png" },
        };

        private static readonly byte[] BmpMagicNumbers = new byte[] { 66, 77 };
        private static readonly byte[] GifMagicNumbers = new byte[] { 71, 73, 70 };
        private static readonly byte[] PngMagicNumbers = new byte[] { 137, 80, 78, 71 };
        private static readonly byte[] IcoMagicNumbers = new byte[] { 0, 0, 1, 0 };

        private static readonly byte[] JpgMagicNumbersRaw = new byte[] { 255, 216, 255, 219 };
        private static readonly byte[] JpgMagicNumbersJFIF = new byte[] { 255, 216, 255, 224 };
        private static readonly byte[] JpgMagicNumbersEXIF = new byte[] { 255, 216, 255, 225 };

        private static readonly byte[] TiffLilEndianMagicNumbers = new byte[] { 73, 73, 42, 0 };  //for intel
        private static readonly byte[] TiffBigEndianMagicNumbers = new byte[] { 77, 77, 0, 42 };  //for motorola

        // WEBP magic number format - 52 49 46 46 ?? ?? ?? ?? 57 45 42 50 (ASCII - RIFF????WEBP)
        // Where ?? ?? ?? ?? is reserved for storing the file size.
        //private static readonly byte[] riffHeader = new byte[] { 82, 73, 70, 70 }; // RIFF Chunk Four CC
        //private static readonly int fileSizeByteLength = 4;                     // Number of bytes reserved for recording filesize
        //private static readonly byte[] webpHeader = new byte[] { 87, 69, 66, 80 }; // WEBP Chunk Payload

        public static string GetMIMEType(byte[] bytes, out bool isValidImage) {

            isValidImage = true;

            /* We don't support Webp yet since it is only available on Chrome.
             *
            if (riffHeader.SequenceEqual(bytes.Take(riffHeader.Length))
                && webpHeader.SequenceEqual(bytes.Skip(riffHeader.Length + fileSizeByteLength).Take(webpHeader.Length))) {
                return "image/webp";
            }
            */

            if (JpgMagicNumbersRaw.SequenceEqual(bytes.Take(JpgMagicNumbersRaw.Length)) 
                || JpgMagicNumbersJFIF.SequenceEqual(bytes.Take(JpgMagicNumbersJFIF.Length))
                || JpgMagicNumbersEXIF.SequenceEqual(bytes.Take(JpgMagicNumbersEXIF.Length))) {
                return "image/jpg";
            }

            if (TiffLilEndianMagicNumbers.SequenceEqual(bytes.Take(TiffLilEndianMagicNumbers.Length))
                || TiffBigEndianMagicNumbers.SequenceEqual(bytes.Take(TiffBigEndianMagicNumbers.Length))) {
                return "image/tiff";
            }

            if (BmpMagicNumbers.SequenceEqual(bytes.Take(BmpMagicNumbers.Length))) {
                return "image/bmp";
            }

            if (GifMagicNumbers.SequenceEqual(bytes.Take(GifMagicNumbers.Length))) {
                return "image/gif";
            }

            if (PngMagicNumbers.SequenceEqual(bytes.Take(PngMagicNumbers.Length))) {
                return "image/png";
            }

            if (IcoMagicNumbers.SequenceEqual(bytes.Take(IcoMagicNumbers.Length))) {
                return "image/x-icon";
            }

            isValidImage = false;
            return "application/octet-stream";
        }

        private static ICompilerContext compilerContext;

        public static ICompilerContext GetCompilerContext() {
            if (compilerContext == null) {
                compilerContext = new ICompilerContext(
                    RuntimePlatformSettings.Sandbox.SandboxOperating.GetValue(),
                    RuntimePlatformSettings.Sandbox.SandboxBoxesKeyName.GetValue());
            }
            return compilerContext;
        }
        public static string WebPageExtension {
            get {
                return ".aspx";
            }
        }

        public static string GetAdministrationEmail() {
            return RuntimePlatformSettings.Environment.AdministrationEmail.GetValue();
        }

        public static void SetupCurrentThreadCulture() {
            Thread.CurrentThread.CurrentCulture = CultureInfo.GetCultureInfo("en-US");
            Thread.CurrentThread.CurrentUICulture = CultureInfo.GetCultureInfo("en-US");
        }

        public static string GetWebReferenceEffectiveOrDefaultURL(string webrefSSKey, int eSpaceId) {
            bool isDefault;
            return GetWebReferenceEffectiveOrDefaultURL(webrefSSKey, eSpaceId, /*cacheValue*/true, out isDefault);
        }

        public static string GetWebReferenceEffectiveOrDefaultURL(string webrefSSKey, int eSpaceId, out bool isDefault) {
            return GetWebReferenceEffectiveOrDefaultURL(webrefSSKey, eSpaceId, /*cacheValue*/false, out isDefault);
        }

        private static string GetWebReferenceEffectiveOrDefaultURL(string webrefSSKey, int eSpaceId, bool cacheValue, out bool isDefault) {
            bool innerIsDefault = false;
            Func<string> fetchFromDb = () => {
                using (var tran = DatabaseAccess.ForSystemDatabase.GetReadOnlyTransaction()) {
                    using (var reader = DBRuntimePlatform.Instance.GetWebReferenceURLs(tran, webrefSSKey, eSpaceId)) {
                        if (reader.Read()) {
                            // get default url
                            var url = reader.SafeGet<string>("URL");
                            // get effective url
                            var effectiveUrl = reader.SafeGet<string>("Effective_URL");
                            if (effectiveUrl != null) {
                                // #484852 trim to convert oracle " " to ""
                                effectiveUrl = effectiveUrl.Trim();
                            }
                            if (effectiveUrl.IsEmpty()) {
                                innerIsDefault = true;
                                return url;
                            } else {
                                return effectiveUrl;
                            }
                        }
                        return string.Empty;
                    }
                }
            };


            if (cacheValue) {
                isDefault = false;
                return AppCache.GetESpaceCachedValue<string, string>(webrefSSKey, "WebReferenceURLCache", eSpaceId, dummy => fetchFromDb());
            } else {
                var result = fetchFromDb();
                isDefault = innerIsDefault;
                return result;
            }
        }

        public static WebReferenceConfiguration GetWebReferenceLoggingConfiguration(string webrefSSKey, int eSpaceId, string eSpaceKey) {
            return WebReferenceConfiguration.GetCustomClientConfiguration(webrefSSKey, eSpaceId, eSpaceKey);
        }

        public const string EditRecordDefinedInParentScreen = "Parent-Screen";


        public static void LogSlowExtensionCall(DateTime startTime, string description) {
        }

        public static void SaveTemporaryAndroidDownload(string guid, string mimeType, DateTime expireDate, byte[] fileContent, string filename, string disposition) {

            using (var tran = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                var hash = RuntimeCommon.Cryptography.SecureHashHelper.Hash(fileContent);
                DBRuntimePlatform.InsertTemporaryAndroidDownload(tran, guid, mimeType, expireDate, fileContent, hash, filename, disposition);
            }
        }

        public static bool GetTemporaryAndroidDownload(string guid, out string mimeType, out DateTime expireDate, out byte[] fileContent, out string filename, out string disposition) {

            mimeType = null;
            expireDate = DateTime.MinValue;
            fileContent = null;
            filename = null;
            disposition = null;

            using (var tran = DatabaseAccess.ForRuntimeDatabase.GetReadOnlyTransaction()) {
                using (var reader = DBRuntimePlatform.GetTemporaryAndroidDownload(tran, guid)) {
                    if (reader.Read()) {
                        mimeType = reader.SafeGet<string>("MIMETYPE");
                        expireDate = reader.SafeGet<DateTime>("EXPIRES");
                        fileContent = reader.SafeGet<byte[]>("CONTENT");
                        filename = reader.SafeGet<string>("FILENAME");
                        disposition = reader.SafeGet<string>("DISPOSITION");
                        return true;
                    }
                }
            }
            return false;
        }

        [Obsolete("Deprecated. Move to RuntimePlatformUtils.Images.")]
        public static string GetDatabaseImagePath(string entityName, string attributeName, string idValue, string fileName) {
            return Images.GetDatabaseImagePath(entityName, attributeName, idValue, fileName);
        }

        public static RequestTracer GetRequestTracer() {
            if (HttpContext.Current != null) {
                var context = (HeContext)HttpContext.Current.Items["osContext"];
                if (context != null) {
                    return context.RequestTracer;
                }
            }
            return null;
        }

        public static GeneralLog GenerateEspaceInvalidateMessage(string sessionId, int espaceId, int tenantId, int userId, int ownereSpaceId, int ownerTenantId, string extraInfo = "") {
            GeneralLog log = new GeneralLog(DateTime.Now,
                                   sessionId,
                                   ownereSpaceId,
                                   ownerTenantId,
                                   userId,
                                   "Espace invalidate cache for espace with id " + espaceId + " (TenantId: " + tenantId + ") in " + RuntimeEnvironment.MachineName + (extraInfo.IsNullOrEmpty() ? string.Empty : Environment.NewLine + extraInfo),
                                   "USER",
                                   "INVALIDATECACHE", "");
            return log;
        }
    }

    // WARNING:
    // should you change any of these values
    // also check OutSystems.HubEdition.RuntimePlatform.Web.JavaScriptManager.clientScript
    // and change the hardcoded value there!
    public enum CacheInvalidationMangleDepth {
        None = 0,
        PlatformInserted = 10,
        UserCSS = 20,
        All = 1000
    }

    // WARNING: Needs to be sync'ed with Service Center!
    public enum PathRuleKind {
        PassThroughESpace = 1,
        PassThroughVDir = 2,
        ESpacePrettyName = 3,
        Custom = 4
    }

}