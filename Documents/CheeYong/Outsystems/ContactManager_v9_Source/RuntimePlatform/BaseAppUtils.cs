/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections.Generic;
using System.Data;
using System.IO;
using System.Reflection;
using System.Text.RegularExpressions;
using OutSystems.HubEdition.Extensibility.Data.DMLService;
using OutSystems.HubEdition.Extensibility.Data.Platform;
using OutSystems.HubEdition.Extensibility.Data.Platform.DMLService;
using OutSystems.HubEdition.RuntimePlatform.Sql;
using OutSystems.Internal.Db;
using OutSystems.RuntimeCommon;

namespace OutSystems.HubEdition.RuntimePlatform {

    public abstract class BaseAppUtils {

        protected BaseAppUtils() {
        }

        public static string GetPageName(HeContext heContext, int eSpaceId, string page, IList<Pair<string, string>> parameters) {
            return GetPageName(heContext, eSpaceId, page, parameters, /*useParamsOnlyIfNeededForRule*/false);
        }

        public static string GetPageName(HeContext heContext, int eSpaceId, string page, IList<Pair<string, string>> parameters, bool useParamsOnlyIfNeededForRule) {
            string pageTransform = null;
            IList<Pair<string, string>> leftoverParams = parameters;
            List<string> rules = RuntimePlatformUtils.GetPageRules(eSpaceId, page, heContext);

            if (rules != null) {
                foreach (string transform in rules) {
                    pageTransform = transform.Substring(1);
                    leftoverParams = new List<Pair<string, string>>();
                    foreach (Pair<string, string> parm in parameters) {
                        string markedParam = "{" + parm.First + "}";
                        int paramPos = pageTransform.IndexOf(markedParam);

                        if (paramPos == -1) {
                            leftoverParams.Add(parm);
                        } else {
                            // It shouldn't be possible to get here with parm.Second == null (these should always be leftoverParms)
                            //  but just to be on the safe side...
                            pageTransform = pageTransform.Replace(markedParam, parm.Second != null ? parm.Second : "");
                        }
                    }

                    if (pageTransform.IndexOf('{') == -1) {
                        break;
                    } else {
                        pageTransform = null;
                    }
                }
            }

            if (pageTransform == null) {
                pageTransform = page + RuntimePlatformUtils.WebPageExtension;
                leftoverParams = parameters;
            }

            if (leftoverParams.Count > 0 && !useParamsOnlyIfNeededForRule) {
                pageTransform += "?";

                foreach (Pair<string, string> parm in leftoverParams) {
                    if (!string.IsNullOrEmpty(parm.First)) {
                        pageTransform += parm.First + "=" + (parm.Second ?? string.Empty) + "&";
                    }
                }

                pageTransform = pageTransform.TrimEnd('&', '?');
            }

            return pageTransform;
        }

        public static bool getResourceFileContent(out string store, string path) {
            store = "";
            if (String.IsNullOrEmpty(path) || !(path.EndsWith(".css") || path.EndsWith(".js"))) {
                return false;
            }

            string assembly = Path.GetDirectoryName(Assembly.GetCallingAssembly().CodeBase).Replace("file:\\", "");
            string fullPath = Path.Combine(Directory.GetParent(assembly).FullName, path);

            if (File.Exists(fullPath)) {
                try {
                    using(StreamReader resourceStream = File.OpenText(fullPath)) {
                        string resource = resourceStream.ReadToEnd();
                        if (!String.IsNullOrEmpty(resource)) {
                            store += resource;
                            if (!resource.EndsWith(Environment.NewLine)) {
                                store += Environment.NewLine;
                            }
                        }
                    }
                } catch {
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// Due to differences in url escape between xhtml and wml (adapters related). Returns true or false
        /// </summary>
        /// <param name="req">current Request</param>
        /// <returns>True if the URL must be encodes, false otherwise.</returns>
        public static bool UrlAttributeMustBeEncoded(System.Web.HttpRequest req) {
            bool res = false;
            if (req.Browser.IsMobileDevice) {
                string prefRendType = req.Browser.PreferredRenderingType;
                if (prefRendType.StartsWith("xhtml") || prefRendType.StartsWith("html")) {
                    res = false;
                } else {
                    res = true;
                }
            }
            return res;
        }

        // This pattern is also present in service studio cnode:validateSql.
        private static Regex _notAllowedTableNamesRegex;
        protected static Regex NotAllowedTableNamesRegex { get { return _notAllowedTableNamesRegex ?? (_notAllowedTableNamesRegex = new Regex("(^|\\s|\\.)(\\[|\"|)(ossys_|osltm_|oslog_|osevt_|osusr_|osext_)", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant | RegexOptions.Compiled)); } }

        private static Regex _entitiesInOrderByRegex;
        protected static Regex EntitiesInOrderByRegex { get { return _entitiesInOrderByRegex ?? (_entitiesInOrderByRegex = new Regex(@"(\{\w+\}|\w+\.)", RegexOptions.CultureInvariant | RegexOptions.Compiled)); } }

        private static Regex _dynOrderByValidateRegex;
        protected static Regex DynOrderByValidateRegex { get { return _dynOrderByValidateRegex ?? (_dynOrderByValidateRegex = new Regex(@"((((\{\w+\})|(\w+)).)?((\[\w+\])|(\w+))(( )+(desc|asc))?)(( )*,( )*(((\{\w+\})|(\w+)).)?((\[\w+\])|(\w+))(( )+(desc|asc))?)*", RegexOptions.IgnoreCase)); } }

        private static Regex _entityAttributesRegex;
        protected static Regex EntityAttributesRegex { get { return _entityAttributesRegex ?? (_entityAttributesRegex = new Regex(@"((\{\w+\}).(\[\w+\]))*", RegexOptions.IgnoreCase)); } }

        private static Regex _aliasAttributesRegex;
        protected static Regex AliasAttributesRegex { get { return _aliasAttributesRegex ?? (_aliasAttributesRegex = new Regex(@"(\w+)(\s*\.\s*((\[\w+\])|(\w+)))", RegexOptions.CultureInvariant | RegexOptions.Compiled)); } }

        private static Regex _attributesRegex;
        protected static Regex AttributesRegex { get { return _attributesRegex ?? (_attributesRegex = new Regex(@"(\[\w+\])", RegexOptions.CultureInvariant | RegexOptions.Compiled)); } }

        private static Regex _orderByDirectionRegex;
        protected static Regex OrderByDirectionRegex { get { return _orderByDirectionRegex ?? (_orderByDirectionRegex = new Regex(@"\b(ASC|DESC)$", RegexOptions.Compiled | RegexOptions.IgnoreCase | RegexOptions.Multiline | RegexOptions.ExplicitCapture)); } }

        private static Regex _controlCharsRegex;
        protected static Regex ControlCharsRegex { get { return _controlCharsRegex ?? (_controlCharsRegex = new Regex(@"[^\P{Cc}\s]", RegexOptions.Compiled)); } }

        public string ReplaceEntityReferences(HeContext heContext, string sql) {
            return new ReplaceEntities(delegate(string entName) {
                return EntityToTablename(entName, GetTenantId(heContext));
            }).ParseSQL(sql);
        }

        public string ReplaceAttributeReferences(HeContext heContext, string sql) {
            return ReplaceAttributeReferences(heContext, sql, false);
        }

        public string ReplaceAttributeReferences(HeContext heContext, string sql, bool allowCommentHints) {
            return new ReplaceAttributes(delegate (string entityName, string attributeName) {
                return EntityAttributeToColumnName(entityName, attributeName);
            }).ParseSQL(sql, allowCommentHints);
        }

        public string ReplaceEntityReferencesKeepCommentHints(HeContext heContext, string sql) {
            return new ReplaceEntities(delegate(string entName) {
                return EntityToTablename(entName, GetTenantId(heContext));
            }).ParseSQL(sql, true);
        }

        public static string ReplaceEntityReferences(string sql, Dictionary<string,string> entitiesTablenames, bool allowCommentHints) {
            return new ReplaceEntities(delegate(string entName) {
                return EntityToTablename(entName.ToLower(), entitiesTablenames);
            }).ParseSQL(sql, allowCommentHints);
        }
        public static string ReplaceAttributeReferences(string sql, Dictionary<Pair<string, string>, string> entityAttributenames, bool allowCommentHints) {
            return new ReplaceAttributes(delegate (string entityName, string attributeName) {
                return EntityAttributeToColumnName(Pair.Create<string,string>(entityName,attributeName), entityAttributenames);
            }).ParseSQL(sql, allowCommentHints);
        }

        public string CheckReadOnlyEntityReferences(string sql) {
            return new CheckReadOnlyEntities(delegate(string entName) {
                return CheckReadOnlyInvalidOperations(entName);
            }).ParseSQL(sql);
        }

        public string CheckReadOnlyEntityReferencesKeepCommentHints(string sql) {
            return new CheckReadOnlyEntities(delegate(string entName) {
                return CheckReadOnlyInvalidOperations(entName);
            }).ParseSQL(sql, /* allowCommentHints */ true);
        }

        public static string CheckReadOnlyEntityReferences(string sql, HashSet<string> readOnlyEntities) {
            return new CheckReadOnlyEntities(delegate(string entName) {
                return CheckReadOnlyInvalidOperations(entName.ToLower(), readOnlyEntities);
            }).ParseSQL(sql);
        }

        public static string CheckReadOnlyEntityReferences(string sql, HashSet<string> readOnlyEntities, bool allowCommentHints) {
            return new CheckReadOnlyEntities(delegate(string entName) {
                return CheckReadOnlyInvalidOperations(entName.ToLower(), readOnlyEntities);
            }).ParseSQL(sql, allowCommentHints);
        }

        protected static bool CheckReadOnlyInvalidOperations(string entity, HashSet<string> readOnlyEntities) {
            return readOnlyEntities.Contains(entity);
        }

        public bool CheckForSelectStatement(string sql) {
            if (!PrepareQueryForCount.IsSelectStatement(sql)) {
                throw new InvalidQueryForCount(sql);
            }
            return true;
        }

        public static string ReplaceEntityIdentifiers(IDMLIdentifiers dmlIdentifiers, string inParam, bool enableFixLiteralsMisinterpretedAsIdentifiers) {
            if (enableFixLiteralsMisinterpretedAsIdentifiers) {
                return new EscapeIdentifier(match => ReplaceAttributeName(dmlIdentifiers, match))
                    .ParseSQL(inParam, true /* allowcommentHints */);
            }
            return inParam;
        }

        public static string ReplaceEntityReferencesInParameter(IDMLIdentifiers dmlIdentifiers, string inParam) {
            return ReplaceEntityReferencesInParameter(dmlIdentifiers, inParam, false);
        }

        public static string ReplaceEntityReferencesInParameter(IDMLIdentifiers dmlIdentifiers, string inParam, bool enableFixLiteralsMisinterpretedAsIdentifiers) {
            var mc = NotAllowedTableNamesRegex.Matches(inParam);
            if (mc.Count > 0) {
                var m = mc[0];
                throw new DataBaseException("'" + m.Groups[2] + m.Groups[3] + "' found in 'Expand Inline' parameter is a reserved prefix");
            }

            var ret = inParam;

            if (!enableFixLiteralsMisinterpretedAsIdentifiers) {
                MatchEvaluator meReplaceAttributeName = match => ReplaceAttributeName(dmlIdentifiers, match);
                ret = AttributesRegex.Replace(ret, meReplaceAttributeName);
            }

            return ret;
        }

        private static string ReplaceAttributeName(IDMLIdentifiers dmlIdentifiers, Match m) {
            string result = m.Value.Substring(1, m.Value.Length - 2);
            // Escape the attribute name
            return dmlIdentifiers.EscapeIdentifier(result);
        }

        private static string ReplaceEntityNameInOrderBy(Match m, string[] entityNames, string[] entityAliases) {
            string result = "";
            string entityName = GetEntityNameFromMatch(m);

            bool found = false;
            for (int i = 0; i < entityNames.Length; i++) {
                if (entityNames[i].EqualsIgnoreCase(entityName)) {
                    found = true;
                    result = entityAliases[i];
                    break;
                }
            }
            if (!found) {
                throw new DataBaseException("'" + entityName + "' found in 'Order By' parameter is an invalid Entity");
            }

            if (m.Value.EndsWith(".")) {
                return result + ".";
            } else {
                return result;
            }
        }

        [Obsolete("ReplaceEntityReferencesInOrderBy is deprecated, please use ReplaceEntityReferencesAndAttributesInOrderBy instead.")]
        public static string ReplaceEntityReferencesInOrderBy(IDMLIdentifiers dmlIdentifiers, string paramValue, string[] entityNames, string[] entityAliases) {
            var attributes = new IDictionary<string, string>[entityNames.Length];
            return ReplaceEntityReferencesAndAttributesInOrderBy(dmlIdentifiers,paramValue,entityNames,entityAliases, attributes);
        }

        public static string ReplaceEntityReferencesAndAttributesInOrderBy(IDMLIdentifiers dmlIdentifiers, string paramValue, string[] entityNames, string[] entityAliases, IDictionary<string, string>[] entityNamesToAttributes) {
            string ret;
            MatchCollection mc;
            Match m;

            paramValue = paramValue.Trim();

            mc = NotAllowedTableNamesRegex.Matches(paramValue);
            if (mc.Count > 0) {
                m = mc[0];
                throw new DataBaseException("'" + m.Groups[2] + m.Groups[3] + "' found in 'Order By' parameter is a reserved prefix");
            }

            if (paramValue != "") {
                mc = DynOrderByValidateRegex.Matches(paramValue);
                if (mc.Count != 1 || mc[0].Value != paramValue) {
                    throw new DataBaseException("Invalid syntax in 'Order By' parameter.");
                }
            }

            MatchEvaluator meReplaceEntityName = match => ReplaceEntityNameInOrderBy(match, entityNames, entityAliases);
            MatchEvaluator meReplaceEntityAttributeName = match => ReplaceEntityAttributesName(dmlIdentifiers, match, entityNames, entityAliases, entityNamesToAttributes);
            MatchEvaluator meReplaceAttributeName = match => ReplaceAttributeName(dmlIdentifiers, match);


            ret = EntitiesInOrderByRegex.Replace(paramValue, meReplaceEntityName);
            ret = AliasAttributesRegex.Replace(ret, meReplaceEntityAttributeName);
            ret = AttributesRegex.Replace(ret, meReplaceAttributeName); // replace delimiters in attributes that doesn't belong to any entity
            return ret;
        }

        private static string ReplaceEntityAttributesName(IDMLIdentifiers dmlIdentifiers, Match m, string[] entityNames, string[] entityAliases, IDictionary<string, string>[] entityAttributesNamesToDatabaseNames) {
            string[] result = m.Value.Split('.');
            string entityAlias = result[0];
            string entityAttribute = GetEntityAttributeName(result[1]).ToLower(); // remove the attribute identifier delimiters
            string entityPhysicalAttributeName;

            // Find the entity attributes name mapper
            IDictionary<string, string> attributesDatabaseNamesMapper = null;
            for (int i = 0; i <= entityAliases.Length; i++) {
                if (entityAliases[i] == entityAlias) {
                    attributesDatabaseNamesMapper = entityAttributesNamesToDatabaseNames[i];
                    break;
                }
            }

            entityPhysicalAttributeName = attributesDatabaseNamesMapper != null ? attributesDatabaseNamesMapper[entityAttribute] : entityAttribute;

            // Escape the attribute name
            return entityAlias + "." + dmlIdentifiers.EscapeIdentifier(entityPhysicalAttributeName);
        }

        private static string GetEntityNameFromMatch(Match m) {
            //extract table name from match
            if (m.Value.EndsWith(".")) {
                //remove .
                return m.Value.Substring(0, m.Value.Length - 1);
            } else {
                //remove {}
                return m.Value.Substring(1, m.Value.Length - 2);
            }
        }

        private static string GetEntityAttributeName(string attribute) {
            if (attribute.EndsWith("]")) {
                //remove brackets
                return attribute.Substring(1, attribute.Length - 2);
            } else {
                return attribute;
            }
        }

        private static void CheckTableNameInOrderBy(string entity, string[] queryEnts) {
            bool found = false;
            for (int i = 0; i < queryEnts.Length; i++) {
                if (queryEnts[i].Equals(entity, StringComparison.InvariantCultureIgnoreCase)) {
                    found = true;
                    break;
                }
            }
            if (!found){
                throw new DataBaseException("'" + entity + "' found in 'Order By' parameter is an invalid Entity");
            }
        }

        [Obsolete("FilterOrderBy is deprecated, please use GetOrderByColumnsWithoutDuplicates instead.")]
        public static string FilterOrderBy(string orderBy) {
            string[] columns = orderBy.Split(',');
            return GetOrderByColumnsWithoutDuplicates(columns);
        }

        public static string GetOrderByColumnsWithoutDuplicates(IEnumerable<string> orderByColumns) {
            return FilterDuplicateOrderByColumns(orderByColumns).StrCat(", ");
        }

        private static IEnumerable<string> FilterDuplicateOrderByColumns(IEnumerable<string> orderByColumns) {
            HashSet<string> usedColumns = new HashSet<string>();

            foreach (string col in orderByColumns) {
                string trimmed = col.Trim();
                if (trimmed.IsEmpty()) {
                    continue;
                }

                string invariant = OrderByDirectionRegex.Replace(trimmed, "").Replace("\"", "").Replace("[", "").Replace("]", "").Trim().ToLowerInvariant();
                if (!usedColumns.Contains(invariant)) {
                    yield return trimmed;
                    usedColumns.Add(invariant);
                }
            }
        }

        public static string RemoveControlChars(string text) {
            if (text == null) {
                return "";
            } else {
                return ControlCharsRegex.Replace(text, "");
            }
        }

        public static string RemoveControlCharsWithNull(string text) {
            if (text == null) {
                return null;
            } else {
                return ControlCharsRegex.Replace(text, "");
            }
        }

        public bool NeedsCacheInvalidationSuffixURL(string uri) {
            return !(uri.ToLower().TrimStart().StartsWith("http://") ||
                     uri.ToLower().TrimStart().StartsWith("https://"));
        }

        public string getImagePath() {
            return getImagePath(/*forInternalAccess*/false);
        }

        public string getImagePath(bool forInternalAccess) {
            return getImagePath(forInternalAccess, /*includeSessionId*/false);
        }

        public string getImagePath(bool forInternalAccess, bool includeSessionIdIfNeeded) {
            return getImagePath(forInternalAccess, includeSessionIdIfNeeded, /*nameOverride*/null);
        }

        public string getImagePath(bool forInternalAccess, bool includeSessionIdIfNeeded, string nameOverride) {
            return getImagePath(forInternalAccess, includeSessionIdIfNeeded, nameOverride, /*skipSeo*/false);
        }

        public abstract string getImagePath(bool forInternalAccess = false, bool includeSessionIdIfNeeded = false, string nameOverride = null, bool skipSeo = false);

        protected static string EntityToTablename(string entity, Dictionary<string, string> entitiesTablenames) {
            string tablename;
            entitiesTablenames.TryGetValue(entity, out tablename);
            return tablename;
        }

        protected static string EntityAttributeToColumnName(Pair<string, string> entityAttribute, Dictionary<Pair<string, string>, string> entityAttributenames) {
            string columnName;
            entityAttributenames.TryGetValue(entityAttribute, out columnName);
            return columnName;
        }

        protected virtual string EntityAttributeToColumnName(string entityName, string attributeName) { return null; }

        protected virtual string EntityToTablename(string entity, int tenantId) { return null; }

        protected virtual bool CheckReadOnlyInvalidOperations(string entity) { return false; }

        [Obsolete]
        protected virtual string EncloseTableName(string name) { return null; }
        protected virtual int GetTenantId(HeContext heContext) { return 0; }

        public abstract string[] GetAjaxJQueryFileNames();
        public abstract string GetGlobalJavaScriptInclude();

        public abstract string CacheInvalidationPlatformSuffix { get; }
        public abstract string CacheInvalidationSuffix { get; }

        public static string EscapeAndQualifySqlIdentifier(IDatabaseAccessProvider<IPlatformDatabaseServices> provider, string objectName) {
            return provider.DatabaseServices.DMLService.Identifiers.EscapeAndQualifyIdentifierForLocalDatabase(objectName);
        }
    }

}