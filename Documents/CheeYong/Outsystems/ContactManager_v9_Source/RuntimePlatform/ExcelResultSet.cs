/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.IO;
using GemBox.Spreadsheet;
using OutSystems.RuntimeCommon;

namespace OutSystems.HubEdition.RuntimePlatform.Db {
    public class ExcelResultSet : IDataReader {

        static ExcelResultSet() {
            GemBoxLicensing.SetLicense();      
        }

        protected ExcelWorksheet sheet;

        protected int currentrow = 0;

        protected ExcelRow row = null;

        private const int headerRow = 0;

        private string[] dataTypes;

        private int fieldCount = 0;

        public ExcelResultSet(byte[] fileContents, string sheetName, int totalFields, string[] dataTypes, string[] attributeNames, string[] attributeLabels, string[] entityAttributeNames, string[] entityAttributeLabels) :
            this(GetWorksheetFromFile(fileContents, sheetName), totalFields, dataTypes, attributeNames, attributeLabels, entityAttributeNames, entityAttributeLabels) {
        }

        public ExcelResultSet(ExcelWorksheet sheet, int totalFields) {
            this.sheet = sheet;
            realIndices = new int[totalFields];
            fieldCount = totalFields;
            for (int i = 0; i < realIndices.Length; ++i) {
                realIndices[i] = i;
            }            
            try {
                row = sheet.Rows[headerRow];
            } catch {
            }
        }


        private string[] attributeNames;
        private string[] attributeLabels;
        private string[] entityAttributeNames;
        private string[] entityAttributeLabels;
        private string[] originalHeaders;


        private List<String> duplicateBindingLabels = new List<string>();

        private int[] realIndices;

        public ExcelResultSet(ExcelWorksheet sheet, int totalFields, string[] dataTypes, string[] attributeNames, string[] attributeLabels, string[] entityAttributeNames, string[] entityAttributeLabels) {
            this.sheet = sheet;
            this.dataTypes = dataTypes;
            this.attributeNames = attributeNames;
            this.attributeLabels = attributeLabels;
            this.entityAttributeNames = entityAttributeNames;
            this.entityAttributeLabels = entityAttributeLabels;
                        
            realIndices = new int[attributeLabels.Length];
            originalHeaders = new string[attributeLabels.Length];

            for (int i = 0; i < sheet.Rows.Count; i++) {
                int thisRowFieldCount = sheet.Rows[i].AllocatedCells.Count;
                while (thisRowFieldCount > 0 && sheet.Rows[i].Cells[thisRowFieldCount-1].Value == null) {
                    thisRowFieldCount -= 1;
                }
                fieldCount = (int)Math.Max(fieldCount, thisRowFieldCount);
            }
            try {
                row = sheet.Rows[headerRow];
                if (fieldCount != totalFields) {
                    fieldCount = 0;
                    for (int j = 0; j < attributeLabels.Length; ++j) {
                        realIndices[j] = -1;
                        for (int i = 0; i < row.AllocatedCells.Count; ++i) {
                            string caption = row.AllocatedCells[i].Value as string;
                            bool matched = false;

                            if (caption != null) {
                                if (caption.Contains(":")) {                                
                                    // this excel contains multiple records, look up in entityAttributelabels
                                    int separatorIndex = caption.IndexOf(":");
                                    string vEnt = caption.Substring(0, separatorIndex);
                                    string attribute = caption.Substring(separatorIndex + 1);
                                    if (vEnt + ":" + attribute == entityAttributeLabels[j] || 
                                        vEnt + ":" + attribute.FixName(/*extended*/false) == entityAttributeNames[j]) {
                                        matched = true;
                                    }
                                }     
                            
                                if (caption == attributeLabels[j] || caption.FixName(/*extended*/false) == attributeNames[j]) {
                                    matched = true;
                                }

                                if (matched) {
                                    if (realIndices[j] != -1) {
                                        duplicateBindingLabels.Add(caption);
                                    }
                                    realIndices[j] = i;
                                    originalHeaders[j] = caption;
                                    fieldCount += 1;
                                }
                            }
                        }
                    }
                } else {
                    for (int i = 0; i < realIndices.Length; ++i) {
                        realIndices[i] = i;
                        originalHeaders[i] = row.AllocatedCells[i].Value as string;
                    }
                }
            } catch {
            }
        }

        private static ExcelWorksheet GetWorksheetFromFile(byte[] fileContents, string sheetName) {
            ExcelFile excelFile = new ExcelFile();

            try {
                using (MemoryStream stream = new MemoryStream(fileContents)) {
                    excelFile.LoadXls(stream, XlsOptions.PreserveAll);
                }
            } catch {
                using (MemoryStream stream = new MemoryStream(fileContents)) {
                    excelFile.LoadXlsx(stream, XlsxOptions.PreserveKeepOpen);
                }
            }

            if (!string.IsNullOrEmpty(sheetName)) {
                try {
                    return excelFile.Worksheets[sheetName];
                } catch {
                    throw new InvalidOperationException("Error - '" + sheetName + "' sheet not found in excel file.");
                }
            } else {
                try {
                    return excelFile.Worksheets["Sheet1"];
                } catch {
                    return excelFile.Worksheets[0];
                }
            }
        }

        private HashSet<int> emptyRows = new HashSet<int>();

        public bool DataTypesValid(out string errorMsg) {
            errorMsg = string.Empty;
            if (dataTypes == null) {
                return true;
            }

            bool anyNonEmptyRealIndex = false;
            bool multipleBound = false;

            foreach (var duplicateBindingLabel in duplicateBindingLabels) {
                errorMsg += "Found duplicated '" + duplicateBindingLabel + "' column header in the Excel file.";
            }

            if (!duplicateBindingLabels.IsEmpty()) {
                return false;
            }

            HashSet<int> usedIndices = new HashSet<int>();
            for (int i = 0; i < realIndices.Length; i++) {
                if (realIndices[i] != -1) {
                    anyNonEmptyRealIndex = true;
                    if (!usedIndices.Contains(realIndices[i])) {
                        usedIndices.Add(realIndices[i]);
                    } else {
                        errorMsg += "Ambiguous binding of the '" + originalHeaders[i] + "' column header; prefix it with the entity name and a colon (':').\n";
                        multipleBound = true;
                    }
                } 
            }

            if (multipleBound) {
                return false;
            }

            if (!anyNonEmptyRealIndex) {
                errorMsg = "None of the column headers match with the record attributes.";
                return false;
            }

            for (int rowIndex = 1; rowIndex <= RowCount; ++rowIndex) {            
                bool anyCellFound = false;
                for (int fieldIndex = 0; fieldIndex < realIndices.Length; ++fieldIndex) {
                    int realIndex = realIndices[fieldIndex];
                    if (realIndex != -1) {
                        object cellValue = sheet.Cells[rowIndex, realIndex].Value;
                        if (cellValue != null) {
                            string cellType = cellValue.GetType().Name;

                            if (!TypeIsCompatible(dataTypes[fieldIndex], cellType, cellValue.ToString())) {
                                errorMsg = "Excel read error in row " + (rowIndex + 1) + ": Column '" + originalHeaders[fieldIndex] + "' has an invalid type. Expected a '" + dataTypes[fieldIndex] + "' but received a '" + cellType + "'.";
                                return false;
                            }
                            anyCellFound = true;
                        }
                    }
                }
                if (!anyCellFound) {
                    emptyRows.Add(rowIndex);
                }
            }

            return true;
        }

        private bool TypeIsCompatible(string RLType, string ExcelType, string value) {            
            var typeConversion = RLType + ">" + ExcelType;

            if (RLType == ExcelType || RLType == "String") {
                return true;
            }

            if (typeConversion == "Decimal>Int32" || typeConversion == "Decimal>Double" ||
                typeConversion == "DateTime>Double" || typeConversion == "Int32>Double" ||
                typeConversion == "Int64>Double" || typeConversion == "Int64>Int32") {
                return true;
            }

            if (typeConversion == "Decimal>String") {
                return ScriptableBuiltInFunction.TextToDecimalValidate(value);               
            }

            if (typeConversion == "Int32>String") {
                return ScriptableBuiltInFunction.TextToIntegerValidate(value);
            }

            if (typeConversion == "Int64>String") {
                return ScriptableBuiltInFunction.TextToLongIntegerValidate(value);
            }

            if (typeConversion == "DateTime>String") {
                return ScriptableBuiltInFunction.TextToDateTimeValidate(value) ||
                       ScriptableBuiltInFunction.TextToDateValidate(value) ||
                       ScriptableBuiltInFunction.TextToTimeValidate(value);
            }

            return false;
        }

        public bool NextResult() {
            return false;
        }

        public int Depth {
            get { return 0; }
        }

        public bool IsClosed {
            get { return currentrow == RowCount; }
        }

        public bool Read() {
            do {
                currentrow++;
            } while (emptyRows.Contains(currentrow));
            if (currentrow > RowCount)
                return false;
            row = sheet.Rows[currentrow];
            return true;
        }

        public int RecordsAffected {
            get { return 0; }
        }

        // without header
        private int RowCount {
            get { return sheet.Rows.Count - 1; }
        }

        
        public int FieldCount {
            get { return fieldCount; }
        }

        public object this[string name] {
            get {
                throw new NotImplementedException("Not Implemeted");
            }
        }

        public object this[int i] {
            get {
                return GetValue(i);
            }
        }

        private static long TicksFrom1900_2_28 = new DateTime(1900, 2, 28).Ticks;

        public object GetValue(int i) {
            int realIndex = realIndices[i];
            if (realIndex == -1) {
                return DBNull.Value;
            }

            object returnVal = row.Cells[realIndex].Value;

            if (returnVal == null) {
                returnVal = DBNull.Value;
            } else {

                if (dataTypes != null && dataTypes[i] == "DateTime") {
                    if (returnVal.GetType().Name == "Double") {
                        returnVal = DateTime.FromOADate((double)returnVal);
                    } else if (returnVal.GetType().Name == "String") {
                        string str = (string)returnVal;
                        if (str.IndexOf(" ") > 0) {
                            returnVal = ScriptableBuiltInFunction.TextToDateTime(str);
                        } else {
                            if (ScriptableBuiltInFunction.TextToTimeValidate(str)) {
                                returnVal = ScriptableBuiltInFunction.TextToTime(str);
                            } else {
                                returnVal = ScriptableBuiltInFunction.TextToDate(str);
                            }
                        }
                    }

                    // handle excel null dates for time values (30/12/1899)
                    var returnValDateTime = (DateTime)returnVal;
                    if (returnValDateTime.Year == 1899 &&
                        returnValDateTime.Month == 12 &&
                        returnValDateTime.Day == 30) {
                        return new DateTime(1900, 1, 1, returnValDateTime.Hour, returnValDateTime.Minute, returnValDateTime.Second);
                    }
                }

                if (dataTypes != null && dataTypes[i] == "Decimal" && returnVal.GetType().Name == "String") {
                    returnVal = ScriptableBuiltInFunction.TextToDecimal((string)returnVal);
                }

                if (dataTypes != null && dataTypes[i] == "Int32" && returnVal.GetType().Name == "String") {
                    returnVal = ScriptableBuiltInFunction.TextToInteger((string)returnVal);
                }

                if (dataTypes != null && dataTypes[i] == "Int64" && returnVal.GetType().Name == "String") {
                    returnVal = ScriptableBuiltInFunction.TextToLongInteger((string)returnVal);
                }

                if (returnVal is DateTime && ((DateTime)returnVal).Ticks < TicksFrom1900_2_28) {
                    returnVal = ((DateTime)returnVal).AddDays(1);
                }
            }

            return returnVal;
        }

        public void Close() { }

        public void Dispose() { }

        #region NotImplemented Region
        public DataTable GetSchemaTable() {
            throw new NotImplementedException("The method or operation is not implemented.");
        }

        public bool GetBoolean(int i) {
            throw new NotImplementedException("The method or operation is not implemented.");
        }

        public byte GetByte(int i) {
            throw new NotImplementedException("The method or operation is not implemented.");
        }

        public long GetBytes(int i, long fieldOffset, byte[] buffer, int bufferoffset, int length) {
            throw new NotImplementedException("The method or operation is not implemented.");
        }

        public char GetChar(int i) {
            throw new NotImplementedException("The method or operation is not implemented.");
        }

        public long GetChars(int i, long fieldoffset, char[] buffer, int bufferoffset, int length) {
            throw new NotImplementedException("The method or operation is not implemented.");
        }

        public IDataReader GetData(int i) {
            throw new NotImplementedException("The method or operation is not implemented.");
        }

        public string GetDataTypeName(int i) {
            throw new NotImplementedException("The method or operation is not implemented.");
        }

        public DateTime GetDateTime(int i) {
            throw new NotImplementedException("The method or operation is not implemented.");
        }

        public decimal GetDecimal(int i) {
            throw new NotImplementedException("The method or operation is not implemented.");
        }

        public double GetDouble(int i) {
            throw new NotImplementedException("The method or operation is not implemented.");
        }

        public Type GetFieldType(int i) {
            throw new NotImplementedException("The method or operation is not implemented.");
        }

        public float GetFloat(int i) {
            throw new NotImplementedException("The method or operation is not implemented.");
        }

        public Guid GetGuid(int i) {
            throw new NotImplementedException("The method or operation is not implemented.");
        }

        public short GetInt16(int i) {
            throw new NotImplementedException("The method or operation is not implemented.");
        }

        public int GetInt32(int i) {
            throw new NotImplementedException("The method or operation is not implemented.");
        }

        public long GetInt64(int i) {
            throw new NotImplementedException("The method or operation is not implemented.");
        }

        public string GetName(int i) {
            throw new NotImplementedException("The method or operation is not implemented.");
        }

        public int GetOrdinal(string name) {
            throw new NotImplementedException("The method or operation is not implemented.");
        }

        public string GetString(int i) {
            throw new NotImplementedException("The method or operation is not implemented.");
        }

        public int GetValues(object[] values) {
            throw new NotImplementedException("The method or operation is not implemented.");
        }

        public bool IsDBNull(int i) {
            throw new NotImplementedException("The method or operation is not implemented.");
        }

        #endregion NotImplemented Region
    }
}
