/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections;
using System.Data;
using OutSystems.HubEdition.Extensibility.Data.DMLService;
using OutSystems.Internal.Db;
using OutSystems.RuntimeCommon;
using OutSystems.RuntimeCommon.Cryptography;
using System.Net;
using System.Web;
using System.Collections.Generic;

namespace OutSystems.HubEdition.RuntimePlatform.NewRuntime {

    public class BinaryContentUtils {

        public static string GetDatabaseBinaryRestPath(string consumerEspaceName, string entityGlobalKey, string attributeName, string idValue, int userIdLogged, byte[] binaryData) {
            string entityDetails = RuntimePlatformUtils.Images.EncryptImageDetails(entityGlobalKey + "/" + attributeName + "/" + idValue + "/" + userIdLogged + "/" + GetBinaryContentHash(binaryData));
            entityDetails = entityDetails.Replace("+", "-").Replace("/", "_");    /* Replace invalid URL chars */
            return "screenservices/" + consumerEspaceName + "/_BinaryContent/" + entityDetails;
        }

        public struct DbBinaryConfig {
            public string DBConnection;
            public Func<int?, string, string> EntityGetter;
            public string Attribute;
            public string Id;
            public int IdDbType;
            public DbBinaryConfig(Func<int?, string, string> entityGetter, string attribute, string id, int idDbType)
                    : this(null, entityGetter, attribute, id, idDbType) { }

            public DbBinaryConfig(string dbConnection, Func<int?, string, string> entityGetter, string attribute, string id, int idDbType) {
                DBConnection = dbConnection;
                EntityGetter = entityGetter;
                Attribute = attribute;
                Id = id;
                IdDbType = idDbType;
            }
        }

        public static int GetBinaryContent(Dictionary<string, BinaryContentUtils.DbBinaryConfig> htDbBinaryConfig, string input, int userIdLogged, out byte[] content) {
            string parametersString = input.TrimEnd('/').TrimStart('/').Replace("-", "+").Replace("_", "/");
            parametersString = RuntimePlatformUtils.Images.DecryptImageDetails(parametersString);
            content = null;

            /*
             * 0 => Entity's global object key
             * 1 => Name of the binary data attribute
             * 2 => ID of the record that has the binary data
             * 3 => User ID for which the URL was generated
             * 4 => An hash of the binary data (forces the URL to change when the binary data changes)
             */
            var parameters = parametersString.Split('/');
            if (parameters.Length < 4) {
                return (int)HttpStatusCode.BadRequest;
            }

            var entityGlobalKey = parameters[0].ToLower();
            var attribute = parameters[1].ToLower();
            var id = parameters[2];
            var userId = 0;

            if (int.TryParse(parameters[3], out userId) && userId != userIdLogged) {
                return (int)HttpStatusCode.Unauthorized;
            }

            object objt = htDbBinaryConfig[entityGlobalKey + "/" + attribute];
            if (objt == null) {
                return (int)HttpStatusCode.NotFound;
            }

            DbBinaryConfig dbBinaryConfig;
            dbBinaryConfig = (DbBinaryConfig)objt;

            byte[] buffer = GetDatabaseBinaryAttribute(id, dbBinaryConfig);
            if (buffer == null) {
                return (int)HttpStatusCode.NotFound;
            } else {
                content = buffer;
                return (int)HttpStatusCode.OK;
            }
        }

        /**
         * It should be ok to truncate the hash to a shorter length since we are not worried about collisions here,
         * just trying to force different hashes when the content is updated.
         * 
         * FIPS 180-4 (http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf) specifies that:
         * "Some application may require a hash function with a message digest length different than those provided
         * by the hash functions in this Standard. In such cases, a truncated message digest may be used, whereby a
         * hash function with a larger message digest length is applied to the data to be hashed, and the resulting
         * message digest is truncated by selecting an appropriate number of the leftmost bits".
         **/
        private static string GetBinaryContentHash(byte[] content) {
            return SecureHashHelper.Hash(content).Substring(0, 20);
        }

        private static byte[] GetDatabaseBinaryAttribute(string id, DbBinaryConfig dbBinaryConfig) {
            IDMLIdentifiers identifiers = null;
            IDatabaseAccessProvider dbAccessProvider;

            if (string.IsNullOrEmpty(dbBinaryConfig.DBConnection)) {
                dbAccessProvider = DatabaseAccess.ForCurrentDatabase;
                identifiers = dbAccessProvider.DatabaseServices.DMLService.Identifiers;
            } else {
                dbAccessProvider = DatabaseAccess.ForDBConnection(dbBinaryConfig.DBConnection);
                identifiers = dbAccessProvider.DatabaseServices.DMLService.Identifiers;
            }

            using (Transaction trans = dbAccessProvider.GetReadOnlyTransaction()) {
                try {
                    using (Command cmd = trans.CreateCommand(
                        "SELECT " + identifiers.EscapeIdentifier(dbBinaryConfig.Attribute.ToUpper()) + " FROM " +
                        dbBinaryConfig.EntityGetter(null, BuiltInFunction.GetCurrentLocale()) +
                        " WHERE " + identifiers.EscapeIdentifier(dbBinaryConfig.Id.ToUpper()) + " = @ID")) {

                        cmd.CreateParameter("@ID", (DbType)dbBinaryConfig.IdDbType, id);

                        using (IDataReader reader = cmd.ExecuteReader()) {
                            if ((reader.IsClosed) || (!reader.Read())) {
                                return null;
                            }
                            return ReadBytes(reader, dbBinaryConfig.Attribute);
                        }
                    }
                } catch (Exception) {
                    return null;
                }
            }
        }

        private static byte[] ReadBytes(IDataReader reader, string attributeName) {
            long size = reader.GetBytes(0, 0, null, 0, 0);
            var buffer = new byte[size];
            reader.GetBytes(0, 0, buffer, 0, buffer.Length);
            return buffer;
        }

        private static string GetParameters(HttpRequest request) {
            return request.PathInfo;
        }

        private static void ResponseError(HttpResponse response, int statusCode, string description) {
            response.Clear();
            response.StatusCode = statusCode;
            Write(response, description);
            End(response);
        }

        private static void BinaryWrite(HttpResponse response, byte[] content) {
            response.BinaryWrite(content);
        }

        private static void Write(HttpResponse response, string content) {
            response.Write(content);
        }

        private static void End(HttpResponse response) {
            response.End();
        }

    }

}
