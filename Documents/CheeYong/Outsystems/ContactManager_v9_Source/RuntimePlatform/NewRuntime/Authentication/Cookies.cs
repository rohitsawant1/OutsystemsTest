/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using OutSystems.Internal.Db;
using OutSystems.RuntimeCommon;
using OutSystems.RuntimeCommon.Cryptography;
using System;
using System.Security.Cryptography;
using System.Text;
using OutSystems.RuntimeCommon.ObfuscationProperties;
using System.Web;

namespace OutSystems.HubEdition.RuntimePlatform.NewRuntime.Authentication {

    public class SecureTokenGenerator {

        // https://www.owasp.org/index.php/Insufficient_Session-ID_Length
        static readonly int SecureTokenLength = 20;

        readonly RNGCryptoServiceProvider rng;

        SecureTokenGenerator() {
            rng = new RNGCryptoServiceProvider();
        }

        public CSRFToken GenerateCSRFToken() {
            byte[] token = new byte[SecureTokenLength];
            rng.GetBytes(token);
            return new CSRFToken(Convert.ToBase64String(token));
        }
        
        public static readonly SecureTokenGenerator Instance = new SecureTokenGenerator();

    }

    public class LoginInfo {
        
        readonly Encoding encoding = Encoding.UTF8;

        CSRFToken csrfToken;
        HttpOnlyLoginCookieValue httpCookie;
        UserAccessibleLoginCookieValue userCookie;

        MobileLoginInfo mobileLoginInfo;

        bool dirty;

        readonly MobileLoginConfiguration configuration;

        public LoginInfo(MobileLoginConfiguration configuration) {
            this.configuration = configuration;
            csrfToken = null;
            httpCookie = new HttpOnlyLoginCookieValue();
            userCookie = new UserAccessibleLoginCookieValue();
            mobileLoginInfo = new MobileLoginInfo {
                TenantId = configuration.DefaultTenantId
            };

            dirty = false;
        }

        public LoginInfo(MobileLoginConfiguration configuration, CSRFToken csrfToken, HttpOnlyLoginCookieValue httpCookie, UserAccessibleLoginCookieValue userCookie) {
            this.configuration = configuration;
            this.csrfToken = csrfToken;
            this.httpCookie = httpCookie;
            this.userCookie = userCookie;

            dirty = false;
        }

        private bool ValidSignature() {
            bool newSignatureValid = SignatureHelper.SlowEquals(Convert.FromBase64String(httpCookie.HMAC), SignatureHelper.ByteSign(SignatureData, encoding.GetBytes(configuration.HMACKey)));

            if (newSignatureValid) {
                return true;
            } else {
                return SignatureHelper.SlowEquals(Convert.FromBase64String(httpCookie.HMAC), SignatureHelper.ByteSign(SignatureDataDeprecated, encoding.GetBytes(configuration.HMACKey)));
            }
        }

        private byte[] SignatureData {
            get { return encoding.GetBytes((httpCookie.SignatureData + userCookie.SignatureData + configuration.UserProviderEspaceKey)); }
        }

        // TODO: Delete this after migration is complete...
        public byte[] SignatureDataDeprecated {
            get { return encoding.GetBytes((httpCookie.SignatureData + userCookie.SignatureData)); }
        }

        public void Sign() {
            httpCookie.HMAC = Convert.ToBase64String(SignatureHelper.ByteSign(SignatureData, encoding.GetBytes(configuration.HMACKey)));
        }

        private string RolesHash {
            get { return httpCookie.RolesHash; }
            set { httpCookie.RolesHash = value; }
        }

        public string LoginId {
            get { return httpCookie.LoginId; }
        }

        public int UserId  {
            get { return userCookie.UserId; }
        }

        public string Username {
            get { return userCookie.Username; }
        }

        public int TenantId {
            get { return mobileLoginInfo.TenantId; }
        }

        public string UpdateRolesHashAndCalculateRolesInfo(string rolesInfo) {
            if (rolesInfo == null) {
                return null;
            }

            var rolesHash = HashSHA1Helper.HashFromASCII(rolesInfo);
            if (RolesHash == rolesHash) {
                return null;
            }

            RolesHash = rolesHash;
            return rolesInfo;
        }

        public bool IsPersistent {
            get { return mobileLoginInfo.IsPersistent; }
        }

        public bool IsAnonymous {
            get { return userCookie.UserId == 0; }
        }

        public bool IsDirty {
            get { return dirty; }
        }

        public string UserCookieValue {
            get { return userCookie.Serialize(); }
        }

        public string HttpCookieValue {
            get { return httpCookie.Serialize(); }
        }

        public void Login(int userId, int tenantId, string username, bool isPersistent, bool hasSessionStorage) {
            var previousLoginId = httpCookie.IsAnonymous ? null : httpCookie.LoginId;

            userCookie = new UserAccessibleLoginCookieValue {
                UserId = userId,
                Username = username,
                CSRFToken = SecureTokenGenerator.Instance.GenerateCSRFToken()
            };

            mobileLoginInfo = new MobileLoginInfo {
                UserId = userId,
                TenantId = tenantId,
                IsPersistent = isPersistent
            };

            httpCookie = new HttpOnlyLoginCookieValue {
                LoginId = MobileLoginReadWriter.Write(configuration.EncryptKey, mobileLoginInfo)
            };

            if (hasSessionStorage) {
                CreateMobileLoginInfo(httpCookie.LoginId, previousLoginId);
            }

            csrfToken = userCookie.CSRFToken;

            dirty = true;
        }

        private void CreateMobileLoginInfo(string loginId, string previousLoginId) {
            using (var trans = DatabaseAccess.ForRuntimeDatabase.GetCommitableTransaction()) {
                // Define the time until we will wait until verify the information against the database
                long currentUnixTime = (long)TimeSpan.FromTicks(DateTime.UtcNow.Ticks).TotalSeconds;

                httpCookie.ExtendExpirationDateFrom(currentUnixTime, IsPersistent ? configuration.PersistentLoginMaxIdleTime : configuration.SessionLoginMaxIdleTime);
                httpCookie.ExtendTimeUntilUpdateStartingFrom(currentUnixTime, configuration.LoginCacheTime);

                if (!string.IsNullOrEmpty(previousLoginId)) { // invalidate the old identifier
                    DBRuntimePlatform.Instance.MobileLoginDeleteByLoginId(trans, previousLoginId);
                }

                // Insert the login information into the database
                DBRuntimePlatform.Instance.MobileLoginInsert(trans, loginId, mobileLoginInfo.UserId, mobileLoginInfo.TenantId, httpCookie.ExpirationDate, mobileLoginInfo.IsPersistent);
                trans.Commit();
            }
        }

        public class MobileLoginInfo {
            public int UserId;
            public int TenantId;
            public bool IsPersistent;
        }

        public static class MobileLoginReadWriter {

            public static MobileLoginInfo Read(string key, string loginInfo) {
                string decryptedLoginInfo = SymmCryptHelper.DecryptWithAES128(key, loginInfo);
                string[] parts = decryptedLoginInfo.Split('|');
                var info = new MobileLoginInfo();
                info.UserId = Base64.IntFromBase64(parts[0]);
                info.TenantId = Base64.IntFromBase64(parts[1]);
                info.IsPersistent = Convert.ToBoolean(Base64.IntFromBase64(parts[2]));
                return info;
            }

            public static string Write(string key, MobileLoginInfo loginInfo) {
                string encoded = string.Join("|", Base64.ToBase64(loginInfo.UserId), Base64.ToBase64(loginInfo.TenantId), Base64.ToBase64(Convert.ToInt32(loginInfo.IsPersistent)));
                return SymmCryptHelper.EncryptWithAES128(key, encoded);
            }
        }

        public void Logout() {
            userCookie = new UserAccessibleLoginCookieValue();
            httpCookie = new HttpOnlyLoginCookieValue();

            mobileLoginInfo = new MobileLoginInfo {
                TenantId = configuration.DefaultTenantId
            };

            csrfToken = userCookie.CSRFToken;

            dirty = true;
        }

        public void Validate() {
            Validate(false);
        }

        public void Validate(bool ignoreCSRFToken) {

            if (!ignoreCSRFToken && csrfToken == null) { // Unacceptable
                throw new InvalidLoginException("Invalid CSRF request");
            }

            if (httpCookie == null || userCookie == null) {
                Anonymize();
            }

            if (!ValidSignature()) {
                // Downgrade to anonymous cookies.
                // You might be wondering why we let the guy go as anonymous
                // we do this so that when we change the cookie format
                // users can upgrade their login cookies by logging in again.
                Anonymize();
            }

            if (!ignoreCSRFToken && !csrfToken.SlowEquals(userCookie.CSRFToken)) { // Unaceptable
                throw new InvalidLoginException("Invalid CSRF request");
            }

            if (!IsAnonymous) {
                mobileLoginInfo = MobileLoginReadWriter.Read(configuration.EncryptKey, httpCookie.LoginId);
            } else {
                mobileLoginInfo = new MobileLoginInfo {
                    TenantId = configuration.DefaultTenantId
                };
            }

            if (userCookie.UserId != mobileLoginInfo.UserId) {
                throw new InvalidLoginException("Inconsistent Login Info");
            }

        }

        public void Refresh() {
            // If IsAnonymous there is nothing to do
            if (IsAnonymous) {
                return;
            }

            long currentDate = (long)TimeSpan.FromTicks(DateTime.UtcNow.Ticks).TotalSeconds;

            // Checks if is within the time where we trust in the information stored in the cookie
            if (configuration.LoginCacheTime <= TimeSpan.Zero || httpCookie.NeedsToBeRefreshedAt(currentDate)) {
                // If not, get information from database
                using (var trans = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                    using (var reader = DBRuntimePlatform.Instance.MobileLoginGet(trans, LoginId)) {
                        if (!reader.Read()) { // If the session was deleted from the database due to be expired  
                            Anonymize();
                            return;
                        }
                        mobileLoginInfo.UserId = reader.SafeGet<int>("USER_ID");
                        mobileLoginInfo.TenantId = reader.SafeGet<int>("TENANT_ID");
                        httpCookie.ExpirationDate = reader.SafeGet<long>("EXPIRATION_DATE");
                        mobileLoginInfo.IsPersistent = reader.SafeGet<bool>("IS_PERSISTENT");

                        userCookie.UserId = mobileLoginInfo.UserId;
                    }

                    // Since we already fetched the information from the database, update the TimeUntilUpdate
                    httpCookie.ExtendTimeUntilUpdateStartingFrom(currentDate, configuration.LoginCacheTime);
                }
            } else {
                // Use the encrypted information in the cookie's LoginId
                userCookie.UserId = mobileLoginInfo.UserId;
                return;
            }

            if (httpCookie.IsValidAt(currentDate)) { // If it is within the expiration date validate if it is still valid
                using (var trans = DatabaseAccess.ForRuntimeDatabase.GetCommitableTransaction()) {
                    if (DBRuntimePlatform.Instance.MobileLoginIsValidAt(trans, LoginId, currentDate)) { // If login is still valid, extend expiration time
                        httpCookie.ExtendExpirationDateFrom(currentDate, mobileLoginInfo.IsPersistent ? configuration.PersistentLoginMaxIdleTime : configuration.SessionLoginMaxIdleTime);
                        DBRuntimePlatform.Instance.MobileLoginExtendExpirationDateUntil(trans, LoginId, httpCookie.ExpirationDate);
                        dirty = true;
                    } else { // Login isn't valid, downgrade to anonymous
                        Anonymize();
                    }
                }
            } else { // Login is already expired, log out
                Anonymize();
            }
        }


        
        private void Anonymize() {
            Logout();
        }
    }

    internal static class CookieValueFormat {
        internal static readonly char KeySeparator = ';';
        internal static readonly string KeyValueSeparator = "=";
    }

    [DoNotObfuscateType]
    internal class CookieValueReader {

        private string p;
        private int currentIndex;
        private bool bad;

        public CookieValueReader(string payload) {
            p = HttpUtility.UrlDecode(payload.Trim('"'), Encoding.UTF8);
            currentIndex = 0;
            bad = false;
        }

        private bool BadAndFail() {
            bad = true;
            return false;
        }

        private bool Consume(string str) {

            if (currentIndex >= p.Length) {
                return BadAndFail();
            }

            if (currentIndex + str.Length > p.Length) {
                return BadAndFail();
            }

            int strIndex = p.IndexOf(str, currentIndex, str.Length);
            if (strIndex == -1) {
                return BadAndFail();
            }

            currentIndex += str.Length;
            return true;
        }

        private void AdvanceUntil(char c) {
            while (currentIndex < p.Length && p[currentIndex] != c) {
                currentIndex++;
            }
        }

        public bool TryGetStringValue(string key, out string value) {
            value = null;

            if (bad) {
                return false;
            }

            if (!Consume(key)) {
                return false;
            }

            if (!Consume(CookieValueFormat.KeyValueSeparator)) {
                return false;
            }

            int valueStart = currentIndex;
            AdvanceUntil(CookieValueFormat.KeySeparator);
            value = p.Substring(valueStart, currentIndex - valueStart);
            currentIndex++;
            return true;
        }

        public bool TryGetIntValue(string key, out int value) {
            string strValue;
            if (!TryGetStringValue(key, out strValue) || !int.TryParse(strValue, out value)) {
                value = default(int);
                return false;
            }
            return true;
        }

        public bool TryGetBoolValue(string key, out bool value) {
            string strValue;
            if (!TryGetStringValue(key, out strValue) || !bool.TryParse(strValue, out value)) {
                value = default(bool);
                return false;
            }
            return true;
        }

        internal bool TryGetLongValue(string key, out long value) {
            string strValue;
            if (!TryGetStringValue(key, out strValue) || !long.TryParse(strValue, out value)) {
                value = default(long);
                return false;
            }
            return true;
        }
    }

    internal class CookieValueWriter {

        private StringBuilder b = new StringBuilder();

        public CookieValueWriter() {}

        public CookieValueWriter AddKeyValue(string key, string value) {

            if (b.Length != 0) {
                b.Append(CookieValueFormat.KeySeparator);
            }

            b.Append(key).Append(CookieValueFormat.KeyValueSeparator).Append(value);
            return this;
        }

        public CookieValueWriter AddKeyValue(string key, long value) {
            return AddKeyValue(key, value.ToString());
        }

        public CookieValueWriter AddKeyValue(string key, bool value) {
            return AddKeyValue(key, value.ToString());
        }

        public CookieValueWriter AddKeyValue(string key, int value) {
            return AddKeyValue(key, value.ToString());
        }

        public string ToPayload() {
            return HttpUtility.UrlEncode(b.ToString(), Encoding.UTF8);
        }
    }

    public class CSRFToken {

        public static readonly CSRFToken Anonymous = new CSRFToken("T6C+9iB49TLra4jEsMeSckDMNhQ="); // Sync with Communication.ts

        private readonly string value;
        public CSRFToken(string value) {
            this.value = value;
        }

        public bool IsAnonymous { get {
            return SlowEquals(Anonymous);
        } }

        public bool SlowEquals(CSRFToken other) {
            return other != null && SignatureHelper.SlowEquals(value, other.value);
        }

        public string Serialize() {
            return value;
        }
    }

    public class HttpOnlyLoginCookieValue {

        private const string AnonymousLoginId = "Anonymous";

        public string LoginId;
        public long TimeUntilUpdate;
        public string HMAC;
        public long ExpirationDate;
        public string RolesHash;

        public HttpOnlyLoginCookieValue() {
            LoginId = AnonymousLoginId;
            TimeUntilUpdate = 0;
            ExpirationDate = 0;
            RolesHash = "";
            HMAC = "";
        }

        public string Serialize() {
            return new CookieValueWriter()
                        .AddKeyValue("lid", LoginId)
                        .AddKeyValue("tuu", TimeUntilUpdate)
                        .AddKeyValue("exp", ExpirationDate)
                        .AddKeyValue("rhs", RolesHash)
                        .AddKeyValue("hmc", HMAC)
                        .ToPayload();
        }
        public static bool TryParse(string payload, out HttpOnlyLoginCookieValue value) {
            value = null;

            var httpCookie = new HttpOnlyLoginCookieValue();
            var b = new CookieValueReader(payload);

            bool ok = b.TryGetStringValue("lid", out httpCookie.LoginId)
                    && b.TryGetLongValue("tuu", out httpCookie.TimeUntilUpdate)
                    && b.TryGetLongValue("exp", out httpCookie.ExpirationDate)
                    && b.TryGetStringValue("rhs", out httpCookie.RolesHash)
                    && b.TryGetStringValue("hmc", out httpCookie.HMAC);

            if (ok) {
                value = httpCookie;
            }

            return ok;
        }

        public string SignatureData {
            get { return LoginId + TimeUntilUpdate + ExpirationDate + RolesHash; }
        }

        public bool IsAnonymous {
            get {
                return LoginId == AnonymousLoginId;
            }
        }

        public void ExtendExpirationDateFrom(long nowUnixTimeStamp, TimeSpan idleTime) {
            ExpirationDate = nowUnixTimeStamp + (long) idleTime.TotalSeconds;
        }

        public void ExtendTimeUntilUpdateStartingFrom(long nowUnixTimeStamp, TimeSpan cacheTime) {
            TimeUntilUpdate = nowUnixTimeStamp + (long) cacheTime.TotalSeconds;
        }

        public bool IsValidAt(long nowUnixTimeStamp) {
            return nowUnixTimeStamp < ExpirationDate;
        }

        public bool NeedsToBeRefreshedAt(long nowUnixTimeStamp) {
            return TimeUntilUpdate < nowUnixTimeStamp;
        }
    }

    public class UserAccessibleLoginCookieValue {

        public CSRFToken CSRFToken;
        public int UserId;
        public string Username;

        internal UserAccessibleLoginCookieValue() {
            CSRFToken = CSRFToken.Anonymous;
            UserId = 0;
            Username = "";
        }

        public string Serialize() {
            return new CookieValueWriter()
                    .AddKeyValue("crf", CSRFToken.Serialize())
                    .AddKeyValue("uid", UserId)
                    .AddKeyValue("unm", Username)
                    .ToPayload();
        }

        public static bool TryParse(string payload, out UserAccessibleLoginCookieValue value) {
            value = null;

            var userCookie = new UserAccessibleLoginCookieValue();
            var b = new CookieValueReader(payload);
            string csrfTokenStr;

            bool ok =
                b.TryGetStringValue("crf", out csrfTokenStr) &&
                b.TryGetIntValue("uid", out userCookie.UserId) &&
                b.TryGetStringValue("unm", out userCookie.Username);

            if (ok) {
                userCookie.CSRFToken = new CSRFToken(csrfTokenStr);
                value = userCookie;
            }

            return ok;
        }

        public string SignatureData {
            get { return CSRFToken.Serialize() + UserId + Username; }
        }

    }
}
