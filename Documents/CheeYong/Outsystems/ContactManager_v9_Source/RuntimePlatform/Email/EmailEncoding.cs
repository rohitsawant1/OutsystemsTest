/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Text.RegularExpressions;
using System.Collections;
using System.Text;
using OutSystems.RuntimeCommon.ObfuscationProperties;

namespace OutSystems.HubEdition.RuntimePlatform.Email {
    [FlagsAttribute]
    public enum EncodeFlags {
        QuotedPrintable = 0x01,
        Base64 = 0x02,
        SingleLine = 0x04,
        MultiLine = 0x08,
        AllowWhiteSpace = 0x10
    }

    public class EmailEncoding {
        internal const int MaxEncodedLength = 72; // as per RFC2047 (http://www.faqs.org/rfcs/rfc2047.html)  the RFC says 75 but seems some clients count the CRLF separators
        internal const int MaxLineLength = 72; // Used when breaking text blocks, don't use any value greater than 72... it will not work in some clients (outlook 2007)

        private static int QP_CalcSize(System.Text.Encoding encoding, byte[] buffer, EncodeFlags flags) {
            string heading = "=?" + encoding.HeaderName + "?Q?";
            string terminator = "?=";
            string lwsp = "\r\n\t"; // linear-white-space
            bool isSingleLine = (flags & EncodeFlags.SingleLine) == EncodeFlags.SingleLine;
            int encodedcount = 0;
            sbyte cur;

            encodedcount += heading.Length;
            for (int x = 0; x < buffer.Length; x++) {
                cur = (sbyte)buffer[x];
                //is this a valid ascii character?
                bool processed = false;
                bool doit = false;
                if (((cur >= 33) && (cur <= 60)) || ((cur >= 62) && (cur <= 126)) || (cur == '\r') || (cur == '\n') || (cur == '\t') || (cur == ' ')) {
                    if ((cur == '\r') || (cur == '\n')) {
                        // When encoding a single line field escape the newline chars
                        if ((flags & EncodeFlags.MultiLine) == EncodeFlags.MultiLine) {
                            doit = true;
                        }
                    } else if (cur == 63) { // '?'
                        // We must escape this char as it is not allowed
                        doit = false;
                    } else if ((cur == ' ') || (cur == '\t')) { // '?'
                        // We must escape these chars as it is not allowed
                        doit = false;
                    } else {
                        doit = true;
                    }
                    if (doit) {
                        if (!isSingleLine && encodedcount + 2 + 1 > MaxEncodedLength) { // 2 for the terminator, 1 for the char
                            encodedcount += terminator.Length;
                            encodedcount += lwsp.Length;
                            encodedcount += heading.Length;
                        }
                        encodedcount++;
                        processed = true;
                    }
                }
                if (!processed) {
                    if (!isSingleLine && encodedcount + 2 + 3 > MaxEncodedLength) { // 2 for the terminator, 3 for the chars
                        encodedcount += terminator.Length;
                        encodedcount += lwsp.Length;
                        encodedcount += heading.Length;
                    }
                    encodedcount += 3;
                }
            }
            return encodedcount;
        }

        private static string QP_Encode(System.Text.Encoding encoding, byte[] buffer, EncodeFlags flags) {
            string heading = "=?" + encoding.HeaderName + "?Q?";
            string terminator = "?=";
            string lwsp = "\r\n\t"; // linear-white-space
            bool isSingleLine = (flags & EncodeFlags.SingleLine) == EncodeFlags.SingleLine;
            StringBuilder buf = new StringBuilder();
            int encodedcount = 0;
            sbyte cur;

            buf.Append(heading);
            encodedcount += heading.Length;

            for (int x = 0; x < buffer.Length; x++) {
                cur = (sbyte)buffer[x];
                //is this a valid ascii character?
                bool processed = false;
                bool doit = false;
                if (((cur >= 33) && (cur <= 60)) || ((cur >= 62) && (cur <= 126)) || (cur == '\r') || (cur == '\n') || (cur == '\t') || (cur == ' ')) {
                    if ((cur == '\r') || (cur == '\n')) {
                        // When encoding a single line field escape the newline chars
                        if ((flags & EncodeFlags.MultiLine) == EncodeFlags.MultiLine) {
                            doit = true;
                        }
                    } else if (cur == 63) { // '?'
                        // We must escape this char as it is not allowed
                        doit = false;
                    } else if ((cur == ' ') || (cur == '\t') || (cur == '_')) { // '?'
                        // We must escape these chars as it is not allowed
                        doit = false;
                    } else {
                        doit = true;
                    }
                    if (doit) {
                        if (!isSingleLine && encodedcount + 2 + 1 > MaxEncodedLength) { // 2 for the terminator, 1 for the char
                            buf.Append(terminator);
                            buf.Append(lwsp);
                            buf.Append(heading);
                            encodedcount = heading.Length;
                        }
                        buf.Append((char)buffer[x]);
                        encodedcount++;
                        processed = true;
                    }
                }
                if (!processed) {
                    if (!isSingleLine && encodedcount + 2 + 3 > MaxEncodedLength) { // 2 for the terminator, 3 for the chars
                        buf.Append(terminator);
                        buf.Append(lwsp);
                        buf.Append(heading);
                        encodedcount = heading.Length;
                    }
                    buf.Append('=');
                    buf.Append(((sbyte)((cur & 0xF0) >> 4)).ToString("X"));
                    buf.Append(((sbyte)(cur & 0x0F)).ToString("X"));
                    encodedcount += 3;
                }
            }
            buf.Append(terminator);

            //format data so that lines don't end with spaces (if so, add a trailing '='), etc.
            //for more detail see RFC 2045.

            int start = 0;
            string enc = buf.ToString();
            buf.Length = 0;
            for (int x = 0; x < enc.Length; ++x) {
                cur = (sbyte)enc[x];
                if (cur == '\n' || cur == '\r' || x == (enc.Length - 1)) {
                    buf.Append(enc.Substring(start, x - start + 1));
                    start = x + 1;
                    continue;
                }
                if (!isSingleLine && (x - start) > MaxEncodedLength) {
                    bool inWord = true;
                    while (inWord) {
                        inWord = (!char.IsWhiteSpace(enc, x) && enc[x - 2] != '=');
                        if (inWord) {
                            --x;
                            cur = (sbyte)enc[x];
                        }
                        if (x == start) {
                            x = start + MaxEncodedLength;
                            break;
                        }
                    }
                    buf.Append(enc.Substring(start, x - start + 1));
                    buf.Append("=\r\n");
                    start = x + 1;
                }
            }
            return buf.ToString();
        }

        // This is used to get a Base64 encoded body part
        [DoNotObfuscate]
        internal static string GetBase64TextBlock(byte[] buffer, int linelength) {
            int dummy;
            string result = GetBase64TextBlock(buffer, linelength, out dummy);
            return result;

        }

        internal static string GetBase64TextBlock(byte[] buffer, int linelength, out int base64Length) {
            if (linelength > MaxEncodedLength) { linelength = MaxEncodedLength; }
            StringBuilder builder = new StringBuilder();
            string base64 = System.Convert.ToBase64String(buffer) + "\r\n";
            base64Length = base64.Length;
            for (int i = 0; i < base64.Length; i = i + linelength) {
                builder.Append(base64.Substring(i, (linelength + i > base64.Length ? base64.Length - i : linelength)));
                builder.Append("\r\n");
            }
            return builder.ToString();
        }

        /// <summary>
        /// Encode the body as in quoted-printable format.
        /// Adapted from PJ Naughter's quoted-printable encoding code.
        /// For more information see RFC 2045.
        /// </summary>
        /// <returns>The encoded body.</returns>
        private static string EncodeAsQuotedPrintable(System.Text.Encoding encoding, string text, EncodeFlags flags) {
            StringBuilder buf = new StringBuilder();
            string heading = "=?" + encoding.HeaderName + "?Q?";
            string terminator = "?=";
            string lwsp = "\r\n\t"; // linear-white-space
            int start = 0;

            if ((flags & EncodeFlags.SingleLine) == EncodeFlags.SingleLine) {
                return QP_Encode(encoding, encoding.GetBytes(text), flags);
            } else {
                while (start < text.Length) {
                    byte[] buffer = null;
                    int tsize = MaxEncodedLength + 1;
                    int tbufsize = 0;
                    tbufsize = MaxEncodedLength - heading.Length - terminator.Length;
                    if (start + tbufsize > text.Length)
                        tbufsize = text.Length - start;
                    while (tsize > MaxEncodedLength) {
                        if (start + tbufsize > text.Length)
                            tbufsize = text.Length - start;
                        buffer = encoding.GetBytes(text.Substring(start, tbufsize));
                        tsize = QP_CalcSize(encoding, buffer, flags);
                        if (tsize > MaxEncodedLength) {
                            // Reduce the size and try again
                            tbufsize--;
                        }
                    }
                    if (start != 0) {
                        buf.Append(lwsp);
                    }
                    buf.Append(QP_Encode(encoding, buffer, flags));
                    start += tbufsize;
                }

                return buf.ToString();
            }
        }

        // This is used to MIME encode a string in Base64
        // 2004-07-08 MRC This method is broken, by the spec we should limit each 'encoded-text' to max 75 chars
        //                and create several 'encoded-texts' separated by 'linear-white-space'.
        //                I'm not fixing this at this time. Maybe later if it is needed.
        internal static string EncodeString(System.Text.Encoding encoding, string text, EncodeFlags flags) {
            if ((flags & EncodeFlags.Base64) == EncodeFlags.Base64) {
                throw new ArgumentException("Unsupported encoding");
            } else if ((flags & EncodeFlags.QuotedPrintable) == EncodeFlags.QuotedPrintable) {
                return EncodeAsQuotedPrintable(encoding, text, flags);
            } else {
                throw new InvalidOperationException("Unsupported encoding");
            }
        }

        // Receives a string and returns true if the string contains chars that are not plain letters, numbers or a white space.
        internal static bool NeedsEncoding(System.Text.Encoding encoding, string text, EncodeFlags flags) {
            for (int i = 0; i < text.Length; i++) {
                if ((text[i] != 32) && ((text[i] < 48) || (text[i] > 57)) && ((text[i] < 65) || (text[i] > 90)) && ((text[i] < 97) || (text[i] > 122))) {
                    return true;
                }
            }
            return false;
        }
    }
}
