/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Net;
using System.Text;
using System.Text.RegularExpressions;
using System.Web;
using System.Linq;
using OutSystems.HubEdition.RuntimePlatform.Internal;
using OutSystems.Internal.Db;
using OutSystems.RuntimeCommon;

namespace OutSystems.HubEdition.RuntimePlatform.Email {

    [FlagsAttribute]
    public enum HeaderFlags {
        ContentType = 0x01,
        ContentDescription = 0x02,
        ContentDisposition = 0x04,
        Location = 0x08,
        ContentID = 0x10,
        ContentDispositionInline = 0x20
    }

    public class EmailProcessor {

        public class EmailAttachment {
            public string FileName;
            public byte[] FileContent;
            public string MimeType;
            public EmailAttachment(string fileName, byte[] fileContent, string mimeType) {
                FileName = fileName;
                FileContent = fileContent;
                MimeType = mimeType;
            }
        }

        /// <summary>
        /// String for RuntimePlatform to use as UserAgent on HTTP Requests
        /// </summary>
        public static string MailUA {
            get { return "OutSystems Email Request"; }
        }

        public enum EmailType {
            Normal,
            TestSendEmail,
            TestDownloadEmail
        }

        private static Regex emailIdExp = new Regex("<EmailId>([0-9]+)</EmailId>", RegexOptions.Compiled);
        private static Regex exceptionExp = new Regex("<ExceptionMessage>([^<]*)</ExceptionMessage><ExceptionStackTrace>([^<]*)</ExceptionStackTrace>", RegexOptions.Compiled);

        public static int SendEmailRequest(string url, string from, string to, string cc, string bcc,
            int activityId, int tenantId, int userId, string consumerKey, string producerKey,
            bool storeContent, EmailType type) {

            from = EmailFunctions.Normalize(from);
            to = EmailFunctions.Normalize(to);
            cc = EmailFunctions.Normalize(cc);
            bcc = EmailFunctions.Normalize(bcc);

            if (to.IsEmpty() && cc.IsEmpty() && bcc.IsEmpty()) {
                throw new InvalidOperationException("Error creating email. There must be at least one recipient.");
            }

            try {
                int emailId = 0;

                url = url
                    + (url.Contains("?") ? "&" : "?")
                    + "_From=" + HttpUtility.UrlEncode(from)
                    + "&_To=" + HttpUtility.UrlEncode(to)
                    + "&_CC=" + HttpUtility.UrlEncode(cc)
                    + "&_BCC=" + HttpUtility.UrlEncode(bcc)
                    + "&_ActivityId=" + activityId
                    + "&_TenantId=" + tenantId
                    + "&_UserId=" + userId
                    + "&_ProducerKey=" + producerKey
                    + "&_IsEmail=true"
                    + "&_StoreContent=" + ((storeContent || (type == EmailType.TestDownloadEmail)) ? "true" : "false")
                    + ((type == EmailType.TestSendEmail || type == EmailType.TestDownloadEmail) ? "&_IsTestEmail=true" : "");

                string baseUrl;
                EmailHelper.QueryParameter[] parameters;
                EmailHelper.SplitUrl(url, out baseUrl, out parameters);

                string content;
                string encoding;
                var authHeader = SecurityTokenManager.GenerateAuthorizationHeader(RuntimeSettingsProvider.Instance, consumerKey, producerKey, userId, tenantId);
                var headers = new Dictionary<HttpRequestHeader, string>();
                headers.Add(HttpRequestHeader.Authorization, authHeader);
                EmailHelper.HttpPost(baseUrl, parameters, headers, "", null, out content, out encoding);

                var exceptionMatch = exceptionExp.Match(content);
                if (exceptionMatch != Match.Empty) {
                    string message = HttpUtility.HtmlDecode(exceptionMatch.Groups[1].Value);
                    string stacktrace = HttpUtility.HtmlDecode(exceptionMatch.Groups[2].Value);
                    throw new EmailException("Error creating Email. " + message, stacktrace);
                } else {
                    var emailMatch = emailIdExp.Match(content);
                    if (emailMatch != Match.Empty)
                        emailId = Convert.ToInt32(emailMatch.Groups[1].Value);
                    else
                        throw new EmailException("Error creating Email. No EmailId was returned.");
                }

                if (type != EmailType.TestDownloadEmail) {
                    if (RuntimePlatformSettings.Sandbox.SandboxOperating.GetValue()) {
                        using (Transaction statusTransaction = DatabaseAccess.ForCurrentDatabase.GetCommitableTransaction()) {
                            DBRuntimePlatform.Instance.CreateEmailStatus(statusTransaction, emailId);
                            SendEmailNotifier.Current.NotifiyNewEmail();
                            statusTransaction.Commit();
                        }
                    } else {
                        using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                            DBRuntimePlatform.Instance.CreateEmailStatus(trans, emailId);
                        }
                    }
                }
                return emailId;
            } catch (EmailException) {
                throw;
            } catch (Exception e) {
                throw new EmailException("Error creating Email.", e);
            }
        }

        [Obsolete("Deprecated, use overload with eSpaceId")]
        public static int CreateEmail(string bodyUrl, string emailBody,
            string from, string to, string cc, string bcc,
            int activityId, string emailDefSSKey, bool storeContent,
            List<String> headers, List<EmailAttachment> attachments, string realHostname) {

            return CreateEmail(bodyUrl, emailBody, from, to, cc, bcc, activityId, 0, 0, emailDefSSKey, storeContent, headers, attachments, realHostname);
        }

        internal static string CleanEmailBody(string emailBody) {
            // remove comments, scripts, and inputs, links with javascript hrefs
            emailBody = RemoveFromHtml(emailBody, "<!--", "-->", false);
            emailBody = RemoveAllTags(emailBody, "script", false);
            emailBody = RemoveAllTags(emailBody, "input", false);
            emailBody = RemoveAllTags(emailBody, "textarea", false);
            emailBody = RemoveAllTagsIf(emailBody, "a", a => a.ContainsIgnoreCase("javascript:") ||
                                                             a.ContainsIgnoreCase("onclick="), true);
            emailBody = RemoveAllTagsIf(emailBody, "span", span => span.ContainsIgnoreCase("id=\"ValidationMessage_"), false);
            return emailBody;
        }

        public static int CreateEmail(string bodyUrl, string emailBody,
            string from, string to, string cc, string bcc,
            int activityId, int tenantId, int eSpaceId, string emailDefSSKey, bool storeContent,
            List<String> headers, List<EmailAttachment> attachments, string realHostname) {

            return CreateEmail(bodyUrl, string.Empty, emailBody, from, to, cc, bcc,
                               activityId, tenantId, eSpaceId, emailDefSSKey, storeContent, headers,
                               attachments, realHostname, DeploymentZoneResolution.ByModuleKey(AppInfo.GetAppInfo().eSpaceUIDAsKey).Address);
        }



        public static int CreateEmail(string bodyUrl, string emailSubject, string emailBody,
            string from, string to, string cc, string bcc,
            int activityId, int tenantId, int eSpaceId, string emailDefSSKey, bool storeContent,
            List<String> headers, List<EmailAttachment> attachments, string realHostname, string zoneAddress) {

            NormalizeFields(ref from, ref to, ref cc, ref bcc);

            string subject = emailSubject;
            string charset = "UTF-8";

            Regex titleRe = ScriptableEmailFunctions.GetRegex("<title>([^<]*)</title>", RegexOptions.IgnoreCase);
            Match titleMatch = titleRe.Match(emailBody);
            if (titleMatch.Success) {
                subject = HttpUtility.HtmlDecode(titleMatch.Groups[1].Value.Trim());
            }

            emailBody = CleanEmailBody(emailBody);

            // #122347 TODO: process obtained emailBody to separate attachments from body

            string emailBoundary;
            string pathUrl = bodyUrl.Substring(0, bodyUrl.LastIndexOf('/') + 1);
            string messageId;
            string content;
            CreateEmail(false, // the email addresses need to be correctly formated already (using the provided functions), processing them would re-encode them
                               //multipart/related
                from, to, headers, cc, bcc, "", charset, subject, emailBody, true, pathUrl, true, "", MailUA, realHostname,
                zoneAddress, out emailBoundary, out content, out messageId);

            StringBuilder emailContent = new StringBuilder();

            emailContent.Append(content);

            if (attachments != null) {
                foreach (EmailAttachment att in attachments) {
                    string newPart;
                    string encodedFilename = att.FileName;
                    if (EmailEncoding.NeedsEncoding(Encoding.UTF8, att.FileName, EncodeFlags.QuotedPrintable)) {
                        encodedFilename = EmailEncoding.EncodeString(Encoding.UTF8, att.FileName, EncodeFlags.QuotedPrintable);
                    }
                    AddPart(HeaderFlags.ContentType | HeaderFlags.ContentDisposition, att.MimeType, null, emailBoundary, encodedFilename, null, att.FileContent, "base64", out newPart);
                    emailContent.Append(newPart);
                }
            }

            // Close email
            emailContent.Append("--" + emailBoundary + "--\r\n");
            emailContent.Append("\r\n");

            string finalContent = emailContent.ToString();
            int contentLen = finalContent.Length;
            UTF8Encoding encoder = new UTF8Encoding();

            byte[] byteContent = encoder.GetBytes(finalContent);

            using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                return DBRuntimePlatform.Instance.SaveEmail(trans,
                    EmailHelper.GetCleanEmailAddress(from),
                    EmailHelper.GetCleanEmailAddresses(to),
                    EmailHelper.GetCleanEmailAddresses(cc),
                    EmailHelper.GetCleanEmailAddresses(bcc),
                    subject, byteContent, contentLen, activityId, tenantId, eSpaceId, emailDefSSKey, storeContent, messageId,
                    AppInfo.GetAppInfo().Properties.EnableEmails,
                    AppInfo.GetAppInfo().Properties.TestEmails);
            }
        }

        public static void NormalizeFields(ref string from, ref string to, ref string cc, ref string bcc) {
            from = EmailFunctions.Normalize(from);
            to = EmailFunctions.Normalize(to);
            cc = EmailFunctions.Normalize(cc);
            bcc = EmailFunctions.Normalize(bcc);

            if (from.IsEmpty()) {
                string defaultOriginatorName = RuntimePlatformSettings.EMail.DefaultOriginatorName.GetValue();
                string defaultOriginatorEmail = RuntimePlatformSettings.EMail.DefaultOriginator.GetValue();
                if (string.IsNullOrEmpty(defaultOriginatorName) || string.IsNullOrEmpty(defaultOriginatorEmail)) {
                    throw new InvalidOperationException("The 'Default Sender Email' and 'Default Sender Name' must be set in Service Center's Email Configuration to send emails.");
                }
                from = EmailFunctions.Normalize(EmailFunctions.Compose(Encoding.UTF8, RuntimePlatformSettings.EMail.DefaultOriginatorName.GetValue(), RuntimePlatformSettings.EMail.DefaultOriginator.GetValue()));
            }
        }

        /// <summary>
        /// Initializes the production of an email message, creating its headers and main body. Note that this
        /// action does not immediately send the message, as you may want to add futher parts (attachments) to
        /// it (using <see cref="AddPart" />). To finalize message and send it you should then call RichMailSend
        /// </summary>
        /// <remarks>
        /// Older emails clients (such as some versions of Lotus and Outlook 2000) do not correctly support the MIME encoding used to send HTML emails. To enable HTML emails to be delivered correctly to these clients you can add &quot;lotus/compatible&quot; (without the quotes) to the ContentType. This will change how the whole email is created and allows those clients to shows the message properly at the expense of more recent email clients (such as Yahoo! Mail) that will not display the message correctly.
        /// </remarks>
        /// <param name="processAddresses">Pre-process the email addresses?</param>
        /// <param name="ssFrom">Email address of the sender</param>
        /// <param name="ssTo">Email addresses to send the email to (comma separated)</param>
        /// <param name="headers">Email header information</param>
        /// <param name="ssCc">Email addresses to carbon-copy the email to (comma separated)</param>
        /// <param name="ssBcc">Email addresses to blind carbon-copy the email to (comma separated)</param>
        /// <param name="ssContentType">MIME type of the message.</param>
        /// <param name="ssCharset">Character used in the message text</param>
        /// <param name="ssSubject">Subject of the message</param>
        /// <param name="ssBody">Text content of the message</param>
        /// <param name="ssBodyIsHtml">TRUE if content of the message is HTML rather than plain text</param>
        /// <param name="ssUrl">Base URL to use in case the Body is HTML. This allows any relative paths that may exist in the Body to be expanded to full blown URL's</param>
        /// <param name="ssIncludeImages">If TRUE, any images referenced via an URL in the Body are attached to the message</param>
        /// <param name="ssInReplyTo">Alternate reply-to email address</param>
        /// <param name="userAgent">User agent to use to request the email messages.</param>
        /// <param name="realHostname">The hostname to use when building links in the email body.</param>
        /// <param name="zoneAddress">Deploymentzoneadress of the running espace</param>
        /// <param name="ssBoundary">System marker that should be passed in to any further parts that are added to this message (see <see cref="AddPart" />).</param>
        /// <param name="ssMail">The full message text produced by the call</param>
        /// <param name="emailId">The created email id.</param>
        public static void CreateEmail(bool processAddresses, string ssFrom, string ssTo, List<String> headers, string ssCc, string ssBcc, string ssContentType, string ssCharset, string ssSubject, string ssBody, bool ssBodyIsHtml, string ssUrl, bool ssIncludeImages, string ssInReplyTo, string userAgent, string realHostname, string zoneAddress, out string ssBoundary, out string ssMail, out string emailId) {
            bool prepareMimeEncoding = true;
            //string base64 = null;
            bool use_multipart_related = true;
            ssBoundary = "";
            System.Text.StringBuilder sbMail = new System.Text.StringBuilder();

            if (realHostname == null) {
                throw new InvalidOperationException("The 'Default DNS Name' must be set in Service Center's Environment Configuration to send emails.");
            }

            // Cleanup the content type
            ssContentType = EmailHelper.TrimHeaderLine(ssContentType);

            // This is a hack to support Outlook 2000 and other clients
            // that do not support multipart/related.
            int tpos = ssContentType.ToUpper().IndexOf("LOTUS/COMPATIBLE");
            if (tpos >= 0) {
                ssContentType = ssContentType.Remove(tpos, 16);
                use_multipart_related = false;
            }

            // If no Content Type defined, set it to "multipart/mixed"
            if (ssContentType == "") {
                ssContentType = "multipart/mixed";
            }

            if (!ssContentType.ToLower().StartsWith("multipart")) {
                // If it's not a multipart message then don't encase in MIME containers
                prepareMimeEncoding = false;
            }

            if (ssBodyIsHtml) {
                prepareMimeEncoding = true;
            }

            // If no Content Type defined, set it to "multipart/mixed"
            if (ssCharset == "") {
                ssCharset = "iso-8859-1";
            } else {
                ssCharset = EmailHelper.TrimHeaderLine(ssCharset);
            }

            // Get a correct encoder
            System.Text.Encoding mailEncoding = System.Text.Encoding.GetEncoding(ssCharset);

            if (prepareMimeEncoding) {
                // Get a random boundary
                ssBoundary = EmailHelper.CreateRandomBoundary();
            } else {
                ssBoundary = "";
            }

            // Add date to email header
            sbMail.Append("Date: ");
            sbMail.Append(EmailHelper.GetEmailDate(System.DateTime.Now));
            sbMail.Append("\r\n");

            if (processAddresses) {
                ssFrom = EmailHelper.ProcessEmailAddresses(mailEncoding, ssFrom);
            }

            emailId = System.Guid.NewGuid().ToString().Replace("-", "") + "@" + RuntimePlatformSettings.EMail.ServerHost.GetValue();
            // Add the EmailID
            sbMail.Append("Message-ID: <" + emailId + ">\r\n");


            // Add from to email header
            sbMail.Append("From: ");
            sbMail.Append(ssFrom);
            sbMail.Append("\r\n");

            if (processAddresses) {
                // If any of the email addresses in the To field are in the format
                // "description <email address>", then encode with iso-8859-1 the description.
                ssTo = EmailHelper.ProcessEmailAddresses(mailEncoding, ssTo);
            }

            // Add to to email header
            sbMail.Append("To: ");
            sbMail.Append(ssTo);
            sbMail.Append("\r\n");

            // Add headers

            if (headers != null) {
                foreach (String header in headers) {
                    sbMail.Append(header);
                    sbMail.Append("\r\n");
                }
            }

            // If cc not empty, add it to email header
            if (ssCc != "") {
                if (processAddresses) {
                    // If any of the email addresses in the Cc field are in the format
                    // "description <email address>", then encode with iso-8859-1 the description.
                    ssCc = EmailHelper.ProcessEmailAddresses(mailEncoding, ssCc);
                }

                // Add it to the email header
                sbMail.Append("Cc: ");
                sbMail.Append(ssCc);
                sbMail.Append("\r\n");
            }

            ssInReplyTo = EmailHelper.TrimHeaderLine(ssInReplyTo);

            // Add In-Reply-To to email header
            if (ssInReplyTo != "") {
                sbMail.Append("In-Reply-To:");
                sbMail.Append(ssInReplyTo);
                sbMail.Append("\r\n");
            }

            ssSubject = EmailHelper.TrimHeaderLine(ssSubject);

            EncodeFlags headerEncodeFlags = EncodeFlags.SingleLine | EncodeFlags.QuotedPrintable;

            // Encode the subject
            if (EmailEncoding.NeedsEncoding(mailEncoding, ssSubject, headerEncodeFlags)) {
                ssSubject = EmailEncoding.EncodeString(mailEncoding, ssSubject, headerEncodeFlags);
            }

            // Add subject to email header
            sbMail.Append("Subject: ");
            sbMail.Append(ssSubject);
            sbMail.Append("\r\n");

            // Add content type to email header
            if (prepareMimeEncoding) {
                sbMail.Append("MIME-Version: 1.0\r\n");
            }
            if (prepareMimeEncoding) {
                sbMail.Append("Content-Type: " + ssContentType + "; boundary=\"" + ssBoundary + "\"\r\n");
            } else {
                sbMail.Append("Content-Type: " + ssContentType + "; charset=\"" + ssCharset + "\"\r\n");
                sbMail.Append("Content-Transfer-Encoding: base64\r\n");
            }

            //sbMail += "Content-Transfer-Encoding: base64\r\n";
            if (prepareMimeEncoding) {
                sbMail.Append("\r\n");

                // For older clients to display something
                sbMail.Append("This is a multi-part message in MIME format.\r\n");

                // Dump the starting boundary
                sbMail.Append("--" + ssBoundary + "\r\n");
            }

            // Add body header to email
            //System.Text.Encoding bodyEncoding = System.Text.Encoding.GetEncoding(ssCharset);
            if (ssBodyIsHtml) {
                // Outlook 2000 is too old by now and treats emails using MULTIPART/RELATED as 
                // MULTIPART/MIXED (which is standards compliant).
                // Thus if a tree like the following is used it will show an empty email
                // with two attachments. The first attachment is an email and a second one is the attachment file.
                //   Begin Message
                //     Begin Mixed Content
                //       Begin Related Contnt
                //         Begin Alternative Content
                //           Plain text message
                //           HTML Message message
                //         End Alternative Content
                //         Image
                //       End Related Content
                //       Attachment
                //     End Mixed Content  
                //   End Message
                // 
                // To avoid this we now have a flag that disables the use of MULTIPART/RELATED
                // and uses a tree like this :
                //   Begin Message
                //     Begin Mixed Content
                //       Begin Alternative Content
                //         Plain text message
                //         HTML Message message
                //       End Alternative Content
                //       Image
                //       Attachment
                //     End Mixed Content  
                //   End Message

                string relatedBoundary = null;
                if (use_multipart_related) {
                    relatedBoundary = EmailHelper.CreateRandomBoundary();
                }

                string alternateBoundary = EmailHelper.CreateRandomBoundary();
                string normBody;
                Hashtable uri2cidMap;
                StringCollection uris;

                // remove meta content type
                normBody = ScriptableEmailFunctions.GetRegex("<meta +http-equiv='?\"?content-type[^>]+>", RegexOptions.IgnoreCase).Replace(ssBody, "");

                // Place stylesheet inline
                var match = ScriptableEmailFunctions.GetRegex("<link [^>]*href=\"([^\"]+\\.css)(\\?[0-9_]+)?\"[^>]*>", RegexOptions.IgnoreCase).Match(normBody);
                if (match.Success) {
                    string css;
                    Uri absUri = null;
                    try {
                        absUri = new Uri(new Uri(ssUrl), match.Groups[1].Value);
                    } catch { }
                    if (absUri != null) {
                        string cssEncoding;
                        EmailHelper.HttpGet(absUri.AbsoluteUri, MailUA, null, out css, out cssEncoding);
                        css = EmailHelper.NormalizeCSS(css);
                        normBody = normBody.Substring(0, match.Index) + "<style>" + css + "</style>" + normBody.Substring(match.Index + match.Length, normBody.Length - match.Index - match.Length);
                    }
                }

                string returnBody;
                EmailHelper.HtmlProcessPaths(normBody, ssUrl, ssIncludeImages, use_multipart_related, out returnBody, out uris, out uri2cidMap);
                normBody = returnBody;

                // Replace localhost with the real name for any unescaped link that occurred (normal destinations are already ok)
                if (realHostname != null) { //just for sanity check
                    normBody = ReplaceLinksWithEnvAddress(realHostname, zoneAddress, normBody);
                }

                string images = EmailHelper.HtmlFetchImages(ssIncludeImages, ssBoundary, use_multipart_related, relatedBoundary, uri2cidMap, userAgent);
                EmailHelper.HtmlAppendImages(ssCharset, EmailEncoding.MaxEncodedLength, use_multipart_related, sbMail, mailEncoding, relatedBoundary, alternateBoundary, normBody, images);

            } else if (ssBody != "") {
                if (prepareMimeEncoding) {
                    sbMail.Append("Content-Type: text/plain; charset=\"" + ssCharset + "\"\r\n");
                    sbMail.Append("Content-Transfer-Encoding: base64\r\n");
                }
                sbMail.Append("\r\n");

                // Encode body and add it to the email
                sbMail.Append(EmailEncoding.GetBase64TextBlock(mailEncoding.GetBytes(ssBody), EmailEncoding.MaxEncodedLength));
            } else {
                sbMail.Append("\r\n");
            }

            ssMail = sbMail.ToString();
        } // CreateEmail

        private static string ReplaceLinksWithEnvAddress(string realHostname, string zoneAddress, string normBody) {
            string addressesToRemove = 
                new List<string>() { "localhost",
                    "127.0.0.1",
                    zoneAddress,
                    RuntimePlatformSettings.Misc.InternalAddress.GetValue()
                }.Select(s => Regex.Escape(s)).StrCat("|") + RuntimePlatformSettings.EMail.UrlsToExcludeOnRender.GetValue();
            return Regex.Replace(normBody, @"(\s+href=['""]http[s]{0,1}://)(" + addressesToRemove + @")([""'/])", @"$1" + realHostname.Replace("$", "$$") + @"$3", RegexOptions.IgnoreCase);
        }

        public static void AddPart(HeaderFlags flags, string ssContentType, string ssContentID, string ssBoundary, string ssFilename, string ssLocation, byte[] ssContent, string ssContentTransferEncod, out string ssoPart) {
            System.Text.StringBuilder ssPart = new System.Text.StringBuilder();
            // Define the line size

            int linelength = EmailEncoding.MaxLineLength;

            // Add starting boundary
            ssPart.Append("--" + ssBoundary + "\r\n");

            if ((flags & HeaderFlags.ContentType) == HeaderFlags.ContentType) {
                // Add the attachment Content type and encoding
                ssPart.Append("Content-Type: " + (ssContentType.IsEmpty() ? "application/octet-stream" : ssContentType) + "");

                // If a filename was given add description and disposition
                if (ssFilename != "") {
                    ssPart.Append("; name=\"" + ssFilename + "\"\r\n");
                    if ((flags & HeaderFlags.ContentDescription) == HeaderFlags.ContentDescription) {
                        ssPart.Append("Content-Description: " + ssFilename + "\r\n");
                    }
                    if ((flags & HeaderFlags.ContentDisposition) == HeaderFlags.ContentDisposition) {
                        ssPart.Append("Content-Disposition: attachment; filename=\"" + ssFilename + "\"\r\n");
                    } else if ((flags & HeaderFlags.ContentDispositionInline) == HeaderFlags.ContentDispositionInline) {
                        ssPart.Append("Content-Disposition: inline; filename=\"" + ssFilename + "\"\r\n");
                    }
                } else {
                    ssPart.Append("; charset=\"iso-8859-1\"\r\n");
                    ssPart.Append("Content-Disposition: inline\r\n");
                }
            }

            if ((flags & HeaderFlags.ContentID) == HeaderFlags.ContentID) {
                if (ssContentID != "") {
                    ssPart.Append("Content-ID: <" + ssContentID + ">\r\n");
                }
            }

            ssContentTransferEncod = ssContentTransferEncod.ToLower();
            ssPart.Append("Content-Transfer-Encoding: " + ssContentTransferEncod + "\r\n");

            // If a location was given add it to the attachment header
            if ((flags & HeaderFlags.Location) == HeaderFlags.Location) {
                if (ssLocation != "") {
                    ssPart.Append("Content-Location: " + ssLocation + "\r\n");
                }
            }

            switch (ssContentTransferEncod) {
                case "base64":
                    // Encode the binary part to base64 and add it to the attachment
                    int base64Length;
                    string base64 = EmailEncoding.GetBase64TextBlock(ssContent, linelength, out base64Length);
                    ssPart.Append("Content-Length: " + base64Length + "\r\n");
                    ssPart.Append("\r\n");
                    ssPart.Append(base64);
                    break;
                case "binary":
                    ssPart.Append("Content-Length: " + ssContent.Length + "\r\n");
                    ssPart.Append("\r\n");
                    foreach (byte bte in ssContent) {
                        ssPart.Append(Convert.ToChar(bte));
                    }
                    ssPart.Append("\r\n");
                    break;
                default:
                    if ((ssContentTransferEncod == null) || (ssContentTransferEncod == "")) {
                        throw new InvalidOperationException("Empty Content Transfer Encoding not supported");
                    }
                    throw new InvalidOperationException("Content Transfer Encoding " + ssContentTransferEncod + " not supported");
            }

            ssoPart = ssPart.ToString();
        }


        private delegate bool HtmlTagFilter(string startTag);

        private static string RemoveAllTags(string inputHtml, string tagName, bool preserveContents) {
            return RemoveAllTagsIf(inputHtml, tagName, dummy => true, preserveContents);
        }

        private static string RemoveAllTagsIf(string inputHtml, string tagName, HtmlTagFilter @if, bool preserveContents) {
            return RemoveFromHtmlIf(inputHtml,
                "<\\s*{0}\\b[^>]*>".F(Regex.Escape(tagName)),
                "</\\s*{0}\\b[^>]*>".F(Regex.Escape(tagName)),
                @if,
                preserveContents);
        }

        private static string RemoveFromHtml(string inputHtml, string startReExpr, string endReExpr, bool preserveContents) {
            return RemoveFromHtmlIf(inputHtml, startReExpr, endReExpr, dummy => true, preserveContents);
        }

        private static string RemoveFromHtmlIf(string inputHtml, string startReExpr, string endReExpr, HtmlTagFilter @if, bool preserveContents) {
            Regex startRe = ScriptableEmailFunctions.GetRegex(startReExpr, RegexOptions.IgnoreCase | RegexOptions.ExplicitCapture);
            Regex endRe = ScriptableEmailFunctions.GetRegex(endReExpr, RegexOptions.IgnoreCase | RegexOptions.ExplicitCapture);

            StringBuilder sb = new StringBuilder(inputHtml.Length);
            int inputIndex = 0;

            var startMc = startRe.Matches(inputHtml);
            foreach (Match startMatch in startMc) {
                if (@if(startMatch.Value)) {
                    // Include everything up to startMatch
                    sb.Append(inputHtml.Substring(inputIndex, startMatch.Index - inputIndex));
                    inputIndex = startMatch.Index + startMatch.Length;

                    var endMatch = endRe.Match(inputHtml, startMatch.Index + startMatch.Length);
                    if (endMatch.Success) {
                        if (preserveContents) {
                            // Include everything up to endMatch
                            sb.Append(inputHtml.Substring(inputIndex, endMatch.Index - inputIndex));
                            inputIndex = endMatch.Index + endMatch.Length;
                        } else {
                            // Do not include anything, just update inputIndex
                            inputIndex = endMatch.Index + endMatch.Length;
                        }
                    }
                } else {
                    // Include the match
                    sb.Append(inputHtml.Substring(inputIndex, startMatch.Index + startMatch.Length - inputIndex));
                    inputIndex = startMatch.Index + startMatch.Length;
                }
            }

            // Include the remaining of the inputHtml
            sb.Append(inputHtml.Substring(inputIndex));

            return sb.ToString();
        }

        private static string RemoveFromHtmlFormActionAndOnSubmit(string inputHtml) {
            Regex formPattern = ScriptableEmailFunctions.GetRegex("<\\s*form\\b[^>]*>", RegexOptions.IgnoreCase);
            Regex actionPattern = ScriptableEmailFunctions.GetRegex("action=(?:(?:\"[^\"]*\")|(?:'[^']*'))", RegexOptions.IgnoreCase);
            Regex onSubmitPattern = ScriptableEmailFunctions.GetRegex("onsubmit=(?:(?:\"[^\"]*\")|(?:'[^']*'))", RegexOptions.IgnoreCase);

            StringBuilder sb = new StringBuilder(inputHtml.Length);
            int inputIndex = 0;
            Match startMatch = formPattern.Match(inputHtml);

            // Include the text up to match
            sb.Append(inputHtml.Substring(inputIndex, startMatch.Index));
            inputIndex = startMatch.Index + startMatch.Length;

            //Append modified match
            sb.Append(onSubmitPattern.Replace(actionPattern.Replace(startMatch.Value, "action=\"-\""), "onsubmit=\"\""));

            // Include the remaining of the inputHtml
            sb.Append(inputHtml.Substring(inputIndex));

            return sb.ToString();
        }
    }

}
