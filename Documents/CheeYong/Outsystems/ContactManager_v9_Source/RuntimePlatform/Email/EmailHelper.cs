/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net;
using System.Text;
using System.Text.RegularExpressions;
using System.Web;
using OutSystems.RuntimeCommon;

namespace OutSystems.HubEdition.RuntimePlatform.Email {

    public class EmailHelper {

        // Generates a new boundary, based on a time stamp
        internal static string CreateRandomBoundary() {
            return "----=_NextPart_:_" + Guid.NewGuid().ToString();
        } // GetRandomBoundary

        // Left public because testing console needs this
        public static string GetEmailDate(DateTime dateTime) {
            string datestr = dateTime.ToString("ddd, dd MMM yyyy HH:mm:ss zzz", DateTimeFormatInfo.InvariantInfo);
            datestr = datestr.Substring(0, datestr.Length - 3) + datestr.Substring(datestr.Length - 2);
            return datestr;
        }

        private static char[] ControlChars = new char[] {
            '\x00', '\x01', '\x02', '\x03', '\x04', '\x05', '\x06', '\x07',
            '\x08', '\x09', '\x0A', '\x0B', '\x0C', '\x0D', '\x0E', '\x0F',
            '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
            '\x18', '\x19', '\x1A', '\x1B', '\x1C', '\x1D', '\x1E', '\x1F'
        };

        private static string RemoveControlCodes(string header) {
            if (header == null) return null;
            foreach (char ch in ControlChars) {
                header = header.Replace("" + ch, "");
            }
            return header;
        }

        internal static string TrimHeaderLine(string header) {
            if (header == null) return null;
            return header.Trim(ControlChars.Concat((char)'\x20').ToArray());
        }

        public class QueryParameter {
            public string Name;
            public string Value;
        }

        public static void SplitUrl(string ssUrl, out string ssBaseUrl, out QueryParameter[] parameters) {
            int queryStringSeparatorPos = ssUrl.IndexOf('?');
            ssBaseUrl = queryStringSeparatorPos == -1 ? ssUrl : ssUrl.Substring(0, queryStringSeparatorPos);
            string queryString = queryStringSeparatorPos == -1 ? null : ssUrl.Substring(queryStringSeparatorPos + 1);

            string[] queryStringParameters = queryString.SafeSplit('&').Where(p => !p.IsEmpty()).ToArray();
            parameters = new QueryParameter[queryStringParameters.Length];
            for (int i = 0; i < queryStringParameters.Length; i++) {
                string queryStringParameter = queryStringParameters[i];
                int nameValueSeparatorPos = queryStringParameter.IndexOf('=');
                parameters[i] = new QueryParameter() {
                    Name = nameValueSeparatorPos == -1 ? queryStringParameter : queryStringParameter.Substring(0, nameValueSeparatorPos),
                    Value = nameValueSeparatorPos == -1 ? "" : HttpUtility.UrlDecode(queryStringParameter.Substring(nameValueSeparatorPos + 1))
                };
            }
        }

        public static void HttpGet(string ssUrl, string userAgent, Cookie cookie, out string ssContent, out string ssContentEncoding) {
            HttpGetContent(Internal.ModuleUrlTranformations.ReplaceLoopbackAddressByModuleZone(ssUrl), null, null, userAgent, cookie, null, null, out ssContent, out ssContentEncoding);
        }

        public static void HttpPost(string ssUrl, QueryParameter[] parameters, IDictionary<HttpRequestHeader, string> headers, string userAgent, Cookie cookie, out string ssContent, out string ssContentEncoding) {
            HttpGetContent(new Uri(ssUrl), "POST", "application/x-www-form-urlencoded", userAgent, cookie, parameters, headers, out ssContent, out ssContentEncoding);
        }

        /// <summary>
        /// Downloads Text content from the specified URL
        /// </summary>
        /// <param name="ssUrl">URL to get the content from</param>
        /// <param name="method">The request method.</param>
        /// <param name="contentType">The request contentType header</param>
        /// <param name="userAgent">The request userAgent.</param>
        /// <param name="cookie">Cookie to use in the request.</param>
        /// <param name="parameters">Query parameters for the request.</param>
        /// <param name="headers">HTTP headers for the request.</param>
        /// <param name="ssContent">Actual text content downloaded from URL</param>
        /// <param name="ssContentEncoding">The Content enconding.</param>
        public static void HttpGetContent(Uri ssUrl, string method, string contentType, string userAgent, Cookie cookie, QueryParameter[] parameters, IDictionary<HttpRequestHeader, string> headers, out string ssContent, out string ssContentEncoding) {
            ssContent = "";
            OSTrace.Debug("EmailHelder.HttpGetContent: url: {0}".F(ssUrl));
            HttpWebRequest req = (HttpWebRequest)HttpWebRequest.Create(ssUrl);
            if (method != null) {
                req.Method = method;
            }
            if (contentType != null) {
                req.ContentType = contentType;
            }
            req.AllowAutoRedirect = true;
            req.UserAgent = userAgent;
            if (headers != null) {
                foreach (var header in headers) {
                    req.Headers.Add(header.Key, header.Value);
                }
            }
            req.CookieContainer = new CookieContainer();
            if (cookie != null) {
                req.CookieContainer.Add(cookie);
            }

            if (parameters != null) {
                string urlEncodedParameters = parameters.Select(p => p.Name + "=" + HttpUtility.UrlEncode(p.Value)).StrCat("&");

                using (var requestWriter = new StreamWriter(req.GetRequestStream())) {
                    requestWriter.Write(urlEncodedParameters);
                }
            }

            using (HttpWebResponse resp = (HttpWebResponse)req.GetResponse()) {
                Encoding encoding = null;

                // try get charset from response Content Type
                try {
                    Match charsetMatch = ScriptableEmailFunctions.GetRegex("charset=\"?(.*)\"?", RegexOptions.IgnoreCase).Match(resp.ContentType);
                    if (charsetMatch.Success) {
                        encoding = Encoding.GetEncoding(charsetMatch.Groups[1].Value);
                    }
                } catch {
                }
                if (encoding == null) {
                    encoding = Encoding.ASCII;
                }
                using (var sr = new StreamReader(resp.GetResponseStream(), encoding)) {
                    ssContent = sr.ReadToEnd();
                    OSTrace.Debug("EmailHelder.HttpGetContent: url: {0} ssContentLength: {1} status: {2}".F(ssUrl, ssContent.Length, resp.StatusCode));
                }
                ssContentEncoding = resp.ContentEncoding;
            }
        } // HttpGet

        /// <summary>
        /// Downloads Binary content from the specified URL
        /// </summary>
        /// <param name="ssUrl">URL to get the content from</param>
        /// <param name="userAgent">The request userAgent.</param>
        /// <param name="ssContentType">MIME type of downloaded content</param>
        /// <param name="ssContent">Actual binary content downloaded from URL</param>
        public static void HttpBinaryGet(string ssUrl, string userAgent, out string ssContentType, out byte[] ssContent) {
            ssContentType = "";

            HttpWebRequest req = (HttpWebRequest)HttpWebRequest.Create(Internal.ModuleUrlTranformations.ReplaceLoopbackAddressByModuleZone(ssUrl));
            req.AllowAutoRedirect = true;
            req.Accept = "image/gif, image/jpeg, */*";
            req.UserAgent = userAgent;

            using (HttpWebResponse resp = (HttpWebResponse)req.GetResponse()) {
                ssContent = StreamUtils.ToArray(resp.GetResponseStream());
                // content type
                ssContentType = resp.ContentType;
            }
        } // HttpBinaryGet

        /// <summary>
        /// Removes tags from an HTML string, producing a clean text version of the input
        /// </summary>
        /// <param name="html">The HTML text to be converted</param>
        /// <returns>The resulting text</returns>
        public static string HtmlToText(string html) {
            string lineBreak = "-----------LB------------";
            // Strip out title tag
            html = ScriptableEmailFunctions.GetRegex(@"<title[^>]*>(.*?)</title[^>]*>", RegexOptions.IgnoreCase | RegexOptions.Singleline).Replace(html, String.Empty);

            // Strip out script tags
            html = ScriptableEmailFunctions.GetRegex(@"<script[^>]*>.*?</script[^>]*>", RegexOptions.IgnoreCase | RegexOptions.Singleline).Replace(html, String.Empty);

            // Strip comments
            html = ScriptableEmailFunctions.GetRegex(@"<!--.*?-->", RegexOptions.IgnoreCase | RegexOptions.Singleline).Replace(html, String.Empty);

            // Strip out style tags
            html = ScriptableEmailFunctions.GetRegex(@"<style[^>]*>.*?</style[^>]*>", RegexOptions.IgnoreCase | RegexOptions.Singleline).Replace(html, String.Empty);

            // Line Breaks
            html = ScriptableEmailFunctions.GetRegex(@"<\s*(br|h[1-3]|p|div|tr|li)[^>]*>", RegexOptions.IgnoreCase | RegexOptions.Singleline).Replace(html, lineBreak);
            //html = GetRegex( @"<\s*h1[^>]*>", RegexOptions.IgnoreCase | RegexOptions.Singleline).Replace(HTML, lineBreak);
            //html = GetRegex( @"<\s*h2[^>]*>", RegexOptions.IgnoreCase | RegexOptions.Singleline).Replace(HTML, lineBreak);
            //html = GetRegex( @"<\s*h3[^>]*>", RegexOptions.IgnoreCase | RegexOptions.Singleline).Replace(HTML, lineBreak);
            //html = GetRegex( @"<\s*p[^>]*>", RegexOptions.IgnoreCase | RegexOptions.Singleline).Replace(HTML, lineBreak);
            //html = GetRegex( @"<\s*div[^>]*>", RegexOptions.IgnoreCase | RegexOptions.Singleline).Replace(HTML, lineBreak);
            //html = GetRegex( @"<\s*tr[^>]*>", RegexOptions.IgnoreCase | RegexOptions.Singleline).Replace(HTML, lineBreak);
            //html = GetRegex( @"<\s*li[^>]*>", RegexOptions.IgnoreCase | RegexOptions.Singleline).Replace(HTML, lineBreak);
            html = ScriptableEmailFunctions.GetRegex(@"</\s*(ul|ol)[^>]*>", RegexOptions.IgnoreCase | RegexOptions.Singleline).Replace(html, lineBreak);
            //html = GetRegex( @"</\s*ol[^>]*>", RegexOptions.IgnoreCase | RegexOptions.Singleline).Replace(HTML, lineBreak);

            // Strip out html tags
            html = ScriptableEmailFunctions.GetRegex(@"<[/!]*?[^<>]*?>", RegexOptions.IgnoreCase | RegexOptions.Singleline).Replace(html, " ");

            // colapse spaces and \n
            html = ScriptableEmailFunctions.GetRegex(@"\s+", RegexOptions.Singleline).Replace(html, " ");

            //put linebreaks back
            html = ScriptableEmailFunctions.GetRegex(lineBreak).Replace(html, "\r\n");

            // Replace html entities			
            html = ReplaceHtmlEntities(html);

            //trim spaces
            html = ScriptableEmailFunctions.GetRegex(@"[ \xA0]+\r\n", RegexOptions.Multiline).Replace(html, "\r\n");

            //trim blank lines
            html = ScriptableEmailFunctions.GetRegex(@"(\r\n){3,}", RegexOptions.Multiline).Replace(html, "\r\n\r\n");

            //trim start
            html = ScriptableEmailFunctions.GetRegex(@"^(\r\n)*", RegexOptions.Singleline).Replace(html, "");

            //trim end
            html = ScriptableEmailFunctions.GetRegex(@"\s*$", RegexOptions.Singleline).Replace(html, "");

            return html;
        }

        private static string ReplaceHtmlEntities(string html) {
            return ScriptableEmailFunctions.GetRegex(@"&[^;]{2,7};").Replace(html, new MatchEvaluator(HTMLDecode));
        }

        /// <summary>
        /// Delegate that decodes HTML when matches are found by HtmlToText
        /// </summary>
        /// <param name="match">Match found by the regexps</param>
        /// <returns>Decoded text</returns>
        private static string HTMLDecode(Match match) {
            return HttpUtility.HtmlDecode(match.Value);
        }

        private static Pair<Regex, string>[] normalizeCSSRegexs;
        public static string NormalizeCSS(string css) {
            if (normalizeCSSRegexs == null) {
                normalizeCSSRegexs = new Pair<Regex, string>[] {
                    Pair.Create(ScriptableEmailFunctions.GetRegex("/\\*.*?\\*/", RegexOptions.Singleline), ""),
                    Pair.Create(ScriptableEmailFunctions.GetRegex("^[ \t]+"), ""),
                    Pair.Create(ScriptableEmailFunctions.GetRegex("[ \t]+$"), ""),
                    Pair.Create(ScriptableEmailFunctions.GetRegex("[\r\n]+"), "\r\n"),
                    Pair.Create(ScriptableEmailFunctions.GetRegex("[ \t]+"), " ")
                };
            }
            foreach (Pair<Regex, string> regex in normalizeCSSRegexs) {
                css = regex.First.Replace(css, regex.Second);
            }
            return css;
        }

        // Left public because testing console needs this
        public static string ProcessEmailAddresses(Encoding encoding, string addresses) {
            StringBuilder new_addresses = new StringBuilder();

            string[] address_array = addresses.Split(',', ';');

            EncodeFlags flags = EncodeFlags.SingleLine | EncodeFlags.QuotedPrintable;

            foreach (string address_item in address_array) {
                string new_address_item = TrimHeaderLine(RemoveControlCodes(address_item));
                new_address_item = EmailFunctions.EncloseEmail(new_address_item);

                if (new_address_item.Length > 0) {
                    if (new_address_item.IndexOf("<") > 0) {
                        string desc = new_address_item.Substring(0, new_address_item.IndexOf("<") - 1);
                        string address = new_address_item.Substring(new_address_item.IndexOf("<") - 1, new_address_item.Length - new_address_item.IndexOf("<") + 1);
                        if (address != null) {
                            address = TrimHeaderLine(address);
                        }
                        if (EmailEncoding.NeedsEncoding(encoding, desc, flags)) {
                            new_addresses.Append(", " + EmailEncoding.EncodeString(encoding, desc, flags) + address);
                        } else {
                            new_addresses.Append(", " + new_address_item);
                        }
                    } else {
                        new_addresses.Append(", " + new_address_item);
                    }
                }
            }
            return new_addresses.ToString().TrimStart(',').TrimStart();
        }

        // Parses an HTML body looking for elements with src or href attributes
        // and trying to resolve the uri's into absolute uris.
        // If calcCIDs is set it will assign a ContentID to each image
        // If replaceByCIDs is set it will replace the image url with a CID url
        internal static void HtmlProcessPaths(string html, string url, bool calcCIDs, bool replaceByCIDs, out string result, out StringCollection uris, out Hashtable uri2cidMap) {
            StringBuilder sb = new StringBuilder(html);
            uris = new StringCollection();
            uri2cidMap = new Hashtable();

            //#33590 - Added [^#] to the regular expression to make it skip named anchors inside the same page (relative named anchors) 
            //#382261 - Added support url's already using data URI schemes data: cid: mid:
            Regex regex = ScriptableEmailFunctions.GetRegex("([^\\(]\\s+src|\\s+href)=['\"]((data:|cid:|mid:)?[^#][^'\"]*)['\"]", RegexOptions.IgnoreCase);
            int originalHTMLoffsetDifference = 0;
            foreach (Match match in regex.Matches(html)) {
                bool dataUriSchemeFound = match.Groups[3].Success;
                if (dataUriSchemeFound) {
                    continue;
                }

                string g1 = match.Groups[1].Value;
                string imgUrl = match.Groups[2].Value;

                Uri absUri = null;
                try {
                    absUri = new Uri(new Uri(url), imgUrl);
                } catch { }
                if (absUri != null) {
                    string absoluteUrl = absUri.AbsoluteUri;
                    string newurl = absoluteUrl;

                    if (!uris.Contains(absoluteUrl)) {
                        if ((calcCIDs) && (g1.ToLower().Substring(g1.Length - 3, 3) == "src")) {
                            string cid = Guid.NewGuid().ToString();
                            uri2cidMap.Add(absoluteUrl, cid);
                            newurl = string.Concat("cid:", cid);
                        }
                        uris.Add(absoluteUrl);
                    } else {
                        string cid = (string)uri2cidMap[absoluteUrl];
                        if (cid != null) {
                            newurl = string.Concat("cid:", cid);
                        }
                    }

                    if (newurl != imgUrl) {
                        if (replaceByCIDs) {
                            sb.Replace(imgUrl,
                                newurl,
                                match.Groups[2].Index + originalHTMLoffsetDifference,
                                match.Groups[2].Length);

                            originalHTMLoffsetDifference += newurl.Length - imgUrl.Length;
                        } else {
                            sb.Replace(imgUrl,
                                absoluteUrl,
                                match.Groups[2].Index + originalHTMLoffsetDifference,
                                match.Groups[2].Length);

                            originalHTMLoffsetDifference += absoluteUrl.Length - imgUrl.Length;
                        }
                    }
                    //html = html.Substring(0,mat.Groups[2].Index) + absoluteUrl + html.Substring(mat.Groups[2].Index+mat.Groups[2].Length);
                }
            }

            result = ScriptableEmailFunctions.GetRegex("/\\(........................\\)/").Replace(sb.ToString(), "/");
        }

        internal static string HtmlFetchImages(bool ssIncludeImages, string ssBoundary, bool use_multipart_related, string relatedBoundary, Hashtable uri2cidMap, string userAgent) {
            // Fetch images
            string images = "";
            if (ssIncludeImages) {
                IDictionaryEnumerator en = uri2cidMap.GetEnumerator();
                while (en.MoveNext()) {
                    string cid = (string)en.Value;
                    string url = (string)en.Key;
                    byte[] content;
                    string contentType;
                    string attach;
                    Uri absUri = null;
                    try {
                        absUri = new Uri(url);
                    } catch { }
                    if (absUri != null) {
                        string absoluteUrl = absUri.AbsoluteUri;
                        HeaderFlags flags = HeaderFlags.ContentID | HeaderFlags.ContentType | HeaderFlags.ContentDispositionInline | HeaderFlags.Location;

                        try {
                            // Fetch the file content
                            HttpBinaryGet(absoluteUrl, userAgent, out contentType, out content);
                        } catch (Exception e) {
                            throw new InvalidOperationException("Unable to fetch '" + absoluteUrl + "' to include in email", e);
                        }

                        // Try to get the content filename from the Uri
                        string filename = "";
                        try {
                            filename = absUri.AbsolutePath;
                            filename = Path.GetFileName(filename);
                        } catch {
                            filename = "";
                        }

                        // Create the image attachment
                        if (use_multipart_related) {
                            EmailProcessor.AddPart(flags, contentType, cid, relatedBoundary, filename, "", content, "base64", out attach);
                        } else {
                            EmailProcessor.AddPart(flags, contentType, cid, ssBoundary, filename, absoluteUrl, content, "base64", out attach);
                        }

                        // Append it to the images blob
                        images += attach;
                    }
                }
            }
            return images;
        }

        internal static void HtmlAppendImages(string ssCharset, int linelength, bool use_multipart_related, StringBuilder sbMail, Encoding mailEncoding, string relatedBoundary, string alternateBoundary, string normBody, string images) {
            if (use_multipart_related) {
                sbMail.Append("Content-Type: multipart/related; boundary=\"" + relatedBoundary + "\"\r\n");
                sbMail.Append("\r\n");

                sbMail.Append("--" + relatedBoundary + "\r\n");
            } else {
                // #14440: Do nothing as starting boundary was already dumped above
            }
            sbMail.Append("Content-Type: multipart/alternative; boundary=\"" + alternateBoundary + "\"\r\n");
            sbMail.Append("\r\n");

            sbMail.Append("--" + alternateBoundary + "\r\n");
            sbMail.Append("Content-Type: text/plain; charset=\"" + ssCharset + "\"\r\n");
            sbMail.Append("Content-Transfer-Encoding: base64\r\n");
            sbMail.Append("\r\n");

            string plainText = HtmlToText(normBody);

            sbMail.Append(EmailEncoding.GetBase64TextBlock(mailEncoding.GetBytes(plainText), linelength));

            sbMail.Append("--" + alternateBoundary + "\r\n");
            sbMail.Append("Content-Type: text/html; charset=\"" + ssCharset + "\"\r\n");
            sbMail.Append("Content-Transfer-Encoding: base64\r\n");
            sbMail.Append("\r\n");

            sbMail.Append(EmailEncoding.GetBase64TextBlock(mailEncoding.GetBytes(normBody), linelength));

            sbMail.Append("--" + alternateBoundary + "--\r\n");
            sbMail.Append(images);
            if (use_multipart_related) {
                sbMail.Append("--" + relatedBoundary + "--\r\n");
            } else {
                sbMail.Append("\r\n");
            }
        }

        // Receives an email in a valid format for an email header, and returns just the
        //	trimmed email address, removing all the other text and delimiters ('<' and '>').
        public static string GetCleanEmailAddress(string address) {
            Match match = ScriptableEmailFunctions.GetRegex("<([^>]+)>").Match(address);
            if (match != Match.Empty) {
                return match.Groups[1].Value.Trim();
            }
            return address.Trim();
        } // GetCleanEmailAddress

        public static string GetCleanEmailAddresses(string addresses) {
            return GetCleanEmailAddresses(addresses, ", ");
        }

        public static string GetCleanEmailAddresses(string addresses, string separator) {
            return addresses.SafeSplit(',').Select(addr => GetCleanEmailAddress(addr)).StrCat(separator);
        }

        internal static Hashtable GetHeaders(string email, int start, int maxpos) {
            Hashtable headers = CollectionsUtil.CreateCaseInsensitiveHashtable();
            while (start < maxpos) {
                int headerstart = start;
                int headerend = start;
                int lineend = -1;
                lineend = email.IndexOf("\n", headerstart, maxpos - headerstart);
                while ((email[lineend + 1] == ' ') || (email[lineend + 1] == '\t')) {
                    lineend = email.IndexOf("\n", lineend + 1, ((lineend + 1) + (maxpos - headerstart) < email.Length ? (maxpos - headerstart) : email.Length - (lineend + 1)));
                }
                headerend = lineend + 1;
                if (headerend == 0) {
                    headerend = email.Length - 1;
                }
                string headerline = email.Substring(headerstart, headerend - headerstart).Trim();
                int header_divider_pos = headerline.IndexOf(":");
                string header = headerline.Substring(0, header_divider_pos).Trim();
                string header_value = headerline.Substring(header_divider_pos + 1).Trim();
                if (headers[header] == null) {
                    headers[header] = new ArrayList();
                }
                ((ArrayList)headers[header]).Add(header_value);
                start = headerend;
            }
            return headers;
        }

        private static string RemoveHeaderLine(string header, string email, int start, int maxpos) {
            header = header.Trim();
            if (!header.EndsWith(":")) header += ":";
            int headerstart = start;
            int headerbeggining = start;
            do {
                headerstart = email.IndexOf(header, start, maxpos);
                if (headerstart != start) {
                    headerbeggining = 1 + email.LastIndexOf("\n", start, headerstart);
                    if (headerbeggining != headerstart) {
                        headerstart = headerbeggining + 1;
                    }
                }
            } while (headerbeggining != headerstart);
            int headerend = start;
            int lineend = -1;
            lineend = email.IndexOf("\n", headerstart, maxpos);
            while (email[lineend + 1] == ' ') {
                lineend = email.IndexOf("\n", lineend + 1, maxpos);
            }
            headerend = lineend + 1;
            email = email.Substring(0, headerstart) + email.Substring(headerend + 1);
            return email;
        }

        private static string GetHeaderLine(string header, string email, int start, int maxpos) {
            header = header.Trim();
            if (!header.EndsWith(":")) header += ":";
            int headerstart = start;
            int headerbeggining = start;
            do {
                headerstart = email.IndexOf(header, start, maxpos);
                if (headerstart != start) {
                    headerbeggining = 1 + email.LastIndexOf("\n", start, headerstart);
                    if (headerbeggining != headerstart) {
                        headerstart = headerbeggining + 1;
                    }
                }
            } while (headerbeggining != headerstart);
            int headerend = start;
            int lineend = -1;
            lineend = email.IndexOf("\n", headerstart, maxpos);
            while (email[lineend + 1] == ' ') {
                lineend = email.IndexOf("\n", lineend + 1, maxpos);
            }
            headerend = lineend + 1;
            header = email.Substring(headerstart, headerend - headerstart).Trim();
            return header;
        }

        internal static string GetHeaderSubfield(string headerline, string field) {
            string res = null;
            string span = null;
            if (headerline == null) return res;
            headerline = headerline.Trim();
            if (headerline.Length == 0) return res;
            headerline.Replace("\r\n", " ");
            int pos = 0;
            int state = 0;
            int start = -1;
            bool breakout = false;
            string subfield = null;
            string subvalue = null;
            while ((pos <= headerline.Length) && (!breakout)) {
                switch (state) {
                    case 0: {
                            if (pos == headerline.Length) {
                                breakout = true;
                                break;
                            }
                            // Evaluate if it's a regular token or a quoted value
                            if (headerline[pos] == '\"') {
                                start = pos;
                                state = 2;
                            } else {
                                start = pos;
                                state = 1;
                            }
                            break;
                        }
                    case 1: {
                            // It's a regular token, keep going until we hit a ';'
                            if ((pos == headerline.Length) || (headerline[pos] == ';')) {
                                span = headerline.Substring(start, pos - start);
                                state = 0;

                                if (span.IndexOf("=") > 0) {
                                    subfield = span.Substring(0, span.IndexOf("=")).Trim();
                                }
                                if (((subfield == null) && ((field == null || field.Length == 0))) || (string.Compare(subfield, field, true, CultureInfo.InvariantCulture) == 0)) {
                                    breakout = true;
                                }
                                break;
                            } else if (headerline[pos] == '\"') {
                                state = 2;
                            }
                            break;
                        }
                    case 2: {
                            // It's a quoted value, keep going until we hit a '"'
                            if (headerline[pos] == '\"') {
                                state = 1;
                            }
                            break;
                        }
                }
                pos++;
            }

            if (((subfield == null) && ((field == null || field.Length == 0))) || (string.Compare(subfield, field, true, CultureInfo.InvariantCulture) == 0)) {
                if (subfield != null) {
                    subvalue = span.Substring(span.IndexOf("=") + 1).Trim();
                } else {
                    subvalue = span.Trim();
                }
            }

            return subvalue;
        }



        public static bool IsLocal(string location) {
            return !(location == null || location.StartsWith("http") || location.StartsWith("https") || location.StartsWith("//"));
        }

        private static string RemoveSubRelativeDirs(string path) {
            path = ScriptableEmailFunctions.GetRegex(@"/[\.]{1}/([\.]{1}/)*").Replace(path, "/");
            var r1 = ScriptableEmailFunctions.GetRegex(@"[^\.]/\.\.");
            var r2 = ScriptableEmailFunctions.GetRegex(@"[^/\.]+/[\.]{2}/");
            while (r1.IsMatch(path)) {
                path = r2.Replace(path, "");
            }
            return path;
        }

        public static string FlattenCSSFile(string fileContent, string filename, HashSet<String> doneList) {
            return FlattenCSSFile(fileContent, filename, doneList, null);
        }

        public static string FlattenCSSFile(string fileContent, string filename, HashSet<String> doneList, string hostName) {
            if (!filename.IsEmpty() && !fileContent.IsEmpty()) {
                if (IsLocal(filename)) {
                    return FlattenCSSFileAux(fileContent, GetAbsolutePathFromRequest(System.Web.HttpContext.Current.Request.Url, filename), doneList, hostName);
                } else {
                    return FlattenCSSFileAux(fileContent, new Uri(filename), doneList, null);
                }
            }
            return fileContent;
        }

        private static string AddPathToURLs(Uri path, string fileContent, string hostName) {
            Regex urls = new Regex(@"url\s*\([^\)]*\)|src\s*=\s*['|""][^('|"")]+['|""]", RegexOptions.IgnoreCase);
            return urls.Replace(fileContent, delegate (Match match) {
                string resource = match.ToString().Replace(" ", "");

                if (resource.ToLower().Contains(".css")) { // do not touch imports /*@import url(bla.css);*/
                    return match.ToString();
                }

                if (resource.StartsWith("url(")) { /*Eg. background: #EAEAEA url(/RichWidgets/img/Header_Background_Purple.jpg?537) repeat-x top;*/
                    resource = resource.Substring(4, resource.Length - 5)/*remove "url(...)*/
                        .Replace("'", "").Replace("\"", "")/* remove quotes if they exist */;
                    if (resource.ToLower().StartsWith("http") || resource.ToLower().StartsWith("//")/*url("//ssl.bla.com/Bar_Gradient.png")*/
                        || resource.ToLower().StartsWith("data:") /*do not touch encoded data url('data:image/png;base64,R0lGODlhDQAE(...)*/)
                        return "url('" + resource + "')";
                    return "url('" + GetAbsolutePathFromRequest(path, resource, hostName) + "')";

                } else { /*Eg. _filter: progid: DXImageTransform.Microsoft.AlphaImageLoader(src='/RichWidgets/img/Bar_Gradient.png', sizingMethod='scale'); */
                    resource = resource.Substring(5, resource.Length - 6);
                    if (resource.ToLower().StartsWith("http") || resource.ToLower().StartsWith("//")/*url("//ssl.bla.com/Bar_Gradient.png")*/
                        || resource.ToLower().StartsWith("data:") /*do not touch encoded data url('data:image/png;base64,R0lGODlhDQAE(...)*/) {
                        return "src='" + resource + "'";
                    }
                    return "src='" + GetAbsolutePathFromRequest(path, resource, hostName) + "'";
                }
            });
        }

        private static string GetApplicationPathFromUri(Uri path) {
            // pre: full url
            string location = path.ToString();
            // sanity check
            bool doublebar = location.Substring(0, 2) == "//"; // keep protocol
            location = location.Replace("://", "{*}");
            location = location.Replace("//", "/");
            location = location.Replace("{*}", "://");
            location = doublebar ? "/" + location : location;
            int count = 0;
            for (int i = 0; i < location.Length; i++) {
                if (location.ElementAt(i) == '/')
                    count++;
                if (count == 4)
                    return location.Substring(0, i + 1); // includes last bar
            }
            return "";
        }

        private static string GetParentFolder(string url) {
            // pre: relative url does not start with '/'
            if (url.StartsWith("//"))
                url = HttpContext.Current.Request.Url.Scheme + ":" + url; // keep protocol
            if (url.StartsWith("/"))
                url = url.Substring(1);
            if (url.EndsWith("/"))
                url = url.Substring(0, url.Length - 1);
            return url.Substring(0, url.LastIndexOf('/') > -1 ? url.LastIndexOf('/') : 0);
        }

        public static Uri GetAbsolutePathFromRequest(Uri request, string filename) {
            return GetAbsolutePathFromRequest(request, filename, null);
        }

        private static Uri GetAbsolutePathFromRequest(Uri request, string filename, string hostName) {
            string url = "";
            if (GetParentFolder(filename) != "" && GetParentFolder(filename) != "img") {
                url = request.Scheme + "://" + (hostName == null ? request.Host : hostName);
            } else {
                url = GetApplicationPathFromUri(request).ToString().TrimEnd('/');
                url = hostName == null ? url : url.Replace("/127.0.0.1/", "/" + hostName + "/");
            }
            return new Uri(url + (filename.StartsWith("/") ? "" : "/") + filename);
        }

        private static string FlattenCSSFileAux(string fileContent, Uri path, HashSet<String> doneList, string hostName) {
            doneList.Add(RemoveSubRelativeDirs(path.ToString()));

            fileContent = NormalizeCSS(fileContent);

            if (StringUtils.ContainsIgnoreCase(fileContent, "<html>") || StringUtils.ContainsIgnoreCase(fileContent, "<!DOCTYPE")) {
                return string.Empty;
            }

            fileContent = AddPathToURLs(path, fileContent, hostName);

            MatchCollection matches = ScriptableEmailFunctions.GetRegex(@"@import\s+url\s*\(\s*(?:'([^']+)'|""([^""]+)"")\s*\)\s*;").Matches(fileContent);
            if (matches.Count == 0) {
                return fileContent;
            }

            string result = fileContent.Substring(0, matches[0].Index);

            for (int i = 0; i < matches.Count; i++) {
                Match m = matches[i];
                string location = m.Groups[1].Value + m.Groups[2].Value;
                int matchstart = m.Index;
                int matchend = m.Index + m.Length; // first char after match

                if (!doneList.Contains(RemoveSubRelativeDirs(location))) {
                    try {
                        string externalCss;
                        string externalCssEncoding;
                        if(IsLocal(location)){
                            Uri uri = GetAbsolutePathFromRequest(path, location);
                            HttpGet(uri.AbsoluteUri, EmailProcessor.MailUA, /*cookie*/null, out externalCss, out externalCssEncoding);
                            result += FlattenCSSFileAux(externalCss, uri, doneList, hostName);
                        } else {
                            HttpGet(location, EmailProcessor.MailUA, /*cookie*/null, out externalCss, out externalCssEncoding);
                            result += FlattenCSSFileAux(externalCss, new Uri(location), doneList, hostName);
                        }
                    } catch {

                    }
                }
                if (i == matches.Count - 1) {
                    result += fileContent.Substring(matchend, fileContent.Length - matchend);
                } else {
                    result += fileContent.Substring(matchend, matches[i + 1].Index - matchend);
                }
            }
            return result;
        }

    }
}
