/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Text;
using System.Text.RegularExpressions;
using OutSystems.HubEdition.RuntimePlatform;
using OutSystems.ObjectKeys;
using OutSystems.RuntimeCommon;
using System.Linq;

namespace OutSystems.HubEdition.RuntimePlatform.Sql {

    public class ReplaceEntities : SimpleSQLParser {
        private static readonly Regex _linkRegex = new Regex(@"@(?:\.?\w)+$", RegexOptions.Compiled | RegexOptions.CultureInvariant);
        private static readonly Regex _entityNameRegEx = new Regex(@"([{]\w+[}])(\s*\.\s*[""\[]?\w+[""\]]?)?", RegexOptions.Compiled | RegexOptions.CultureInvariant);

        private Func<string, string> resolve;

        public ReplaceEntities(Func<string, string> entityToViewName) {
            this.resolve = entityToViewName;
        }

        protected override string ProcessSQLSpan(string sqlSpan, bool allowCommentHints) {
            string result = sqlSpan;

            // #1146855 - special behavior to allow that oracle hints are not removed
            if (allowCommentHints) {
                result = sqlCommentsWithoutHints.Replace(sqlSpan, string.Empty); //sqlspan;
            } else {
                result = sqlComments.Replace(sqlSpan, string.Empty); //sqlspan;
            }

            // #14295 Replace {ent} with physical table name outside literals
            result = Replace(result, _entityNameRegEx, new MatchEvaluator(ProcessEntityName));
            return result;
        }

        private string ProcessEntityName(Match match) {
            string entName = match.Groups[1].Value.Substring(1, match.Groups[1].Value.Length - 2);
            string attr = (match.Groups[2] != null && match.Groups[2].Success) ? match.Groups[2].Value : "";
            string resolvedTableName = resolve(entName);
            if (!String.IsNullOrEmpty(attr)) {
                Match linkMatch = _linkRegex.Match(resolvedTableName);
                if ((linkMatch != null) && (linkMatch.Success)) {
                    string linkPart = linkMatch.Value;
                    resolvedTableName = resolvedTableName.Remove(resolvedTableName.Length - linkPart.Length, linkPart.Length);
                    return resolvedTableName + attr + linkPart;
                }
            }
            return resolvedTableName + attr;
        }

        private string Replace(string sql, Regex regex, MatchEvaluator matchEval) {
            int fixup = 0;
            MatchCollection mc = regex.Matches(sql);
            for (int i = 0; i < mc.Count; i++) {
                string s = matchEval(mc[i]);
                sql = ReplaceSpan(sql, mc[i].Index + fixup, mc[i].Length, s);
                fixup += s.Length - mc[i].Value.Length;
            }
            return sql;
        }

        private string ReplaceSpan(string sql, int start, int length, string replaceWith) {
            return sql.Substring(0, start) + replaceWith + sql.Substring(start + length);
        }

    }
}
