/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using System.Web;
using OutSystems.HubEdition.RuntimePlatform.Callbacks;
using OutSystems.HubEdition.RuntimePlatform.Db;
using OutSystems.HubEdition.RuntimePlatform.Log;
using OutSystems.HubEdition.RuntimePlatform.NewRuntime.Authentication;
using OutSystems.HubEdition.RuntimePlatform.SessionState;
using OutSystems.HubEdition.RuntimePlatform.Web;
using OutSystems.Internal.Db;
using OutSystems.ObjectKeys;
using OutSystems.RuntimeCommon;
using OutSystems.RuntimeCommon.Cryptography.Insecure;
using OutSystems.RuntimeCommon.ObfuscationProperties;

namespace OutSystems.HubEdition.RuntimePlatform {
    public delegate object GetSessionDefaultDelegate(string varName);

    public class SessionDefaults {
        // START: Backwards compatibility code
        private static Hashtable _varDefaults = new Hashtable();
        private static object GetSessionDefaultLegacy(string varName) {
            return _varDefaults[varName];
        }
        /// <summary>
        /// DEPRECATED: AddSessionDefault() kept for backwards compatibility ONLY.
        ///  Use SessionDefaultFunctions delegate instead.
        /// </summary>
        [Obsolete("AddSessionDefault() kept for backwards compatibility ONLY.\nUse SessionDefaultFunctions delegate instead.", true)]
        public static void AddSessionDefault(string varName, object varValue) {
            // System variables may be added more than once, hence the check.
            if (!_varDefaults.Contains(varName))
                _varDefaults.Add(varName, varValue);
        }
        // END: Backwards compatibility code

        // Session Var delegate
        public static event GetSessionDefaultDelegate SessionDefaultFunctions;

        public static object GetSessionDefault(string varName) {

            foreach (GetSessionDefaultDelegate delFunc in SessionDefaultFunctions.GetInvocationList()) {
                var retVar = delFunc(varName);
                if (retVar != null) return retVar;
            }

            // Fallback to "legacy" Hash of Session Defaults
            return GetSessionDefaultLegacy(varName);
        }
    }

    [Serializable]
    public class SessionInfo : ISessionInfo {
        private const string USER_ID = "UserID";
        private const string USER_ID_GUID = "UserIDGuid";
        private const string TENANT_ID = "TenantID";
        private const string USERNAME = "UserName";
        private const string TERMINAL_TYPE = "TerminalType";
        private const string SESSION_FIXATION_PROTECTION = "SessionFixationProtection";
        private const string SESSION_FIXATION_PROTECTION_OLD = "SessionFixationProtectionOld";
        private const string SESSION_FIXATION_PROTECTION_EXPIRATION_INSTANT = "SessionFixationProtectionExpirationInstant";

        // System variables
        // TODO: MARK AS DEPRECATED
        public ArrayList ScreenParameters = null;
        public string EntryPoint = null;
        public string OrphanedSpid = null;
        public string LastSpid = null;

        // The user variables
        private volatile ISessionHashtable _variables;

        private Callbacks.CallbackResultStorage _callbackStorage = null;
        private Dictionary<string, Pair<string, string>> _databaseConnectionOverrides = null;

        public static event Action SessionStart;

        #region New Runtime

        [NonSerialized]
        public LoginInfo NewRuntimeLoginInfo;

        [NonSerialized]
        private bool _hasNewRuntimeSessionStorage;
        public bool HasNewRuntimeSessionStorage {
            get { return _hasNewRuntimeSessionStorage; }
        }

        /// <summary>
        /// Enable persistent storage of changes done to this session information.
        /// This allows logins to occur outside the screen flows without generating database or cookie changes.
        /// </summary>
        public void EnableNewRuntimeSessionStorage() {
            if (NewRuntimeLoginInfo != null) {
                _hasNewRuntimeSessionStorage = true;
            }
        }


        // Only to be used by the new runtime to set session vars imediately after session info initialization
        // In the old runtime this class is aotomatically persisted and restored by the session mechanism
        // In the new runtime we we don't use .net session state so we have to start with an empty session and fill it manually.
        // WARNING: This method effectively logs in a user and no validation is done inside. Use with care!
        public void UnsafeSetSession(int userId, int tenantId, string username) {
            _variables[USER_ID] = userId;
            _variables[USER_ID_GUID] = UserIdToGuid(userId);
            _variables[TENANT_ID] = tenantId;
            _variables[USERNAME] = username;
        }

        #endregion

        public SessionInfo(MobileLoginConfiguration mobileLoginConfiguration) {
            _variables = SessionHashtable.CreateSessionHashTable();
            NewRuntimeLoginInfo = mobileLoginConfiguration == null ? null : new LoginInfo(mobileLoginConfiguration);
        }

        public SessionInfo() : this(null) { }

        public void ForceSessionIDLoad() {
            string dummy = _variables.SessionID;
        }

        private static void CallLogoutCallBack() {
            AppInfo app = AppInfo.GetAppInfo();
            if (app != null) {
                // Get an updated session instance and use it in the callback
                app.InjectionCache.RunCallbacks(app, app.OsContext.Session, CallbackEvent.Logout);
            }
        }

        private Dictionary<int, string> _roleCacheByUserId = null;
        private Dictionary<int, string> RoleCache {
            get {
                if (_roleCacheByUserId == null) {
                    ReadRolesInfo();
                }
                return _roleCacheByUserId;
            }
        }

        private SessionInfo contextSessionInfo;
        protected SessionInfo OsContextSession {
            get {
                if (this.contextSessionInfo == null) {
                    this.contextSessionInfo = AppInfo.GetAppInfo().OsContext.Session;
                }

                return this.contextSessionInfo;
            }

            set {
                this.contextSessionInfo = value;
            }
        }

        private void ReadRolesInfo() {
            if (UserId == 0) {
                _roleCacheByUserId = new Dictionary<int, string>();
            } else {
                _roleCacheByUserId = ReadAllUserRoles();
            }
        }

        public Func<string> GetRolesInfo() {
            return () => {
                if (_roleCacheByUserId != null) {
                    return RoleCache.Values.StrCat(",") + ",";
                }
                return null;
            };
        }

        public bool CheckRole(int roleId) {
            return RoleCache.ContainsKey(roleId);
        }

        public void AddRole(int roleId, string roleSSkey) {
            if (!RoleCache.ContainsKey(roleId)) {
                RoleCache.Add(roleId, roleSSkey);
            }
        }

        public void RemoveRole(int roleId) {
            RoleCache.Remove(roleId);
        }

        private Dictionary<int, string> ReadAllUserRoles() {
            // Fetch All User Permissions from the database
            using (Transaction tran = DatabaseAccess.ForRuntimeDatabase.GetReadOnlyTransaction()) {
                using (var reader = DBRuntimePlatform.Instance.GetAllUserRoles(tran, UserId, TenantId)) {
                    var allUserRoles = new Dictionary<int, string>();
                    while (reader.Read()) {
                        var espaceKey = DataReaderUtils.SafeGet<string>(reader[2]);
                        var roleKey = DataReaderUtils.SafeGet<string>(reader[1]);
                        var roleId = DataReaderUtils.SafeGet<string>(reader[0]);

                        if (espaceKey.IsNullOrEmpty() || roleKey.IsNullOrEmpty()) {
                            var errorMessage = "Role with Id " + roleId + " is invalid, check if it was properly created";
                            var appInfo = AppInfo.GetAppInfo();

                            Log.ErrorLog.LogApplicationError(
                                errorMessage, 
                                string.Empty,
                                appInfo != null ? appInfo.OsContext : null, 
                                "RuntimePlatform");
                            
                            continue;
                        }

                        var compoundKey = new GlobalObjectKey(ObjectKey.Parse(espaceKey), ObjectKey.Parse(roleKey));
                        allUserRoles.Add(DataReaderUtils.SafeGet<int>(roleId), compoundKey.ToString(ObjectKey.ShortFormat));
                    }
                    return allUserRoles;
                }
            }
        }

        private HashSet<string> _sessionStartedEspaces;
        private HashSet<string> SessionStartedEspaces {
            get {
                if (_sessionStartedEspaces == null) {
                    _sessionStartedEspaces = new HashSet<string>();
                }
                return _sessionStartedEspaces;
            }
        }

        public bool TestAndSetNeedsSessionStart(string eSpaceName) {
            lock (SessionStartedEspaces) {
                if (NeedsSessionStart(eSpaceName)) {
                    SessionStartedEspaces.Add(eSpaceName);
                    return true;
                }
                return false;
            }
        }

        public bool NeedsSessionStart(string eSpaceName) {
            lock (SessionStartedEspaces) {
                return !SessionStartedEspaces.Contains(eSpaceName);
            }
        }

        private void ClearSessionStartedEspaces() {
            lock (SessionStartedEspaces) {
                SessionStartedEspaces.Clear();
            }
        }

        public void Clear() {
            InnerClearAndSet(/*onlyChangeSessionId*/false, /*keepTenant*/false, /*tenantId*/null, /*userId*/null, /*userName*/null);
        }

        private void ClearAndSet(int tenantId) {
            InnerClearAndSet(/*onlyChangeSessionId*/false, /*keepTenant*/false, tenantId, /*userId*/null, /*userName*/null);
        }

        private void ClearAndSet(bool onlyChangeSessionId, int? userId, string userName) {
            InnerClearAndSet(onlyChangeSessionId, /*canKeepTenant*/true, /*tenantId*/null, userId, userName);
        }

        private static Guid UserIdToGuid(int userId) {
            return MD5GuidHelper.ToGuidWithSaltAndUTF16(userId.ToString(CultureInfo.InvariantCulture), SharedKeys.PrivateSalt());
        }

        private void InnerClearAndSet(bool onlyChangeSessionId, bool canKeepTenant, int? tenantId, int? userId, string userName) {
            SessionInfo instance = this;
            object terminalType = _variables[TERMINAL_TYPE]; // always preserve terminal type
            object currentTenantId = _variables[TENANT_ID]; // can try keep tenantId unless one is provided

            if (onlyChangeSessionId) {
                ClearSessionStartedEspaces();
            } else {
                InnerClearSession();
                // Get a update instance and make changes there
                instance = this.OsContextSession;
            }

            // Need to set the variables directly!
            if (tenantId != null) {
                instance._variables[TENANT_ID] = tenantId.Value;
            } else if (canKeepTenant && currentTenantId != null) {
                instance._variables[TENANT_ID] = currentTenantId;
            }

            if (userId != null) {
                instance._variables[USER_ID] = userId.Value;
                instance._variables[USER_ID_GUID] = UserIdToGuid(userId.Value).ToString();
            }

            if (userName != null) {
                instance._variables[USERNAME] = userName;
            }

            if (terminalType != null) {
                instance._variables[TERMINAL_TYPE] = terminalType;
            }

            if (SessionStart != null) {
                SessionStart();
            }
        }

        private void ClearSessionFixationProtection() {
            SessionFixationProtection = null;
        }

        private void InnerClearSession() {

            string oldSessionId = this.SessionID;

            // #490679 - Clean up the session item deleting the external session variables.
            _variables = this.DeleteExternalVarFromSession(oldSessionId);

            if (HttpContext.Current != null && HttpContext.Current.Session != null) {
                HttpContext.Current.Session.Clear();
            }
            ClearSessionStartedEspaces();
            ClearPermissions();
            ClearSessionFixationProtection();

            var info = AppInfo.GetAppInfo();
            if (info != null) {
                info.OsContext.ClearSession();
            }
        }

        protected virtual ISessionHashtable DeleteExternalVarFromSession(string oldSessionId) {
            SqlSessionStateStore.DeleteExternalVarFromSession(oldSessionId);
            return SessionHashtable.CreateSessionHashTable();
        }

        public void ClearPermissions() {
            _roleCacheByUserId = null;
        }

        public object this[string name] {
            get {
                if (_variables[name] == null) {
                    _variables[name] = SessionDefaults.GetSessionDefault(name);
                }
                return _variables[name];
            }
            set {
                _variables[name] = value;
            }
        }

        public Callbacks.CallbackResultStorage CallbackResults {
            get {
                if (_callbackStorage == null) {
                    _callbackStorage = new Callbacks.CallbackResultStorage();
                }
                return _callbackStorage;
            }
        }

        internal Pair<string, string> GetDatabaseConnectionOverride(string connectionName) {
            if (_databaseConnectionOverrides != null) {
                Pair<string, string> value;
                if (_databaseConnectionOverrides.TryGetValue(connectionName, out value)) {
                    return new Pair<string, string>(SecureConfidentialInformationEncryption.TryDecryptString(value.First), value.Second);
                }
            }
            return null;
        }

        internal void SetDatabaseConnectionOverride(string connectionName, string connectionString, string initialSchema) {
            if (_databaseConnectionOverrides == null) {
                _databaseConnectionOverrides = new Dictionary<string, Pair<string, string>>(StringComparer.OrdinalIgnoreCase);
            }

            _databaseConnectionOverrides[connectionName] = new Pair<string, string>(SecureConfidentialInformationEncryption.EncryptString(connectionString),
                initialSchema);
        }

        public string TerminalType {
            get {
                string terminalType = (string)_variables[TERMINAL_TYPE];
                if (terminalType.IsEmpty()) {
                    return "WEB";
                }
                return terminalType;
            }
            set {
                if (value != TerminalType) {
                    _variables[TERMINAL_TYPE] = value;
                }
            }
        }

        public string UserIdGuid {
            get {
                return (string)_variables[USER_ID_GUID];
            }
        }

        public int UserId {
            get {
                int userId = (int)(_variables[USER_ID] ?? 0);

                if (userId != 0 && CheckValidUser(userId)) {
                    return userId;
                }
                return 0;
            }
            set {
                SetUser(value, null);
            }
        }

        public string UserName {
            get {
                return (string)_variables[USERNAME];
            }
            set {
                _variables[USERNAME] = value;
            }
        }

        public string SessionFixationProtection {
            get {
                return (string)_variables[SESSION_FIXATION_PROTECTION];
            }
            set {
                /* Log.GeneralLog.StaticWrite(DateTime.Now, SessionID, 0, 0, UserId, "SessionFixation Key set to " + value, "INFO", "SESSION", null); */
                _variables[SESSION_FIXATION_PROTECTION] = value;
            }
        }

        public string SessionFixationProtectionOld {
            get {
                return (string)_variables[SESSION_FIXATION_PROTECTION_OLD] ?? "";
            }
            set {
                _variables[SESSION_FIXATION_PROTECTION_OLD] = value;
            }
        }

        public DateTime SessionFixationProtectionExpirationInstant {
            get {
                return _variables[SESSION_FIXATION_PROTECTION_EXPIRATION_INSTANT] == null ? DateTime.MinValue : Convert.ToDateTime(_variables[SESSION_FIXATION_PROTECTION_EXPIRATION_INSTANT]);
            }
            set {
                _variables[SESSION_FIXATION_PROTECTION_EXPIRATION_INSTANT] = value;
            }

        }

        public void SetUser(int userId, string userName) {
            int currentUserId = UserId;

            if (currentUserId != userId) {
                // if logging from no user, just change the session id and reset SessionStarts,
                // otherwise clear the session completely
                ClearAndSet(/*onlyChangeSessionId*/currentUserId == 0, userId, userName);
            } else {
                UserName = userName;
            }
            ReadRolesInfo();
        }

        private bool CheckValidUser(int userId) {
            try {
                const string VAR_NAME = "_osLastCheckedValidUserDate";
                object lastCheckedDate = _variables[VAR_NAME];
                DateTime now = DateTime.Now;
                bool isValid = true;

                if ((lastCheckedDate == null) || (((DateTime)lastCheckedDate) < BuiltInFunction.AddMinutes(now, -10))) {
                    using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                        isValid = DBRuntimePlatform.Instance.IsUserActive(trans, userId);
                        _variables[VAR_NAME] = now;
                    }

                    if (!isValid) {
                        Logout(userId);
                    }
                }

                return isValid;
            } catch {
                return false;
            }
        }

        public void Logout() {
            Logout(UserId);
        }

        private void Logout(int userId) {
            if (userId == 0) {
                return;
            }

            CookieActions.DeleteAllPersistentLoginEntries(userId, "Logout");

            ClearAndSet(/*onlyChangeSessionId*/false, /*userId*/null, /*userName*/null);
            CallLogoutCallBack();

            ReadRolesInfo();
        }

        private static volatile int defaultTenant = 0;

        public int TenantId {
            get {
                if (_variables[TENANT_ID] == null) {
                    lock (_variables) {
                        if (_variables[TENANT_ID] == null) {
                            int currentDefaultTenant = defaultTenant; // local variable to make less locks on defaultTenant and make sure the values on this thread are consistent
                            if (currentDefaultTenant == 0) {
                                AppInfo app = AppInfo.GetAppInfo();
                                if (app != null) {
                                    currentDefaultTenant = app.DefaultTenantId;
                                    defaultTenant = currentDefaultTenant; // set new cache value
                                }
                            }
                            if (currentDefaultTenant != 0) {
                                _variables[TENANT_ID] = currentDefaultTenant;
                            }
                        }
                    }
                }

                return (int)(_variables[TENANT_ID] ?? 0);
            }
            set {
                int tenantId = TenantId;
                if (tenantId != value) {
                    var app = AppInfo.GetAppInfo();
                    if (app != null) {
                        if (tenantId != 0) {
                            app.CheckMultitenancy();
                        }
                        using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetReadOnlyTransaction()) {
                            if (!DBRuntimePlatform.Instance.IsValidTenantIdForUserProvider(trans, app.UserProviderEspaceKeyAsKey, value)) {
                                throw new ArgumentException("Invalid Tenant Identifier: " + value + " is not a valid Tenant for this eSpace. Make sure it is active and belongs to the '" + app.UserProviderName + "' eSpace.");
                            }
                        }
                    }

                    ClearAndSet(/*tenantId*/value);
                }
            }
        }
        public string MSISDN {
            get {
                return (string)_variables["MSISDN"];
            }
            set {
                _variables["MSISDN"] = value;
            }
        }

        private static readonly string NoSessionHash = MD5PasswordHelper.HexDeriveUsingUTF16("No session", SharedKeys.PrivateSalt());

        public string SessionIDHash {
            get {
                var app = AppInfo.GetAppInfo();
                if (app != null) {
                    var context = app.OsContext;
                    if (context.SessionID != null) {
                        return context.SessionIDHash;
                    } else {
                        return NoSessionHash;
                    }
                } else {
                    return NoSessionHash;
                }
            }
        }

        public string SessionID {
            get {
                var app = AppInfo.GetAppInfo();
                if (app != null) {
                    var context = app.OsContext;
                    if (context.SessionID != null) {
                        return context.SessionID;
                    } else {
                        return "No session";
                    }
                } else {
                    return "No session";
                }
            }
        }
    }

    /// <summary>
    /// Platform Runtime Context with info to be used in current request processing.
    /// </summary>
    public class HeContext { // He prefix to avoid the need of prefixing with namespace (conflicts)
        public static readonly string UnknownEntryPoint = "__unknown_entry__";
        private ArrayList _disposableObjects;
        private System.Web.HttpContext _context; // TODO: remove this after upgrading code?
        //		public System.Web.SessionState.HttpSessionState _session;
        private AppInfo _appInfo;
        private AjaxEventContextInfo _ajaxEventContextInfo;
        private SessionInfo _tmpSession; // Session used when there is a sessionless request
        public string DestinationDirectory;
        public DateTime StartInstant;
        public bool SPIDHandled;
        public ArrayList ExceptionStack;
        public Exception LastException;
        public System.Web.UI.Page CurrentScreen = null;
        private string currentCulture;
        static string defaultCulture = System.Threading.Thread.CurrentThread.CurrentUICulture.Name;
        private int _extensionLogCount = 0;
        private ObjectKey _currentESpaceKey;
        private bool _allowTenantSwitch = true;
        private bool _isServiceAction = false;

        private string sessionId;
        private string sessionIdHash;
        public bool PendingSessionProtectionValidation = true;

        public string CurrentExecutionFileName = string.Empty;
        private Callbacks.CallbackResultStorage _callbackStorage;

        private RequestTracer _perfTracer;
        public RequestTracer RequestTracer {
            get {
                return _perfTracer;
            }
            set {
                _perfTracer = value;
            }
        }

        private HashSet<string> visitedExceptionHandlerFlows = new HashSet<string>();
        public HashSet<string> VisitedExceptionHandlerFlows {
            get { return visitedExceptionHandlerFlows; }
        }

        private volatile OsISAPIFilter osISAPIFilter = null;
        public OsISAPIFilter OsISAPIFilter {
            get {
                if (osISAPIFilter == null) {
                    osISAPIFilter = new OsISAPIFilter();
                }
                return osISAPIFilter;
            }
        }

        public bool CanUseCustomErrorHandler(Exception currentexception) {
            foreach (Exception exception in ExceptionStack) {
                if (currentexception.GetType().Equals(exception.GetType())) {
                    return false;
                }
            }
            return true;
        }


        private HashSet<Pair<int, int>> PendingEspacesToInvalidate = new HashSet<Pair<int, int>>();

        internal void QueueEspaceToInvalidate(int espaceId, int tenantId) {
            PendingEspacesToInvalidate.Add(Pair.Create(espaceId, tenantId));
        }

        public void OnEndRequest() {
            if (AppInfo != null) { // Prevents crashes when the AppInfo failed to initialize and we just want to finish the request
                try {
                    AppInfo.EvaluateJavascriptCacheInvalidation();

                    var espacesFullInvalidate = PendingEspacesToInvalidate.Where(pair => pair.Second == 0)
                                                                          .Select(pair => pair.First)
                                                                          .ToList();
                    var tenantsFullInvalidate = PendingEspacesToInvalidate.Where(pair => pair.First == 0)
                                                                          .Select(pair => pair.Second)
                                                                          .ToList();

                    var otherInvalidates = PendingEspacesToInvalidate
                                              .Where(pair => !espacesFullInvalidate.Contains(pair.First))
                                              .Where(pair => !tenantsFullInvalidate.Contains(pair.Second))
                                              .ToList();

                    PendingEspacesToInvalidate.Clear();

                    espacesFullInvalidate.Apply(espaceId => GenericExtendedActions.EspaceInvalidate(this, espaceId, 0));
                    tenantsFullInvalidate.Apply(tenantId => GenericExtendedActions.EspaceInvalidate(this, 0, tenantId));
                    otherInvalidates.Apply(p => GenericExtendedActions.EspaceInvalidate(this, p.First, p.Second));
                } catch (Exception ex) {
                    try {
                        Log.ErrorLog.LogApplicationError("Error invalidating espace caches.", ex.ToString(), this, "RuntimePlatform");
                    } catch { }
                    PendingEspacesToInvalidate.Clear();
                }
            }
        }

        public SessionInfo Session {
            get {
                // If this is a sessionless request, make a tmp session
                if (_context.Session == null) {
                    if (_tmpSession == null) {
                        if (_appInfo.IsMobileRuntime)
                            _tmpSession = new SessionInfo(_appInfo.GetMobileLoginConfigurations());
                        else
                            _tmpSession = new SessionInfo();
                    }

                    return _tmpSession;
                }

                SessionInfo session = null;
                // in rare occasions the session may be in such a state that deserialization fails
                // with "Unable to find <assembly>" errors (see #459715). In those cases we opt
                // to just reset the session.
                try {
                    session = (SessionInfo)_context.Session["OutSystems.UnifiedSession"];
                } catch (Exception ex) {
                    try {
                        ErrorLog.LogApplicationError("Error obtaining session data." + ex.Message, ex.StackTrace, this, "RuntimePlatform");
                    } catch { }
                }

                if (session == null) {
                    session = new SessionInfo();
                    _context.Session["OutSystems.UnifiedSession"] = session;
                }

                return session;
            }
        }

        public void ClearSession() {
            CurrentLocale = null;
        }

        public bool IsReadOnlySessionRequest {
            get {
                if (AppInfo.IsMobileRuntime) {
                    return !Session.HasNewRuntimeSessionStorage;
                }

                return HttpContext.Current.Session == null || HttpContext.Current.Session.IsReadOnly;
            }
        }


        public bool IsWebServiceRequest {
            get {
                return HttpContext.Current.Request.FilePath.ToLower().EndsWith(".asmx");
            }
        }

        public bool IsCookielessSession {
            get {
                return _context.Session == null || _context.Session.CookieMode != HttpCookieMode.UseCookies;
            }
        }

        public AppInfo AppInfo {
            get { return _appInfo; }
        }

        private static bool IsAjaxRequestFromRequest(HttpRequest request) {
            return request.Form["__AJAX"] != null;
        }
        internal static bool IsAjaxRequestFromContext(HttpContext context) {
            HttpRequest request = context.Request;
            return request != null && IsAjaxRequestFromRequest(context.Request);
        }

        public bool IsAjaxRequest {
            get {
                if (CurrentScreen != null) {
                    return IsAjaxRequestFromRequest(CurrentScreen.Request);
                } else {
                    return IsAjaxRequestFromContext(HttpContext.Current);
                }
            }
        }

        public AjaxEventContextInfo AjaxEventContextInfo {
            get { return _ajaxEventContextInfo; }
        }

        public bool IsServiceAction {
            get { return _isServiceAction; }
            set { _isServiceAction = value; }
        }

        private static volatile Dictionary<Pair<string, int>, int> _roleIdCache;
        public int GetRoleIdFromKey(string ssKey, int espaceId) {
            Pair<string, int> key = new Pair<string, int>(ssKey, espaceId);
            if (_roleIdCache == null || !_roleIdCache.ContainsKey(key)) {
                lock (typeof(HeContext)) {
                    if (_roleIdCache == null || !_roleIdCache.ContainsKey(key)) {
                        using (Transaction tran = DatabaseAccess.ForRuntimeDatabase.GetReadOnlyTransaction()) {
                            using (IDataReader reader = DBRuntimePlatform.Instance.GetRoleKeyIdTable(tran)) {
                                Dictionary<Pair<string, int>, int> cache = new Dictionary<Pair<string, int>, int>();
                                while (reader.Read()) {
                                    cache[new Pair<string, int>(Convert.ToString(reader[0]), Convert.ToInt32(reader[1]))] = Convert.ToInt32(reader[2]);
                                }
                                _roleIdCache = cache;
                            }
                        }
                    }
                }
            }
            int id;
            if (!_roleIdCache.TryGetValue(key, out id)) {
                throw new InvalidOperationException("Unknown role");
            }
            return id;
        }

        public Dictionary<string, string> GetESpacePrettyNames {
            get {
                return AppInfo.GetESpacePrettyNames();
            }
        }

        public Dictionary<string, List<string>> GetPageRules(int eSpaceId) {
            return AppInfo.GetPageRules(eSpaceId);
        }


        public bool RunningTestCases { get; set; }

        public HeContext() {
            Constructor(System.Web.HttpContext.Current);
        }

        public HeContext(HttpContext context) {
            Constructor(context);
        }

        private void Constructor(HttpContext context) {
            StartInstant = System.DateTime.Now;
            _disposableObjects = new ArrayList();
            _context = context;
            _appInfo = AppInfo.GetAppInfo(context);
            if (_appInfo != null) {
                _currentESpaceKey = _appInfo.eSpaceUIDAsKey;
            }
            _ajaxEventContextInfo = AjaxEventContextInfo.GetAjaxEventContextInfo(context);
            ExceptionStack = new ArrayList();
            LastException = null;
            SPIDHandled = false;
        }

        [System.Diagnostics.DebuggerNonUserCode]
        private HttpRequest SafeGetRequest(HttpContext context) {
            try {
                return context.Request;
            } catch {
                return null;
            }
        }

        public void AddDisposableObject(IDisposable obj) {
            _disposableObjects.Add(obj);
        }
        public void RemoveDisposableObject(IDisposable obj) {
            _disposableObjects.Remove(obj);
        }

        /// <summary>
        /// Will dispose pending objects that have been added for later disposable
        /// </summary>
        public void DisposeObjects() {
            // Todo: what about exceptions?

            int count = _disposableObjects.Count;
            for (int i = 0; i < count; i++) {
                IDisposable odisp = (IDisposable)_disposableObjects[0];
                odisp.Dispose();
                RemoveDisposableObject(odisp);
            }
        }

        public System.Web.HttpContext Context {
            get { return _context; }
        }

        public string GetTempFileNameWithPath() {
            return FileSystemUtils.GetTemporaryFile();
        }

        [Obsolete("Excel templates are no longer in use. Do not use.")]
        public string GetExcelTemplateFilePath() {
            return string.Empty;
        }

        public CultureInfo CurrentCulture {
            get {
                return new CultureInfo(CurrentLocale);
            }
            set {
                CurrentLocale = value.Name;
            }
        }

        public string CurrentLocale {
            get {
                // This code is because of the cases when we have session, the context object does not need 
                // the session to work and we need a way to store the locale value.
                // But in case we do use sessions we have to guarantee that the values are the same.
                if (currentCulture == null && _context.Session != null) {
                    object sessionCulture = _context.Session["Locale"];

                    if (sessionCulture != null) {
                        if (sessionCulture is string) {
                            currentCulture = (string)sessionCulture;
                        } else {
                            currentCulture = ((CultureInfo)sessionCulture).Name;
                        }
                    }
                }

                return currentCulture ?? defaultCulture;
            }
            set {
                currentCulture = value;
                if (_context.Session != null)
                    _context.Session["Locale"] = value;
            }
        }

        public Callbacks.CallbackResultStorage CallbackResults {
            get {
                if (_callbackStorage == null) {
                    _callbackStorage = new Callbacks.CallbackResultStorage();
                }
                return _callbackStorage;
            }
        }

        private readonly HashSet<HttpContext> _disabledFeedbacks = new HashSet<HttpContext>();
        public bool ResponseDisabledFeedback {
            get {
                return _disabledFeedbacks.Contains(_context) ||
                       (SafeGetRequest(Context) != null && (SafeGetRequest(Context).UserAgent ?? string.Empty).Contains("RichMail"));
            }
            set {
                if (value) {
                    _disabledFeedbacks.Add(_context);
                } else {
                    _disabledFeedbacks.Remove(_context);
                }
            }
        }

        private readonly HashSet<HttpContext> _disabledTaskBoxes = new HashSet<HttpContext>();
        public bool ResponseDisabledTaskBox {
            get {
                return _disabledTaskBoxes.Contains(_context);
            }
            set {
                if (value) {
                    _disabledTaskBoxes.Add(_context);
                } else {
                    _disabledTaskBoxes.Remove(_context);
                }
            }
        }

        private readonly Dictionary<HttpContext, HashSet<string>> _disabledScripts = new Dictionary<HttpContext, HashSet<string>>();

        public void AddDisabledScript(string scriptName) {
            if (!_disabledScripts.ContainsKey(_context)) {
                _disabledScripts[_context] = new HashSet<string>();
            }
            _disabledScripts[_context].Add(scriptName);
        }

        public void RemoveDisabledScript(string scriptName) {
            if (_disabledScripts.ContainsKey(_context)) {
                _disabledScripts[_context].Remove(scriptName);
            }
        }

        public bool hasDisabledScript(string scriptName) {
            if (_disabledScripts.ContainsKey(_context)) {
                return _disabledScripts[_context].Contains(scriptName);
            }
            return false;
        }

        public void QueueJavascript(string script) {
            // queue javascript in the current page
            IPageJavascriptQueue page = CurrentScreen as IPageJavascriptQueue;
            if (page != null) {
                page.AddQueuedJavascript(script);
            }
        }

        public int ExtensionLogCount {
            get {
                return _extensionLogCount;
            }
            set {
                _extensionLogCount = value;
            }
        }

        public ObjectKey CurrentESpaceKey {
            get {
                return _currentESpaceKey;
            }
            set {
                _currentESpaceKey = value;
            }
        }

        public bool AllowTenantSwitch {
            get {
                return _allowTenantSwitch;
            }
            set {
                _allowTenantSwitch = value;
            }
        }

        public void InitSession() {
            if (_context.Session != null) {
                sessionId = _context.Session.SessionID;
                sessionIdHash = MD5GuidHelper.ToGuidWithSaltAndUTF16(sessionId, SharedKeys.PrivateSalt()).ToString();
            }
        }

        internal string SessionIDHash {
            get { return sessionIdHash; }
        }

        internal string SessionID {
            get { return sessionId; }
        }
    }

    /// <summary>
    /// The SessionHashtable is a special hashtable that delays object deserialization
    /// until the object is actually accessed. This makes it possible to share the
    /// session between eSpaces without having to share their dlls also.
    /// </summary>
    [Serializable]
    [DoNotObfuscateType]
    class SessionHashtable : ISerializable, ISessionHashtable {
        // the session
        private string sessionID;
        public string SessionID {
            get {
                if (sessionID.IsEmpty()) {
                    AppInfo appInfo = AppInfo.GetAppInfo();
                    if (appInfo == null) {
                        if (HttpContext.Current != null && HttpContext.Current.Session != null) {
                            sessionID = HttpContext.Current.Session.SessionID;
                        } else {
                            sessionID = string.Empty;
                        }
                    } else {
                        sessionID = appInfo.OsContext.SessionID;
                    }
                }

                return sessionID;
            }
        }

        // the objects that are still serialized
        private Hashtable serialized = new Hashtable();

        // the objects that have already been deserialized
        private Hashtable deserialized = new Hashtable();

        // the eSpaces that have been accessed during this request
        // (the variables from these eSpace will be kept in the
        // session object directly)
        Hashtable accessedEspaces = new Hashtable();

        // the eSpace bags that have been loaded during this request
        // (either explicitly or because they're contained in the
        // session object directly)
        Hashtable loadedBags = new Hashtable();

        // the eSpaces for which a line in the external item table
        // has already been created
        string existingEspaces = "|";

        // the last user id of the loaded session
        int lastUserId = -1;

        const string EXISTING_ESPACES_VAR = "ExistingEspaces";
        const string LAST_USER_ID_VAR = "LastUserId";

        public object this[string key] {
            get {
                string eSpace = GetOwnerEspace(key);
                if (eSpace != null)
                    accessedEspaces[eSpace] = eSpace;

                // if the object is already deserialized, use it directly.
                // Otherwise, deserialize it now, but keep the serialized version
                // (this speeds up the session serialization if the object is not
                // changed)
                if (deserialized.ContainsKey(key))
                    return deserialized[key];

                byte[] data = null;
                object obj = null;

                // is the object still serialized?
                if (serialized.ContainsKey(key)) {
                    data = (byte[])serialized[key];
                } else if (SessionID != null && eSpace != null) {
                    // load eSpace variables now and try to get the variable again
                    try {
                        LoadEspaceBag(eSpace);
                    } catch (IOException e) {
                        throw new InvalidOperationException(e.Message, e);
                    }

                    if (deserialized.ContainsKey(key))
                        return deserialized[key];
                    if (serialized.ContainsKey(key))
                        data = (byte[])serialized[key];
                }

                if (data != null) {
                    try {
                        obj = Deserialize(data);
                    } catch (IOException e) {
                        throw new InvalidOperationException(e.Message, e);
                    }

                    deserialized[key] = obj;

                    // the "serialized" value cannot be kept for object
                    // types since the object may change without notice
                    if (obj != null && !IsPureValueType(obj.GetType()))
                        serialized.Remove(key);
                }

                return obj;
            }
            set {
                string eSpace = GetOwnerEspace(key);
                if (eSpace != null) {
                    // Since the eSpace variables are written together in a
                    // bag, if the variable is being set without having been
                    // read previously we must load the other variables too.
                    // Consequently, we force a read now
                    LoadEspaceBag(eSpace);
                }
                deserialized[key] = value;

                // the "serialized" hashtable no longer contains an up-to-date value
                serialized.Remove(key);
            }
        }

        private bool IsPureValueType(Type type) {
            return IsPureValueType(type, new Hashtable());
        }
        private bool IsPureValueType(Type type, Hashtable valueTypeCache) {
            if (!type.IsValueType) {
                return false;
            } else {
                valueTypeCache[type] = true;
            }

            foreach (FieldInfo fi in type.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)) {
                if (!valueTypeCache.ContainsKey(fi.FieldType)) {
                    if (!IsPureValueType(fi.FieldType, valueTypeCache)) {
                        return false;
                    }
                }
            }

            return true;
        }

        // Load the given eSpace variables from the external table, provided that
        // 1. we haven't yet done so (either explicitly or because the default session
        // object already contained the given eSpace's variables) and
        // 2. there is already that for the given eSpace in the database
        private void LoadEspaceBag(string eSpace) {
            if (SessionID == null || eSpace == null ||
                loadedBags.ContainsKey(eSpace) || !EspaceDataExists(eSpace))
                return;

            loadedBags[eSpace] = eSpace;

            // try to load the eSpace's variables bag
            byte[] eSpaceVariablesData = SqlSessionStateStore.GetExternalItem(SessionID, eSpace);
            if (eSpaceVariablesData != null) {
                Hashtable eSpaceVariables = (Hashtable)Deserialize(eSpaceVariablesData);
                if (eSpaceVariables == null) eSpaceVariables = new Hashtable();

                foreach (DictionaryEntry entry in eSpaceVariables) {
                    if (isDeserialized(entry.Value)) {
                        deserialized[entry.Key] = entry.Value;
                    } else {
                        serialized[entry.Key] = entry.Value;
                    }
                }
            }
        }

        private string GetOwnerEspace(string variable) {
            int pos = variable.IndexOf(".");
            if (pos == -1)
                return null;
            return variable.Substring(0, pos);
        }

        //Doing HttpContext.getCurrent().getSession() here (like in the .net code) 
        // would try to create a new OutsystemsSession java object and get the session locked
        // and freeze the application
        private SessionHashtable() {
        }

        [DoNotObfuscate]
        public static ISessionHashtable OverrideInstance { get; set; }

        public static ISessionHashtable CreateSessionHashTable() {
            return OverrideInstance ?? new SessionHashtable();
        }

        protected SessionHashtable(SerializationInfo info, StreamingContext context) {
            SerializationInfoEnumerator enumerator = info.GetEnumerator();
            while (enumerator.MoveNext()) {
                string key = enumerator.Name;
                object value = enumerator.Value;
                ProcessSerializedObject(key, value);
            }
        }

        private void ProcessSerializedObject(string key, object value) {
            if (key == EXISTING_ESPACES_VAR)
                existingEspaces = (string)value;
            else if (key == LAST_USER_ID_VAR)
                lastUserId = (int)value;
            else if (isDeserialized(value))
                deserialized[key] = value;
            else
                serialized[key] = value;

            string eSpace = GetOwnerEspace(key);
            if (eSpace != null)
                loadedBags[eSpace] = eSpace;
        }

        private bool isDeserialized(object value) {
            return value == null || value.GetType() != typeof(byte[]);
        }

        [System.Security.SecurityCritical]
        public virtual void GetObjectData(SerializationInfo info, StreamingContext context) {
            // there's nothing to do if no session was actually created
            // (this happens, e.g., for the _QueriesCoveragePage)
            if (SessionID == null) {
                return;
            }

            Hashtable eSpaces = new Hashtable();
            IDictionaryEnumerator enumerator;


            string eSpaceName = ((OutSystems.HubEdition.RuntimePlatform.HeContext)HttpContext.Current.Items["osContext"]).AppInfo.eSpaceName;
            int userId = 0;
            // store objects that didn't get deserialized
            enumerator = serialized.GetEnumerator();
            while (enumerator.MoveNext()) {
                if ((string)enumerator.Key == "UserID") {
                    userId = (int)enumerator.Value;
                }
                StoreSessionVariable(info, eSpaces, (string)enumerator.Key, enumerator.Value, true);
            }

            // store objects that were deserialized
            enumerator = deserialized.GetEnumerator();
            while (enumerator.MoveNext()) {
                if ((string)enumerator.Key == "UserID") {
                    userId = (int)enumerator.Value;
                }
                if (serialized.ContainsKey(enumerator.Key))
                    // we already processed this element above
                    continue;
                StoreSessionVariable(info, eSpaces, (string)enumerator.Key, enumerator.Value, false);
            }

            bool updatedUserId = false;

            // store the eSpace bags
            enumerator = eSpaces.GetEnumerator();
            while (enumerator.MoveNext()) {
                string eSpace = (string)enumerator.Key;
                Hashtable h = (Hashtable)enumerator.Value;

                if (eSpace == eSpaceName)
                    updatedUserId = true;

                if (EspaceDataExists(eSpace)) {
                    SqlSessionStateStore.UpdateExternalItem(SessionID, eSpace, Serialize(enumerator.Value), userId);
                } else {
                    SqlSessionStateStore.InsertExternalItem(SessionID, eSpace, Serialize(enumerator.Value), userId);
                    SetCreatedEspaceData(eSpace);
                }
            }

            // Update user id for the current espace if not yet updated.
            // !updateUserId happens when no bags were stored for the current espace
            if (lastUserId != userId && !updatedUserId) {
                if (EspaceDataExists(eSpaceName)) {
                    SqlSessionStateStore.UpdateExternalItemUserId(SessionID, eSpaceName, userId);
                } else {
                    SqlSessionStateStore.InsertExternalItemUserId(SessionID, eSpaceName, userId);
                    SetCreatedEspaceData(eSpaceName);
                }
            }

            // store the last user id
            info.AddValue(LAST_USER_ID_VAR, userId);

            // store the list of loaded eSpaces
            info.AddValue(EXISTING_ESPACES_VAR, existingEspaces);
        }

        private void SetCreatedEspaceData(string eSpace) {
            existingEspaces += eSpace + "|";
        }

        private bool EspaceDataExists(string eSpace) {
            return existingEspaces.IndexOf("|" + eSpace + "|") != -1;
        }

        private void StoreSessionVariable(SerializationInfo info, Hashtable eSpaces, string key, object obj, bool isAlreadySerialized) {
            object objToStore = obj;
            if (!isAlreadySerialized && IsComplexType(obj))
                objToStore = Serialize(obj);

            // the variables contained in the eSpaces that have been accessed during
            // the current request are stored in the session object directly. For the
            // other eSpaces we move the variables to the eSpace's bag (stored in its
            // own line in the DB)
            string eSpace = GetOwnerEspace(key);
            if (SessionID != null && eSpace != null && !accessedEspaces.Contains(eSpace)) {
                GetEspaceBag(eSpaces, eSpace)[key] = objToStore;
            } else {
                info.AddValue(key, objToStore);
            }
        }

        private Hashtable GetEspaceBag(Hashtable eSpaces, string eSpace) {
            Hashtable vars = (Hashtable)eSpaces[eSpace];
            if (vars == null) {
                vars = new Hashtable();
                eSpaces[eSpace] = vars;
            }
            return vars;
        }

        // "ComplexTypes" are the types that must be deserialized only on demand.
        // For simplicity, we'll consider byte arrays also to be complex types, because
        // complext types will be serialized into byte arrays
        private bool IsComplexType(object obj) {
            if (obj == null)
                return false;

            return obj is IRecord || obj is RecordList || obj is byte[] || obj is ArrayList;
        }


        private byte[] Serialize(object obj) {
            MemoryStream ms = new MemoryStream();
            BinaryFormatter bf = new BinaryFormatter();
            bf.Serialize(ms, obj);
            ms.Close();
            byte[] data = ms.ToArray();
            return data;
        }


        private object Deserialize(byte[] data) {
            MemoryStream ms = new MemoryStream(data);
            BinaryFormatter bf = new BinaryFormatter();
            object obj;
            try {
                obj = bf.Deserialize(ms);
            } catch (Exception e) {
                // #77951 - something may have changed in some session variable types
                // and if it did, there'll be a serialization exception thrown in here.
                Log.ErrorLog.LogApplicationError("Error when deserializating session variable types. Session variables may assume empty values.", e, AppInfo.GetAppInfo().OsContext, "RuntimePlatform");
                return null;
            } finally {
                try {
                    ms.Close();
                } catch { }
            }
            return obj;
        }
    }
}
