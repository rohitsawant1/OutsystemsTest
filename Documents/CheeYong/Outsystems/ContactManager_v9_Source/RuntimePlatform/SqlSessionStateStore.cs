/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections.Specialized;
using System.Globalization;
using System.IO;
using System.Web;
using System.Web.Configuration;
using System.Web.SessionState;
using OutSystems.HubEdition.Extensibility.Data.Platform.Session;
using OutSystems.HubEdition.RuntimePlatform.Db;
using OutSystems.Internal.Db;
using OutSystems.RuntimeCommon;

namespace OutSystems.HubEdition.RuntimePlatform.SessionState {
    internal static class AppSuffix {

        private static readonly string APP_SUFFIX_FORMAT = "x8";
        private static RuntimeSetting<bool> FixContainersSSOBug = new RuntimeSetting<bool>("OutSystems.Session.IgnoreWebsiteIdForSSO", false);
        private static string GetAppName() {
            // AppDomainAppIdInternal will contain the whole metabase path of the request's app
            // e.g. /lm/w3svc/1/root/fxtest (for IIS)

            // gather information about current application
            // TODO jmt: access this setting with the new Settings API.
            // Right now it does not work because retrieving a global setting via the Settings API appends 'DEFAULT' to the key.
            string unifiedEspaceKey = System.Configuration.ConfigurationManager.AppSettings[RuntimePlatformSettings.Misc.UnifiedEspaceKey.Key];
            string appDomainAppId = HttpRuntime.AppDomainAppId;
            string appDomainAppVirtualPath = HttpRuntime.AppDomainAppVirtualPath;

            string appName = ""; // the target application name
            bool fixContainersSSO = FixContainersSSOBug.GetValue();
            string prefix = fixContainersSSO ? "/LM/W3SVC/1/ROOT" : ""; // Xsp doesn't have a prefix, IIS has.

            if (appDomainAppId != null) {
                if (!fixContainersSSO && appDomainAppId.ToLower().IndexOf("/root/") > 0) {
                    prefix = appDomainAppId.Substring(0, appDomainAppId.ToLower().IndexOf("/root/") + "/root".Length);
                }
                if (unifiedEspaceKey != null && unifiedEspaceKey != "") {
                    if (fixContainersSSO) {
                        appName = prefix + "/" + unifiedEspaceKey;
                    } else {
                        int indexOfPTA = appDomainAppVirtualPath.IndexOf('/', 1);
                        appName = prefix + "/" + unifiedEspaceKey + (indexOfPTA > 0 ? appDomainAppVirtualPath.Substring(indexOfPTA).ToLower() : "");
                    }
                } else {
                    appName = prefix + appDomainAppVirtualPath.ToLower();
                }
            } else {
                throw new InvalidOperationException("Not running as an application");
            }

            return appName;
        }

        private static int GetHashCode(string s) {
            int hash = 5381;
            int len = s.Length;

            for (int i = 0; i < len; i++) {
                int c = Convert.ToInt32(s[i]);
                hash = ((hash << 5) + hash) ^ c;
            }

            return hash;
        }

        internal static string Load(IPlatformSessionService s) {

            var appName = GetAppName();
            var appHash = GetHashCode(appName.ToLower());

            Func<string> ExecuteStore = () => {
                int existingHash;
                string existingAppName;
                if (s.Store(appName, appHash, out existingHash, out existingAppName)) {
                    return existingHash.ToString(APP_SUFFIX_FORMAT, CultureInfo.InvariantCulture);
                } else {
                    throw new InvalidOperationException("Hash collision between " + appName + " and " + existingAppName + ". Please rename " + appName + ".");
                }
            };

            return DatabaseAccess.ExecuteWithoutRequestTimeout(ExecuteStore);
        }

    }
    
    /// <summary>
    /// Provides session state via SQL Server or Oracle
    /// </summary>
    public class SqlSessionStateStore : SessionStateStoreProviderBase {

        private const int INITIAL_STORE_DATASTREAM_SIZE = 7000;

        private static bool s_oneTimeInited = false;

        private static SqlSessionStateStore s_singleSessionStateStore;

        // Per request info
        private HttpContext _rqContext;

        private int _rqOrigStreamLen;

        private IPlatformSessionService session;

        private static string appSufix;

        public SqlSessionStateStore() {
        }

        public override void Initialize(string name, NameValueCollection config) {

            if (String.IsNullOrEmpty(name))
                name = "Session State Provider";

            base.Initialize(name, config);

            session = DatabaseAccess.ForSession.DatabaseServices.SessionService;

            if (!s_oneTimeInited) {

                var sessionSection = (SessionStateSection) WebConfigurationManager.GetSection("system.web/sessionState");
                session.QueryTimeout = (int) sessionSection.SqlCommandTimeout.TotalSeconds;

                s_singleSessionStateStore = this;

                appSufix = AppSuffix.Load(session);

                s_oneTimeInited = true;
            }
            
        }

        public override bool SetItemExpireCallback(SessionStateItemExpireCallback expireCallback) {
            return false;
        }

        public override void Dispose() {
        }

        public override void InitializeRequest(HttpContext context) {
            _rqContext = context;
            _rqOrigStreamLen = 0;
        }

        public override void EndRequest(HttpContext context) {
            _rqContext = null;
        }

        private class GetResult {
            public byte[] data;
            public int lockId;
            public bool locked;
            public TimeSpan lockAge;
            public ItemState itemState;
        }

        public SessionStateStoreData DoGet(
            HttpContext context, bool exclusive, string id,
                                        out bool locked,
                                        out TimeSpan lockAge,
                                        out object lockId,
            out SessionStateActions actionFlags) {
            ItemState itemState;

            Func<GetResult> ExecuteGet = () => {
                var getResult = new GetResult();
                getResult.data = exclusive ?
                session.GetAndLock(id, out getResult.lockId, out getResult.locked, out getResult.lockAge, out getResult.itemState) :
                session.Get(id, out getResult.lockId, out getResult.locked, out getResult.lockAge, out getResult.itemState);

                return getResult;
            };

            var result = DatabaseAccess.ExecuteWithoutRequestTimeout(ExecuteGet);

            byte[] data = result.data;
            lockId = result.lockId;
            locked = result.locked;
            lockAge = result.lockAge;
            itemState = result.itemState;

            actionFlags = (SessionStateActions)itemState;

            RuntimePlatformUtils.SetRetrievedSessionSize(context, data == null ? 0 : data.Length);

            if (data == null) {
                return null;
            }

            using (var s = new MemoryStream(data)) {
                var item = Deserialize(context, s);
                _rqOrigStreamLen = (int)s.Position;
                return item;
            }
        }

        public override SessionStateStoreData GetItem(HttpContext context,
                                                        String id,
                                                        out bool locked,
                                                        out TimeSpan lockAge,
                                                        out object lockId,
                                                        out SessionStateActions actionFlags) {
            return DoGet(context, false, id + appSufix, out locked, out lockAge, out lockId, out actionFlags);
        }

        public override SessionStateStoreData GetItemExclusive(HttpContext context,
                                                String id,
                                                out bool locked,
                                                out TimeSpan lockAge,
                                                out object lockId,
                                                out SessionStateActions actionFlags) {
            return DoGet(context, true, id + appSufix, out locked, out lockAge, out lockId, out actionFlags);
        }

        // This will deserialize and return an item.
        // This version uses the default classes for SessionStateItemCollection, HttpStaticObjectsCollection
        // and SessionStateStoreData
        private static SessionStateStoreData Deserialize(HttpContext context, Stream stream) {
            int timeout;
            SessionStateItemCollection sessionItems;
            bool hasItems;
            bool hasStaticObjects;
            HttpStaticObjectsCollection staticObjects;
            Byte eof;

            try {
                BinaryReader reader = new BinaryReader(stream);
                timeout = reader.ReadInt32();
                hasItems = reader.ReadBoolean();
                hasStaticObjects = reader.ReadBoolean();

                if (hasItems) {
                    sessionItems = SessionStateItemCollection.Deserialize(reader);
                } else {
                    sessionItems = new SessionStateItemCollection();
                }

                if (hasStaticObjects) {
                    staticObjects = HttpStaticObjectsCollection.Deserialize(reader);
                } else {
                    staticObjects = SessionStateUtility.GetSessionStaticObjects(context);
                }

                eof = reader.ReadByte();
                if (eof != 0xff) {
                    throw new HttpException(SessionSR.GetString(SessionSR.Invalid_session_state));
                }
            } catch (EndOfStreamException) {
                throw new HttpException(SessionSR.GetString(SessionSR.Invalid_session_state));
            }

            return new SessionStateStoreData(sessionItems, staticObjects, timeout);
        }

        private static SessionStateStoreData CreateLegitStoreData(HttpContext context,
                                                    ISessionStateItemCollection sessionItems,
                                                    HttpStaticObjectsCollection staticObjects,
                                                    int timeout) {
            if (sessionItems == null) {
                sessionItems = new SessionStateItemCollection();
            }

            if (staticObjects == null && context != null) {
                staticObjects = SessionStateUtility.GetSessionStaticObjects(context);
            }

            return new SessionStateStoreData(sessionItems, staticObjects, timeout);
        }

        static private void SerializeStoreData(SessionStateStoreData item, int initialStreamSize, out byte[] buf, out int length) {
            using (var s = new MemoryStream(initialStreamSize)) {
                Serialize(item, s);
                length = (int)s.Length;
                buf = s.GetBuffer();
                Array.Resize(ref buf, length);
            }
        }

        // This method will take an item and serialize it
        private static void Serialize(SessionStateStoreData item, Stream stream) {
            bool hasItems = true;
            bool hasStaticObjects = true;

            BinaryWriter writer = new BinaryWriter(stream);
            writer.Write(item.Timeout);

            if (item.Items == null || item.Items.Count == 0) {
                hasItems = false;
            }
            writer.Write(hasItems);

            if (item.StaticObjects == null || item.StaticObjects.NeverAccessed) {
                hasStaticObjects = false;
            }
            writer.Write(hasStaticObjects);

            if (hasItems) {
                ((SessionStateItemCollection)item.Items).Serialize(writer);
            }

            if (hasStaticObjects) {
                item.StaticObjects.Serialize(writer);
            }

            // Prevent truncation of the stream
            writer.Write(unchecked((byte)0xff));
        }

        public override void ReleaseItemExclusive(HttpContext context,
                                String id,
                                object lockId) {
            int lockCookie = (int)lockId;
            Func<int> ExecuteReleaseLock = () => {
                session.ReleaseLock(id + appSufix, lockCookie);
                return 0;
            };

            DatabaseAccess.ExecuteWithoutRequestTimeout(ExecuteReleaseLock);
        }

        private byte[] _GetExternalItem(String sessionId, string itemId) {
            Func<byte[]> ExecuteGetModuleItem = () => {
                return session.GetModuleItem(sessionId + appSufix, itemId);
            };
            var data = DatabaseAccess.ExecuteWithoutRequestTimeout(ExecuteGetModuleItem);
            if (data != null) {
                RuntimePlatformUtils.IncrementRetrievedSessionSize(data.Length);
            }
            RuntimePlatformUtils.IncrementRetrievedSessionRequests();
            return data;
        }

        private void _InsertOrUpdateExternalItem(String sessionId, string itemId, byte[] data, int userId, bool insert) {
            Func<int> ExecuteInsertModuleItem = () => {
                if (insert) {
                    session.InsertModuleItem(sessionId + appSufix, itemId, data, userId, sessionId);
                } else {
                    session.UpdateModuleItem(sessionId + appSufix, itemId, data, userId, sessionId);
                }
                return 0;
            };

            DatabaseAccess.ExecuteWithoutRequestTimeout(ExecuteInsertModuleItem);
        }

        private void _InsertOrUpdateExternalItemUserId(string sessionId, string itemId, int userId, bool insert) {
            Func<int> ExecuteInsertModuleItemUser = () => {
                if (insert) {
                    session.InsertModuleItemUser(sessionId + appSufix, itemId, userId, sessionId);
                } else {
                    session.UpdateModuleItemUser(sessionId + appSufix, itemId, userId, sessionId);
                }
                return 0;
            };

            DatabaseAccess.ExecuteWithoutRequestTimeout(ExecuteInsertModuleItemUser);
        }

        public static void SetItemTimeout(string sessionid, int timeout) {
            s_singleSessionStateStore._SetItemTimeout(sessionid, timeout);
        }

        public void _SetItemTimeout(string sessionId, int timeout) {
            Func<int> ExecuteResetSessionTimeout = () => {
                session.ResetSessionTimeout(sessionId, new TimeSpan(0, timeout, 0));
                return 0;
            };

            DatabaseAccess.ExecuteWithoutRequestTimeout(ExecuteResetSessionTimeout);
        }

        public static byte[] GetExternalItem(String sessionId, string itemId) {
            return s_singleSessionStateStore._GetExternalItem(sessionId, itemId);
        }

        public static void InsertExternalItem(String sessionId, string itemId, byte[] data, int userId) {
            s_singleSessionStateStore._InsertOrUpdateExternalItem(sessionId, itemId, data, userId, true);
        }

        public static void UpdateExternalItem(String sessionId, string itemId, byte[] data, int userId) {
            s_singleSessionStateStore._InsertOrUpdateExternalItem(sessionId, itemId, data, userId, false);
        }

        public static void InsertExternalItemUserId(string sessionId, string itemId, int userId) {
            s_singleSessionStateStore._InsertOrUpdateExternalItemUserId(sessionId, itemId, userId, true);
        }

        public static void UpdateExternalItemUserId(string sessionId, string itemId, int userId) {
            s_singleSessionStateStore._InsertOrUpdateExternalItemUserId(sessionId, itemId, userId, false);
        }

        public static void DeleteSession(string sessionId) {
            s_singleSessionStateStore._DeleteSession(sessionId);
        }

        public static void DeleteExternalVarFromSession(string sessionId) {
            s_singleSessionStateStore._DeleteExternalVarFromSession(sessionId);
        }

        public static void ChangeSessionId(string oldSessionId, string newSessionId) {
            s_singleSessionStateStore._ChangeSessionId(oldSessionId, newSessionId);
        }

        public static int GetUserId(String sessionId) {
            return s_singleSessionStateStore._GetUserId(sessionId);
        }

        private void _DeleteSession(string sessionId) {
            Func<int> ExecuteDeleteSession = () => {
                session.DeleteSession(sessionId + appSufix);
                return 0;
            };

            DatabaseAccess.ExecuteWithoutRequestTimeout(ExecuteDeleteSession);
        }

        private void _DeleteExternalVarFromSession(string sessionId) {
            Func<int> ExecuteDeleteModuleItems = () => {
                session.DeleteModuleItems(sessionId + appSufix);
                return 0;
            };

            DatabaseAccess.ExecuteWithoutRequestTimeout(ExecuteDeleteModuleItems);
        }

        private void _ChangeSessionId(string oldSessionId, string newSessionId) {
            Func<int> ExecuteChangeSessionId = () => {
                session.ChangeSessionId(oldSessionId + appSufix, newSessionId + appSufix);
                return 0;
            };

            DatabaseAccess.ExecuteWithoutRequestTimeout(ExecuteChangeSessionId);
        }

        private int _GetUserId(string sessionId) {
            Func<int> ExecuteGetUserBySessionId = () => {
                return session.GetUserBySessionId(sessionId + appSufix);
            };

            return DatabaseAccess.ExecuteWithoutRequestTimeout(ExecuteGetUserBySessionId);

        }

        public override void SetAndReleaseItemExclusive(HttpContext context,
                                    String id,
                                    SessionStateStoreData item,
                                    object lockId,
                                    bool newItem) {
            byte[] buf;
            int length;
            int lockCookie;

            // The session id might have changed (if a new session was created due to a login/logout event).
            // Note that we have no control over HttpContext.Session.SessionID (the property is read-only),
            // so even though the cookie already has the new value that property still has the old one
            var appInfo = AppInfo.GetAppInfo();
            if (appInfo != null) {
                var osContext = appInfo.OsContext;
                string currentSessionId = osContext.SessionID;
                if (currentSessionId != null && currentSessionId != id) {
                    id = currentSessionId;
                }
            }

            try {
                SerializeStoreData(item, INITIAL_STORE_DATASTREAM_SIZE, out buf, out length);
            } catch {
                if (!newItem) {
                    ReleaseItemExclusive(context, id, lockId);
                }
                throw;
            }

            // Save it to the store

            if (lockId == null) {
                lockCookie = 0;
            } else {
                lockCookie = (int)lockId;
            }

            Func<int> ExecuteInsert = () => {

                if (newItem) {
                    try {
                        session.Insert(id + appSufix, buf, new TimeSpan(0, item.Timeout, 0));
                    } catch (RepeatedInsertException) {
                        // It's possible that two threads (from the same session) are creating the session
                        // state, both failed to get it first, and now both tried to insert it.
                        // One thread may lose with a Primary Key Violation error. If so, that thread will
                        // just lose and exit gracefully.
                    }
                } else {
                    session.Update(id + appSufix, lockCookie, buf, _rqOrigStreamLen, new TimeSpan(0, item.Timeout, 0));
                }
                return 0;
            };

            DatabaseAccess.ExecuteWithoutRequestTimeout(ExecuteInsert);
        }

        public override void RemoveItem(HttpContext context,
                                        String id,
                                        object lockId,
                                        SessionStateStoreData item) {
            int lockCookie = (int)lockId;

            Func<int> ExecuteDelete = () => {
                session.Delete(id + appSufix, lockCookie);
                return 0;
            };

            DatabaseAccess.ExecuteWithoutRequestTimeout(ExecuteDelete);
        }

        public override void ResetItemTimeout(HttpContext context, String id) {
            Func<int> ExecuteResetModuleTimeout = () => {
                session.ResetModuleTimeout(id + appSufix);
                return 0;
            };

            DatabaseAccess.ExecuteWithoutRequestTimeout(ExecuteResetModuleTimeout);
        }

        public override SessionStateStoreData CreateNewStoreData(HttpContext context, int timeout) {
            return CreateLegitStoreData(context, null, null, timeout);
        }

        public override void CreateUninitializedItem(HttpContext context, String id, int timeout) {
            byte[] buf;
            int length;

            // Store an empty data
            SerializeStoreData(CreateNewStoreData(context, timeout), INITIAL_STORE_DATASTREAM_SIZE, out buf, out length);

            try {
                Func<int> ExecuteInsertUninitialized = () => {
                    session.InsertUninitialized(id + appSufix, buf, new TimeSpan(0, timeout, 0));
                    return 0;
                };

                DatabaseAccess.ExecuteWithoutRequestTimeout(ExecuteInsertUninitialized);
            } catch (RepeatedInsertException) {
                // It's possible that two threads (from the same session) are creating the session
                // state, both failed to get it first, and now both tried to insert it.
                // One thread may lose with a Primary Key Violation error. If so, that thread will
                // just lose and exit gracefully.
            }
        }
    }
}