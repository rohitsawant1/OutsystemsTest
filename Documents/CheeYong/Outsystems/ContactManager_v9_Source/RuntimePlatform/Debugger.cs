/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Net;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;
using System.Web;
using System.Web.Services;
using System.Xml;
using OutSystems.HubEdition.RuntimePlatform.Db;
using OutSystems.HubEdition.RuntimePlatform.Web;
using OutSystems.Internal.Db;
using OutSystems.ObjectKeys;
using OutSystems.RuntimeCommon;
using OutSystems.RuntimeCommon.ObfuscationProperties;

namespace OutSystems.HubEdition.RuntimePlatform {
    /// <summary>
    /// 
    /// </summary>
    public class Debugger : System.Web.Services.WebService {

        private static bool DEBUG_STACK_METHODS = false;

        // Debugger version. SS will only debug against a server with the same
        // debugger version
        public const string DebuggerVersion = "1";

        // Kept here for backward compatibility
        public const int MAX_ROW_COUNT = Constants.DEBUGGER_MAX_ROW_COUNT;

        // number of breakpoints that have to be visited in a given call stack level
        // before we consider that we may be inside an infinite loop
        public const int INFINITE_LOOP_THRESHOLD = 100000;

        // time (in ms) that the current thread is put to sleep between breakpoints
        // when we consider that it is running an infinite loop
        private const int INFINITE_LOOP_SLEEP = 1;

        // time (in ticks) that we wait before the last client disconnected until
        // we consider that there are no connected clients
        internal const long REMOVE_CLIENT_TOLERANCE = 20 * TimeSpan.TicksPerSecond;
        internal const long REMOVE_CLIENT_TOLERANCE_AFTER_RESTART = 40 * TimeSpan.TicksPerSecond;

        public const int GET_DEBUG_EVENT_TIMEOUT_IN_MS = 10000;

        public const int REQUEST_TIMEOUT_IN_SECONDS = 3600;

        private static bool loadedPreviousSessionsData;

        /// <summary>
        /// This variable is used to monitor if there are active threads. It is pulsed when there are no threads active.
        /// </summary>
        public static readonly object NO_ACTIVE_THREADS_MONOTORING = new object();

        public static bool IsRunning {
            get {
                return !debugSessions.IsEmpty;
            }
        }

        internal static bool IsInPublicArea {
            get { return RunningInfo.PAName == null; }
        }

        public static bool WasExceptionThrown {
            get { return ThreadDataExists ? ThreadData.LastExceptionThrown != null : false; }
        }

        private static bool appIsBeingRedeployed;
        internal static bool AppIsBeingRedeployed {
            get { return appIsBeingRedeployed; }
        }

        // this property is used to determine if queries for the current
        // thread should be executed in un-optimized mode
        public static bool DebuggingCurrentThread {
            get {
                if (!IsRunning)
                    return false;
                return debugSessions.HasBreakpoints() || ThreadData.WasSuspended;
            }
        }

        // machine id. Used to create thread identifiers
        private static string machineId;

        public static bool IsValidDebugSessionToken(string token) {
            return debugSessions.IsValidToken(token);
        }

        private static volatile DebugSessions _debugSessions_notToBeUsedDirectly;
        private static DebugSessions debugSessions {
            get {
                if (_debugSessions_notToBeUsedDirectly == null) {
                    lock (typeof(Debugger)) {
                        if (_debugSessions_notToBeUsedDirectly == null) {
                            _debugSessions_notToBeUsedDirectly = new DebugSessions();
                            LoadDebugSessionData();
                        }
                    }
                }
                return _debugSessions_notToBeUsedDirectly;
            }
        }

        internal static DebugSessions DebugSessions {
            get { return debugSessions; }
        }

        // this hashtable contains the currently running threads
        private static Dictionary<string, ThreadData> threads = new Dictionary<string, ThreadData>();

        // list of eSpaces that are being debugged
        private static List<DebuggerEventsData> openESpaces = new List<DebuggerEventsData>();

        // Thread data for the current running thread. This is used to keep track of the
        // stack and context of the thread
        [ThreadStatic]
        private static ThreadData _threadData;

        private static void ClearThreadData() {
            _threadData = null;
        }

        public static ThreadData ThreadData {
            get {
                if (_threadData == null || _threadData.Discarded) {
                    lock (threads) {
                        if (_threadId == null) {
                            _threadId = "T" + (++nextThreadId);
                            if (clustered)
                                _threadId += "@" + machineId;
                        }

                        _threadData = new ThreadData(_threadId);
                        threads[_threadId] = _threadData;
                        if (DEBUG_STACK_METHODS) {
                            DebuggerTrace.Log("Created ThreadData for thread " + _threadId);
                        }
                    }
                }
                return _threadData;
            }
            set {
                if (value == null) {
                    _threadData.OnThreadEnded();
                    ClearThreadData();
                } else {
                    _threadData = value;
                }
            }
        }

        private static bool ThreadDataExists {
            get { return _threadData != null; }
        }

        [ThreadStatic]
        private static string _threadId;

        private static void CleanThreadId() {
            _threadId = null;
        }

        private static int nextThreadId;

        public static string ThreadId {
            get {
                return _threadId;
            }
        }

        [ThreadStatic]
        private static IEnumerable<DebugSession> sessionsForCurrentBreakpoint;

        private static void CleanSessionsForCurrentBreakpoint() {
            sessionsForCurrentBreakpoint = null;
        }

        public static int ActiveThreadsCount {
            get {
                lock (threads) {
                    if (DEBUG_STACK_METHODS) {
                        DebuggerTrace.Log("ActiveThreadsCount = " + threads.Count);
                    }
                    return threads.Count;
                }
            }
        }

        static int requestCount;
        public static int RequestCount {
            get {
                lock (threads) {
                    return ++requestCount;
                }
            }
        }

        // TODO Get DebuggerToken from a central (and secure!) place
        private const string DebuggerToken = "Debugger";
        private const string DeployServiceToken = "DeployService";

        // TODO: calculate the value of the "clustered" variable using the factory
        // configuration
        static bool clustered = false;

        static Hashtable timers = new Hashtable();
        public static Hashtable Timers {
            get {
                return timers;
            }
        }

        [ThreadStatic]
        internal static ProcessInfo processInfo;
        internal static ProcessInfo ProcessInfo {
            get { return processInfo; }
            private set { processInfo = value; }
        }

        internal static bool IsLongLivedRequest {
            get { return ProcessInfo.ProcessId > 0; }
        }

        private static string DebuggerWSDL() {
            return "_debugger.asmx";
        }

        public static string DebuggerUrl(string host, string eSpaceName, string tenantName, string personalAreaName) {
            return "http://" + RuntimePlatformUtils.FixHostIPForIPV6(host) + "/" + eSpaceName +
                        (personalAreaName != null ? "/" + personalAreaName : "") +
                        "/" + DebuggerWSDL();
        }

        internal static void SetCurrentProcessInfo(int processId, int activityId, int precedentActivityId, int precedentActivitySuccessorsCount, int rootProcessId) {
            ProcessInfo = new ProcessInfo() {
                ProcessId = processId,
                ActivityId = activityId,
                PrecedentActivityId = precedentActivityId,
                PrecedentActivitySuccessorsCount = precedentActivitySuccessorsCount,
                TopProcessId = rootProcessId <= 0 ? processId : rootProcessId
            };
        }

        internal static void CleanCurrentProcessInfo(bool forceClean) {
            // if an exception has occurred and has not been processed yet, we must keep the thread data
            if (forceClean || !ThreadDataExists || ThreadData.LastExceptionThrown == null) {
                ProcessInfo = new ProcessInfo();
            }
        }

        static Debugger() {
            try {
                DebuggerTrace.Log("Debugger is starting");

                DebuggerTrace.Log("eSpaceName  = " + RunningInfo.EspaceName);
                DebuggerTrace.Log("ptaName     = " + RunningInfo.PAName);

                machineId = Dns.GetHostAddresses(Dns.GetHostName()).FirstOrDefault(ip => !NetworkInterfaceUtils.IsLoopbackAddress(ip.ToString())).ToString();

                DebuggerTrace.Log("machineId = " + machineId);
            } catch (Exception e) {
                DebuggerTrace.Log(e);
            }
        }

        public Debugger() {
        }

        public static void RegisterESpaceHashes(string debuggerType) {
            try {
                DebuggerTrace.Log("RegisterESpaceHashes " + debuggerType);
                Type t = Type.GetType(debuggerType, true);
                MethodInfo m = t.GetMethod("RegisterHashes");
                if (m == null) {
                    DebuggerTrace.Log("Unable to locate method RegisterHashes in type " + t);
                    return;
                }

                m.Invoke(null, (object[])null);
            } catch (Exception e) {
                DebuggerTrace.Log(e);
            }
        }

        public static void RegisterTimerClass(string name, string timerType) {
            try {
                timers[name] = Type.GetType(timerType, true);
            } catch (Exception e) {
                DebuggerTrace.Log(e);
            }
        }

        public static void Remove(DebugSession debugSession) {
            debugSessions.Remove(debugSession);
        }

        #region Component Designer generated code

        //Required by the Web Services Designer 
        private IContainer components = null;

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent() {
        }

        /// Clean up any resources being used.
        protected override void Dispose(bool disposing) {
            if (disposing && components != null) {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #endregion

        #region WebMethods
        [WebMethod]
        public bool GetIsRunning() {
            return Debugger.IsRunning;
        }

        [WebMethod]
        public string StartDebugSession(string eSpaceUID, string userName, string password, bool breakOnAllErrors, string breakpointsIds) {
            try {
                lock (typeof(Debugger)) {
                    if (userName == "") {
                        userName = null;
                    }
                    DebuggerTrace.Log("StartDebugSession eSpaceUID = " + eSpaceUID + ", userName=" + userName);

                    // PTAs can only be debugged by their user (this error should never happen, since SS always connects to
                    // the are of the logged-in user)
                    if (RunningInfo.PAName != null && RunningInfo.PAName != RuntimeCommon.Constants.COMMON_PERSONAL_AREA_NAME && userName.ToLower() != RunningInfo.PAName.ToLower()) {
                        string result = "ERROR: Debugger_WrongUserForPTA|" + RunningInfo.PAName;
                        DebuggerTrace.Log("StartDebugSession error :" + result);
                        return result;
                    }

                    // jec: getting the host
                    // this.Url = "http://"+ System.Web.HttpContext.Current.Request.ServerVariables["SERVER_NAME"] +":"+ System.Web.HttpContext.Current.Request.ServerVariables["SERVER_PORT"] +"/ServiceCenter/IntegratedDebugger.asmx";

                    // #127516: trying to reach SC using the server name as provided by SS (in this case, it is an IP address) isn't working
                    // (is this a configuration problem?)

                    // #146240: if calling the debugger with https we need to change the port. If not, try to respect the current port.
                    string portSnippet = System.Web.HttpContext.Current.Request.IsSecureConnection ?
                                            RuntimePlatformSettings.Misc.ApplicationServerPort.GetValue().ToString() :
                                            System.Web.HttpContext.Current.Request.ServerVariables["SERVER_PORT"];

                    string url = "http://" + RuntimePlatformUtils.FixHostIPForIPV6(RuntimePlatformSettings.Misc.InternalAddress.GetValue()) + ":" + portSnippet + "/ServiceCenter/IntegratedDebugger.asmx";

                    // security check
                    using (IntegratedDebugger sc = new IntegratedDebugger(url)) {
                        if (!sc.CheckPermission(userName, password, eSpaceUID)) {
                            string result = "ERROR: Debugger_ProducerNoDebugPermission";
                            DebuggerTrace.Log("StartDebugSession error :" + result);
                            return result;
                        }
                        if (ObjectKey.Parse(eSpaceUID) != ObjectKey.Parse(RunningInfo.EspaceUID)) {
                            if (!sc.CheckPermission(userName, password, RunningInfo.EspaceUID)) {
                                string result = "ERROR: Debugger_ConsumerNoDebugPermission";
                                DebuggerTrace.Log("StartDebugSession error :" + result);
                                return result;
                            }
                        }
                    }

                    // create debug session object
                    DebugSession debugSession = debugSessions.GetOrCreate(userName);
                    // send list of logged in users
                    if (IsInPublicArea) {
                        debugSessions.SendLoggedInUsers();

                        // send ConcurrentAtBreakpoint events for each suspended thread
                        if (debugSessions.Count > 1) {
                            lock (threads) {
                                foreach (ThreadData suspendedThread in threads.Values.Where(t => t.IsSuspended && !t.DebugSessionToken.IsEmpty()).ToArray()) {
                                    DebugSession suspendedThreadSession = debugSessions.GetByToken(suspendedThread.DebugSessionToken);
                                    if (suspendedThreadSession == null || suspendedThreadSession == debugSession) {
                                        continue;
                                    }

                                    ConcurrentAtBreakpointEvent evt = new ConcurrentAtBreakpointEvent(suspendedThread, suspendedThreadSession);
                                    debugSession.Enqueue(evt);
                                }
                            }
                        }
                    }

                    debugSession.ExceptionMode = breakOnAllErrors ? HandleExceptionMode.BreakOnAll : HandleExceptionMode.DoNotBreak;
                    DebuggerTrace.Log("SetHandleExceptionMode " + debugSession.ExceptionMode);

                    // remove breakpoints
                    DebuggerTrace.Log("ClearBreakpoints");
                    debugSession.ClearBreakpoints();

                    // add breakpoints
                    DebuggerTrace.Log("AddBreakpoints " + breakpointsIds);
                    if (!(breakpointsIds.IsEmpty())) {
                        foreach (string breakpointIdStr in breakpointsIds.Split(',')) {
                            BreakpointId breakpointId = null;
                            if (BreakpointId.TryParse(breakpointIdStr, out breakpointId)) {
                                debugSession.Add(breakpointId);
                            }
                        }
                    }

                    SaveDebugSessionsData();
                    DebuggerTrace.Log("StartDebugSession token = " + debugSession.Token);

                    return debugSession.Token;

                    // TODO: start the debug session in the other Front-end Servers using this same token
                    // (do not forget that there may be a race condition two concurrent StartDebugSession requests
                    // if they occur at the same time but are dispatched to different Front-end Servers. 
                    // In that case we end up by generating two different tokens and need to recover from that
                    // by choosing one of the tokens and signaling the ServiceStudio instances of the new token
                }
            } catch (Exception e) {
                DebuggerTrace.Log("StartDebugSession error :" + e.ToString() + Environment.NewLine + e.StackTrace);
                return "ERROR: Debugger_Exception|" + e.Message;
            }
        }

        [WebMethod]
        public void KillDebugSession(string debugSessionToken) {
            if (debugSessionToken != null && debugSessionToken != string.Empty) {
                StopDebugSession(debugSessionToken, s => new StopDebugSessionEvent("Debugger_SessionEnded"),
                    /*willReconnect*/false);
                SaveDebugSessionsData();
            }
        }

        [WebMethod]
        public void StopDebugSession(string debugSessionToken, bool willReconnect) {
            StopDebugSession(debugSessionToken, /*getEventToSend*/null, willReconnect);
            DebuggerTrace.Log("StopDebugSession: saving " + debugSessions.Count + " debug sessions data. willReconnect = " + willReconnect);
            SaveDebugSessionsData();
        }

        [WebMethod]
        public void OnBeforeDeploy(string debugSessionToken) {
            if (GetCallerType(debugSessionToken) == CallerType.DeployService) {
                if (!appIsBeingRedeployed) {
                    DebuggerTrace.Log("OnBeforeDeploy: saving " + debugSessions.Count + " debug sessions data.");
                    SaveDebugSessionsData();
                    appIsBeingRedeployed = true;

                    debugSessions.ActiveDebugSessionTokens.Apply(
                        t => StopDebugSession(t,
                                              s => new ApplicationIsBeingRedeployedEvent(s, /*fromRedeployEvent*/true),
                            /*willReconnect*/true));
                }
            }
        }

        internal static void SaveDebugSessionsData() {
            if (!RunningInfo.DebugMode || appIsBeingRedeployed || RunningInfo.ESpaceId == 0) {
                return;
            }

            lock (debugSessions) {
                try {
                    StringWriter result = new StringWriter();
                    XmlWriterSettings settings = new XmlWriterSettings();
                    settings.CloseOutput = true;
                    XmlWriter writer = XmlWriter.Create(result, settings);

                    writer.WriteStartDocument();
                    writer.WriteStartElement("DebuggerData");

                    debugSessions.Save(writer);
                    ThreadData.Save(writer);

                    writer.WriteEndElement();
                    writer.WriteEndDocument();
                    writer.Close();

                    string xml = result.ToString();
                    DebuggerTrace.Log("SaveDebugSessionsData: eSpaceId = " + RunningInfo.ESpaceId + ", userId = " + RunningInfo.UserId);
                    DebuggerTrace.Log(xml);
                    byte[] data = Encoding.UTF8.GetBytes(xml);

                    using (Transaction tran = DatabaseAccess.ForSystemDatabase.GetCommitableTransaction()) {
                        DBRuntimePlatform.Instance.CreateOrUpdateDebugSessionData(tran, RunningInfo.ESpaceId, RunningInfo.UserId, data);
                        tran.Commit();
                    }
                } catch (Exception e) {
                    DebuggerTrace.Log(e);
                }
            }
        }

        internal static void LoadDebugSessionData() {
            if (loadedPreviousSessionsData) {
                return;
            }

            lock (typeof(Debugger)) {
                try {
                    if (loadedPreviousSessionsData) {
                        return;
                    }
                    loadedPreviousSessionsData = true;

                    DebuggerTrace.Log("LoadDebugSessionData");
                    if (!RunningInfo.DebugMode) {
                        DebuggerTrace.Log("LoadDebugSessionData: app is not in debug mode");
                        return;
                    }

                    byte[] data;

                    using (Transaction tran = DatabaseAccess.ForSystemDatabase.GetReadOnlyTransaction()) {
                        DebuggerTrace.Log("LoadDebugSessionData: getting data for eSpaceId = " + RunningInfo.ESpaceId + ", userId = " + RunningInfo.UserId);
                        data = DBRuntimePlatform.Instance.GetDebugSessionData(tran, RunningInfo.ESpaceId, RunningInfo.UserId);
                    }
                    if (data == null) {
                        DebuggerTrace.Log("LoadDebugSessionData: no data found");
                        return;
                    }
                    DebuggerTrace.Log("LoadDebugSessionData: Got persisted debug session data from the db");

                    // ignore loading errors
                    XmlDocument doc = new XmlDocument();
                    string xml = Encoding.UTF8.GetString(data);
                    DebuggerTrace.Log("LoadDebugSessionData:");
                    DebuggerTrace.Log(xml);
                    doc.LoadXml(xml);

                    debugSessions.Load(doc.DocumentElement);
                    ThreadData.Load(doc.DocumentElement);
                } catch (Exception e) {
                    DebuggerTrace.Log(e);
                }
            }
        }

        private void StopDebugSession(string debugSessionToken, Func<DebugSession, DebuggerEvent> getEventToSend, bool willReconnect) {
            try {
                DebuggerTrace.Log("StopDebugSession token = " + debugSessionToken);
                if (GetCallerType(debugSessionToken) != CallerType.Unknown) {
                    debugSessions.Stop(debugSessionToken, getEventToSend, willReconnect);

                    // send updated list of logged in users
                    if (IsInPublicArea) {
                        debugSessions.SendLoggedInUsers();
                    }

                    // continue each suspended thread
                    lock (threads) {
                        IEnumerable<ThreadData> threadsToRemove = threads.Values;

                        // if there still active debug sessions, remove only the threads that
                        // had been associated with this session
                        if (!debugSessions.IsEmpty) {
                            threadsToRemove = threadsToRemove.Where(t => t.DebugSessionToken == debugSessionToken);
                        }

                        foreach (ThreadData threadData in threadsToRemove.ToArray()) {
                            // if there are no more sessions
                            threadData.ContinueThread();
                        }
                    }

                    // cleanup open eSpaces
                    lock (openESpaces) {
                        openESpaces.Clear();
                    }
                } else {
                    DebuggerTrace.Log("Session not stopped. Current tokens are " + debugSessions.ActiveDebugSessionTokens.StrCat(","));
                }

                // TODO: stop the debug session in the other Front-end Servers using this same token
            } catch (Exception e) {
                DebuggerTrace.Log(e);
            }
        }

        [WebMethod]
        public string SetHandleExceptionMode(string debugSessionToken, bool breakOnAllErrors) {
            try {
                CallerType callerType = GetCallerType(debugSessionToken);
                DebugSession debugSession = debugSessions.GetByToken(debugSessionToken);
                if (callerType == CallerType.Unknown) {
                    DebuggerTrace.Log("SetHandleExceptionMode, callerType==CallerType.Unknown");
                    return GetCallerTypeError(debugSession);
                }

                // set mode
                debugSession.ExceptionMode = breakOnAllErrors ? HandleExceptionMode.BreakOnAll : HandleExceptionMode.DoNotBreak;
                DebuggerTrace.Log("SetHandleExceptionMode " + debugSession.ExceptionMode);

                // if called by service studio and in clustered mode, forward the call
                // to all of the other nodes
                if (callerType == CallerType.ServiceStudio && clustered) {
                    foreach (_Debugger dbg in GetDebuggerWebServices())
                        dbg.SetHandleExceptionMode(debugSessionToken, breakOnAllErrors);
                }

                SaveDebugSessionsData();
            } catch (Exception e) {
                DebuggerTrace.Log(e);
            }

            return "";
        }

        [WebMethod]
        public string AddBreakpoints(string debugSessionToken, string breakpointsIds) {
            try {
                CallerType callerType = GetCallerType(debugSessionToken);
                DebugSession debugSession = debugSessions.GetByToken(debugSessionToken);
                if (callerType == CallerType.Unknown) {
                    return GetCallerTypeError(debugSession);
                }

                // add breakpoints
                DebuggerTrace.Log("AddBreakpoints " + breakpointsIds);
                if (breakpointsIds.IsEmpty()) {
                    return "";
                }

                foreach (string breakpointIdStr in breakpointsIds.Split(',')) {

                    BreakpointId breakpointId = null;
                    if (BreakpointId.TryParse(breakpointIdStr, out breakpointId)) {
                        debugSession.Add(breakpointId);
                    }
                }

                // if called by service studio and in clustered mode, forward the call
                // to all of the other nodes
                if (callerType == CallerType.ServiceStudio && clustered) {
                    foreach (_Debugger dbg in GetDebuggerWebServices())
                        dbg.AddBreakpoints(debugSessionToken, breakpointsIds);
                }

                SaveDebugSessionsData();

                return "";
            } catch (Exception e) {
                DebuggerTrace.Log(e);
                return "ERROR: Debugger_Exception|" + e.Message;
            }
        }

        [WebMethod]
        public string RemoveBreakpoint(string debugSessionToken, string breakpointId) {
            try {
                CallerType callerType = GetCallerType(debugSessionToken);
                DebugSession debugSession = debugSessions.GetByToken(debugSessionToken);
                if (callerType == CallerType.Unknown) {
                    return GetCallerTypeError(debugSession);
                }

                // remove breakpoint
                DebuggerTrace.Log("RemoveBreakpoint " + breakpointId);

                BreakpointId breakpointIdObj = null;
                if (BreakpointId.TryParse(breakpointId, out breakpointIdObj)) {
                    debugSession.Remove(breakpointIdObj);
                }

                // if called by service studio and in clustered mode, forward the call
                // to all of the other nodes
                if (callerType == CallerType.ServiceStudio && clustered) {
                    foreach (_Debugger dbg in GetDebuggerWebServices())
                        dbg.RemoveBreakpoint(debugSessionToken, breakpointId);
                }

                SaveDebugSessionsData();
            } catch (Exception e) {
                DebuggerTrace.Log(e);
            }

            return "";
        }


        [WebMethod]
        public string ClearBreakpoints(string debugSessionToken) {
            try {
                CallerType callerType = GetCallerType(debugSessionToken);
                DebugSession debugSession = debugSessions.GetByToken(debugSessionToken);
                if (callerType == CallerType.Unknown) {
                    return GetCallerTypeError(debugSession);
                }

                // remove breakpoints
                DebuggerTrace.Log("ClearBreakpoints");
                debugSession.ClearBreakpoints();

                // if called by service studio and in clustered mode, forward the call
                // to all of the other nodes
                if (callerType == CallerType.ServiceStudio && clustered) {
                    foreach (_Debugger dbg in GetDebuggerWebServices())
                        dbg.ClearBreakpoints(debugSessionToken);
                }

                SaveDebugSessionsData();
            } catch (Exception e) {
                DebuggerTrace.Log(e);
            }

            return "";
        }

        [WebMethod]
        public string SuspendAllThreads(string debugSessionToken) {
            try {
                CallerType callerType = GetCallerType(debugSessionToken);
                DebugSession debugSession = debugSessions.GetByToken(debugSessionToken);
                if (callerType == CallerType.Unknown) {
                    return GetCallerTypeError(debugSession);
                }

                DebuggerTrace.Log("SuspendAllThreads");
                // suspend all running threads
                lock (threads) {
                    foreach (ThreadData threadData in threads.Values.ToArray()) {
                        debugSessions.Enqueue(new BeforeSuspendEvent(threadData), debugSessionToken);
                        threadData.Suspend();
                    }
                }

                // if called by service studio and in clustered mode, forward the call
                // to all of the other nodes
                if (callerType == CallerType.ServiceStudio && clustered) {
                    foreach (_Debugger dbg in GetDebuggerWebServices())
                        dbg.SuspendAllThreads(debugSessionToken);
                }

                SaveDebugSessionsData();
            } catch (Exception e) {
                DebuggerTrace.Log(e);
            }

            return "";
        }

        [WebMethod]
        public string ContinueThread(string debugSessionToken, string threadId) {
            try {
                CallerType callerType = GetCallerType(debugSessionToken);
                DebugSession debugSession = debugSessions.GetByToken(debugSessionToken);
                if (callerType == CallerType.Unknown) {
                    return GetCallerTypeError(debugSession);
                }

                // if threadId corresponds to a local thread apply the command here,
                // else forward it to the correct machine
                if (IsLocalThread(threadId)) {
                    DebuggerTrace.Log("Continue " + threadId);
                    // get thread. If not found, assume it has already ended and Service Studio
                    // somehow missed its end event
                    ThreadData threadData = GetThreadData(threadId);
                    if (threadData != null) {
                        threadData.SetAffinity(debugSession);
                        threadData.ContinueThread();
                    } else {
                        SendThreadEndEvent(threadId, /*affinedSession*/null);
                    }
                } else {
                    DebuggerTrace.Log("Forwarding Continue " + threadId);
                    using (_Debugger dbg = GetDebuggerWebService(GetHostFromThreadId(threadId))) {
                        dbg.ContinueThread(debugSessionToken, threadId);
                    }
                }
            } catch (Exception e) {
                DebuggerTrace.Log(e);
            }

            return "";
        }

        [WebMethod]
        public string Stop(string debugSessionToken, string threadId) {
            try {
                CallerType callerType = GetCallerType(debugSessionToken);
                DebugSession debugSession = debugSessions.GetByToken(debugSessionToken);
                if (callerType == CallerType.Unknown) {
                    return GetCallerTypeError(debugSession);
                }

                // if threadId corresponds to a local thread apply the command here,
                // else forward it to the correct machine
                if (IsLocalThread(threadId)) {
                    DebuggerTrace.Log("Stop " + threadId);
                    ThreadData threadData = GetThreadData(threadId);
                    if (threadData != null) {
                        threadData.SetAffinity(debugSession);
                        threadData.Stop();
                    } else {
                        SendThreadEndEvent(threadId, /*affinedSession*/null);
                    }
                } else {
                    DebuggerTrace.Log("Forwarding Stop " + threadId);
                    using (_Debugger dbg = GetDebuggerWebService(GetHostFromThreadId(threadId))) {
                        dbg.Stop(debugSessionToken, threadId);
                    }
                }
            } catch (Exception e) {
                DebuggerTrace.Log(e);
            }

            return "";
        }

        [WebMethod]
        public string RunTo(string debugSessionToken, string threadId, string breakpointId) {
            try {
                CallerType callerType = GetCallerType(debugSessionToken);
                DebugSession debugSession = debugSessions.GetByToken(debugSessionToken);
                if (callerType == CallerType.Unknown) {
                    return GetCallerTypeError(debugSession);
                }

                // if threadId corresponds to a local thread apply the command here,
                // else forward it to the correct machine
                if (IsLocalThread(threadId)) {
                    DebuggerTrace.Log("RunTo " + threadId + ", " + breakpointId + " called");
                    // get thread. If not found, assume it has already ended and Service Studio
                    // somehow missed its end event
                    ThreadData threadData = GetThreadData(threadId);
                    if (threadData != null) {

                        BreakpointId breakpointIdObj = null;
                        if (BreakpointId.TryParse(breakpointId, out breakpointIdObj)) {
                            threadData.RunToBreakpoint = breakpointIdObj;
                        }
                        threadData.SetAffinity(debugSession);
                        threadData.ContinueThread();
                        return "";
                    } else {
                        SendThreadEndEvent(threadId, /*affinedSession*/null);
                        return "ERROR: Debugger_UnknownThreadForRunTo";
                    }
                } else {
                    DebuggerTrace.Log("Forwarding RunTo " + threadId + ", " + breakpointId);
                    using (_Debugger dbg = GetDebuggerWebService(GetHostFromThreadId(threadId))) {
                        return dbg.RunTo(debugSessionToken, threadId, breakpointId);
                    }
                }
            } catch (Exception e) {
                DebuggerTrace.Log(e);
                return "ERROR: Debugger_Exception|" + e.Message;
            }
        }

        [WebMethod]
        public string StepInto(string debugSessionToken, string threadId) {
            try {
                CallerType callerType = GetCallerType(debugSessionToken);
                DebugSession debugSession = debugSessions.GetByToken(debugSessionToken);
                if (callerType == CallerType.Unknown) {
                    return GetCallerTypeError(debugSession);
                }

                // if threadId corresponds to a local thread apply the command here,
                // else forward it to the correct machine
                if (IsLocalThread(threadId)) {
                    DebuggerTrace.Log("StepInto " + threadId + " called");
                    // get thread. If not found, assume it has already ended and Service Studio
                    // somehow missed its end event
                    ThreadData threadData = GetThreadData(threadId);
                    if (threadData != null) {
                        threadData.SetAffinity(debugSession);
                        threadData.StepInto();
                    } else {
                        SendThreadEndEvent(threadId, /*affinedSession*/null);
                    }
                } else {
                    DebuggerTrace.Log("Forwarding StepInto " + threadId);
                    using (_Debugger dbg = GetDebuggerWebService(GetHostFromThreadId(threadId))) {
                        dbg.StepInto(debugSessionToken, threadId);
                    }
                }
            } catch (Exception e) {
                DebuggerTrace.Log(e);
            }

            return "";
        }

        [WebMethod]
        public string StepOver(string debugSessionToken, string threadId) {
            try {
                CallerType callerType = GetCallerType(debugSessionToken);
                DebugSession debugSession = debugSessions.GetByToken(debugSessionToken);
                if (callerType == CallerType.Unknown) {
                    return GetCallerTypeError(debugSession);
                }

                // if threadId corresponds to a local thread apply the command here,
                // else forward it to the correct machine
                if (IsLocalThread(threadId)) {
                    DebuggerTrace.Log("StepOver " + threadId + " called");
                    // get thread. If not found, assume it has already ended and Service Studio
                    // somehow missed its end event
                    ThreadData threadData = GetThreadData(threadId);
                    if (threadData != null) {
                        threadData.SetAffinity(debugSession);
                        threadData.StepOver();
                    } else {
                        SendThreadEndEvent(threadId, /*affinedSession*/null);
                    }
                } else {
                    DebuggerTrace.Log("Forwarding StepOver " + threadId);
                    using (_Debugger dbg = GetDebuggerWebService(GetHostFromThreadId(threadId))) {
                        dbg.StepOver(debugSessionToken, threadId);
                    }
                }
            } catch (Exception e) {
                DebuggerTrace.Log(e);
            }

            return "";
        }

        [WebMethod]
        public string StepOut(string debugSessionToken, string threadId) {
            try {
                CallerType callerType = GetCallerType(debugSessionToken);
                DebugSession debugSession = debugSessions.GetByToken(debugSessionToken);
                if (callerType == CallerType.Unknown) {
                    return GetCallerTypeError(debugSession);
                }

                // if threadId corresponds to a local thread apply the command here,
                // else forward it to the correct machine
                if (IsLocalThread(threadId)) {
                    DebuggerTrace.Log("StepOut " + threadId + " called");
                    // get thread. If not found, assume it has already ended and Service Studio
                    // somehow missed its end event
                    ThreadData threadData = GetThreadData(threadId);
                    if (threadData != null) {
                        threadData.SetAffinity(debugSession);
                        threadData.StepOut();
                    } else {
                        SendThreadEndEvent(threadId, /*affinedSession*/null);
                    }
                } else {
                    DebuggerTrace.Log("Forwarding StepOut " + threadId);
                    using (_Debugger dbg = GetDebuggerWebService(GetHostFromThreadId(threadId))) {
                        dbg.StepOut(debugSessionToken, threadId);
                    }
                }
            } catch (Exception e) {
                DebuggerTrace.Log(e);
            }

            return "";
        }

        [WebMethod]
        public string GetDebugEvent(string debugSessionToken, long lastEventReceived) {
            try {
                CallerType callerType = GetCallerType(debugSessionToken);
                DebugSession debugSession = debugSessions.GetByToken(debugSessionToken);
                if (callerType == CallerType.Unknown) {
                    return GetCallerTypeError(debugSession);
                }

                long eventId;
                DebuggerEvent _event = GetDebugEvent(debugSessionToken, lastEventReceived, GET_DEBUG_EVENT_TIMEOUT_IN_MS, out eventId);
                if (_event == null) {
                    return null;
                } else {
                    return _event.ToXml(eventId, !Debugger.IsInPublicArea, debugSession);
                }
            } catch (Exception e) {
                DebuggerTrace.Log(e);
                return "ERROR: Debugger_Exception|" + e.Message;
            }
        }

        [WebMethod]
        public string Evaluate(string debugSessionToken, string threadId, string vars) {
            try {
                CallerType callerType = GetCallerType(debugSessionToken);
                DebugSession debugSession = debugSessions.GetByToken(debugSessionToken);
                if (callerType == CallerType.Unknown) {
                    return GetCallerTypeError(debugSession);
                }

                // if threadId corresponds to a local thread apply the command here,
                // else forward it to the correct machine
                if (IsLocalThread(threadId)) {
                    // get thread. If not found, assume it has already ended and Service Studio
                    // somehow missed its end event
                    ThreadData threadData = GetThreadData(threadId);
                    if (threadData != null) {
                        DebuggerTrace.Log("Evaluate " + threadId + ", " + vars);
                        SetDebuggerThreadTenant(threadData);

                        XmlDocument varsXml = new XmlDocument();
                        varsXml.LoadXml(vars);

                        for (int i = varsXml.DocumentElement.ChildNodes.Count - 1; i >= 0; i--) {
                            XmlElement var = (XmlElement)varsXml.DocumentElement.ChildNodes[i];
                            threadData.Evaluate(var);
                        }

                        DebuggerTrace.Log("  " + varsXml.OuterXml);
                        return varsXml.OuterXml;
                    } else {
                        SendThreadEndEvent(threadId, /*affinedSession*/null);
                        return "";
                    }
                } else {
                    DebuggerTrace.Log("Forwarding Evaluate " + threadId + ", " + vars);
                    using (_Debugger dbg = GetDebuggerWebService(GetHostFromThreadId(threadId))) {
                        return dbg.Evaluate(DebuggerToken, threadId, vars);
                    }
                }
            } catch (Exception e) {
                DebuggerTrace.Log(e);
                return "";
            }
        }
        #endregion

        private void SetDebuggerThreadTenant(ThreadData thread) {
            if (thread != null) {
                AppInfo.GetAppInfo().OsContext.Session["TenantID"] = thread.Stack.CurrentTenantId;
            }
        }

        private static string GetCallerTypeError(DebugSession debugSession) {
            return "ERROR: " +
                (debugSession == null ? "Debugger_SessionEnded" : "Debugger_CannotJoinSession");
        }

        public static void Stop(string debugSessionToken) {
            try {
                DebuggerTrace.Log("Stop debugSessionToken=" + (debugSessionToken == null ? debugSessions.ActiveDebugSessionTokens.StrCat(", ") : debugSessionToken));

                lock (debugSessions) {
                    if (debugSessionToken == null) {
                        debugSessions.Reset();
                        lock (openESpaces) {
                            openESpaces.Clear();
                        }
                    } else {
                        debugSessions.Remove(debugSessions.GetByToken(debugSessionToken));
                    }
                }

                // TODO: stop the debug session in the other Front-end Servers
            } catch (Exception e) {
                DebuggerTrace.Log(e);
            }
        }

        public static void SendThreadEndEventAndRemoveThread(string threadId, DebugSession affinedSession) {
            // since we now send ConcurrentAtBreakpointEvent to all debug session, we need to
            // send this event also to all sessions
            debugSessions.Enqueue(new ThreadEndEvent(threadId, affinedSession));
            RemoveThread(threadId);
        }

        private static void RemoveThread(string threadId) {
            /* NOTE: We must lock the NO_ACTIVE_THREADS_MONOTORING variable since we may need to pulse it later. 
             * This locks should be in this order since in other parts (namelly in the ApplicationListener.contextDestroyed of Java) 
             * we also lock in this order. 
             * IMPORTANT: It may cause deadlocks if the order of the adquired locks is different */
            lock (NO_ACTIVE_THREADS_MONOTORING) {
                lock (threads) {
                    ThreadData thread;
                    if (Debugger.ThreadId == threadId) {
                        thread = Debugger.ThreadData;
                        Debugger.ThreadData = null;
                        CleanThreadId();
                        CleanSessionsForCurrentBreakpoint();
                    } else {
                        threads.TryGetValue(threadId, out thread);
                    }

                    threads.Remove(threadId);

                    if (threads.Count == 0) {
                        Monitor.PulseAll(NO_ACTIVE_THREADS_MONOTORING);
                    }

                    if (thread != null) {
                        thread.Discarded = true;
                    }
                }
            }
        }

        public static void SendThreadEndEvent(string threadId, DebugSession affinedSession) {
            // since we now send ConcurrentAtBreakpointEvent to all debug session, we need to
            // send this event also to all sessions
            debugSessions.Enqueue(new ThreadEndEvent(threadId, affinedSession));
        }

        public static void AddClient(DebuggerEventsData client) {
            lock (debugSessions) {
                lock (openESpaces) {
                    openESpaces.Add(client);
                    DebugSession debugSession = debugSessions.GetByToken(client.DebugSessionToken);
                    if (debugSession != null) {
                        debugSession.AddClient(client);
                    }

                    // TODO: in clustering mode, notify the other Front-end Servers
                }
            }
        }

        public static void RemoveClient(DebuggerEventsData client) {
            lock (debugSessions) {
                lock (openESpaces) {
                    openESpaces.Remove(client);
                    DebugSession debugSession = debugSessions.GetByToken(client.DebugSessionToken);
                    if (debugSession != null) {
                        debugSession.RemoveClient(client);
                    }

                    // TODO: in clustering mode, notify the other Front-end Servers
                }
            }
        }

        public static bool HasConnectedClients(string debugSessionToken) {
            return debugSessions.HasConnectedClients(debugSessionToken);
        }

        internal static bool IsESpaceOpen(ObjectKey eSpaceUID) {
            if (eSpaceUID == null)
                return false;

            lock (openESpaces) {
                // When the debugger starts up, it is possible that the browser
                // is launched before Service Studio manages to connect to the event page,
                // so we consider that the espace is open if there are currently no clients
                if (openESpaces.Count == 0)
                    return true;

                foreach (DebuggerEventsData client in openESpaces) {
                    if (client.eSpaceUID == eSpaceUID)
                        return true;
                }
            }
            return false;
        }

        private CallerType GetCallerType(string debugSessionToken) {
            if (debugSessionToken == DebuggerToken) {
                return CallerType.Debugger;
            } else if (debugSessionToken == DeployServiceToken) {
                return CallerType.DeployService;
            } else if (IsValidDebugSessionToken(debugSessionToken)) {
                return CallerType.ServiceStudio;
            } else {
                return CallerType.Unknown;
            }
        }

        internal static ThreadData GetThreadData(string threadId) {
            lock (threads) {
                ThreadData result;
                threads.TryGetValue(threadId, out result);
                return result;
            }
        }

        public static bool HasSuspendedThreads(string debugSessionToken) {
            lock (threads) {
                return threads.Values.Any(t =>
                    t.IsSuspended && (t.DebugSessionToken == null || t.DebugSessionToken == debugSessionToken));
            }
        }

        public static bool HasSuspendedThreadWithRequestToken(string requestToken) {
            lock (threads) {
                return threads.Values.Any(t => t.IsSuspended && t.ClientRequestToken == requestToken);
            }
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static bool HasBreakpoint(BreakpointId breakpointId) {
            return HasBreakpoint(breakpointId, false, BreakpointType.Normal, null);
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static bool HasBreakpoint(BreakpointId breakpointId, bool isExpressionlessWidget) {
            return HasBreakpoint(breakpointId, isExpressionlessWidget, BreakpointType.Normal, null);
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static bool HasBreakpoint(BreakpointId breakpointId, BreakpointType breakpointType) {
            return HasBreakpoint(breakpointId, false, breakpointType, null);
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static bool HasBreakpoint(BreakpointId breakpointId, BreakpointType breakpointType, string extraInfo) {
            return HasBreakpoint(breakpointId, false, breakpointType, extraInfo);
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static bool HasBreakpoint(BreakpointId breakpointId, bool isExpressionlessWidget, BreakpointType breakpointType, string extraInfo) {
            bool hasBreakpoint = HasBreakpointAux(breakpointId, isExpressionlessWidget, breakpointType, extraInfo);
            if (!hasBreakpoint)
                ThreadData.SendContinueEvent();
            return hasBreakpoint;
        }

        public static BreakpointId Parse(string breakpointIdStr) {
            // no need to do the actual parsing if we're not debugging
            if (!IsRunning) {
                return null;
            }
            BreakpointId result;
            BreakpointId.TryParse(breakpointIdStr, out result);
            return result;
        }

        private static bool HasBreakpointAux(BreakpointId breakpointId, bool isExpressionlessWidget, BreakpointType breakpointType, string extraInfo) {
            try {
                if (AppIsBeingRedeployed) {
                    return false;
                }

                LocalState stackTop = ThreadData.Stack.Top;
                if (stackTop == null)
                    return false;

                // in order to try to detect infinite loops, we count the number of breakpoints that
                // have been visited in the current stack level. If the count exceeds the configured
                // maximum amount, then sleep a bit so that the debugger can react to user commands 
                // (namely to the SuspendAllThreads command!)
                stackTop.VisitedBreakpoints = stackTop.VisitedBreakpoints + 1;
                int nBreakpoints = stackTop.VisitedBreakpoints;
                if (nBreakpoints >= INFINITE_LOOP_THRESHOLD) {
                    stackTop.VisitedBreakpoints = 0;
                    Thread.Sleep(INFINITE_LOOP_SLEEP);
                }

                sessionsForCurrentBreakpoint = debugSessions.GetSessionsForBreakpoint(ThreadData, breakpointId, isExpressionlessWidget, breakpointType, extraInfo);
                bool hasBreakpoint = !sessionsForCurrentBreakpoint.IsEmpty();
                DebuggerTrace.LogHasBreakpoint(breakpointId, debugSessions, hasBreakpoint);
                return hasBreakpoint;
            } catch (Exception e) {
                DebuggerTrace.Log(e);
                return false;
            }
        }

        // this is called always after HasBreakpoint, so there is no need
        // to recheck that there is a breakpoint here. It will be used to
        // implement conditional breakpoints.
        private static bool EvaluateBreakpointCondition() {
            // current breakpoint is available at ThreadData.Stack.Top.CurrentBreakpointId
            return true;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static bool HandleBreakpoint(BreakpointId breakpointId) {
            if (HasBreakpoint(breakpointId))
                HandleBreakpoint();
            return true;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static bool HandleBreakpoint(BreakpointId breakpointId, bool isExpressionlessWidget) {
            if (HasBreakpoint(breakpointId, isExpressionlessWidget))
                HandleBreakpoint();
            return true;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static bool HandleBreakpoint(BreakpointId breakpointId, BreakpointType breakpointType) {
            if (HasBreakpoint(breakpointId, breakpointType))
                HandleBreakpoint();
            return true;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static bool HandleBreakpoint(BreakpointId breakpointId, BreakpointType breakpointType, string extraInfo) {
            if (HasBreakpoint(breakpointId, breakpointType, extraInfo))
                HandleBreakpoint();
            return true;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static bool HandleBreakpoint() {
            return HandleBreakpoint((string)null, (object)null);
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static bool HandleFunctionExitBreakpoint(string name, Object returnValue) {
            return HandleBreakpoint(name, returnValue);
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private static bool HandleBreakpoint(string functionLeft, Object returnValue) {
            try {
                ThreadData.Stack.UpdateSession();
                if (EvaluateBreakpointCondition() == true) {
                    // send event and then block until a debug command is received
                    AtBreakpointEvent evt = new AtBreakpointEvent(ThreadData);
                    ThreadData.SendBreakpointEventAndWaitForCommand(sessionsForCurrentBreakpoint, evt, functionLeft, returnValue);
                    CleanSessionsForCurrentBreakpoint();
                }
            } catch (DebuggerException de) {
                DebuggerTrace.Log(de);
                throw;
            } catch (Exception e) {
                DebuggerTrace.Log(e);
            }
            return true;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static void HandleException(Exception e, bool isUnhandled) {
            try {
                if (!IsRunning || e.GetType() == typeof(DebuggerException) || IsThreadAbortException(e))
                    return;

                if (ThreadData.LastExceptionThrown == null || ThreadData.LastExceptionThrown.Exception != e)
                    ThreadData.LastExceptionThrown = new ExceptionData(e, ThreadData);

                // get sessions for which this request applies: all the exceptions which have BreakOnAll set
                IEnumerable<DebugSession> sessions = debugSessions.GetSessionsForCurrentRequest()
                                                        .Where(s => s.ExceptionMode == HandleExceptionMode.BreakOnAll);

                // for unhandled exceptions we suspend only when we reach the stack's root
                // (only by then do we know that the exception is unhandled...).
                // for handled exceptions we break right when the exception is thrown but
                // only if the HandleExceptionMode is BreakOnAll
                bool sendExceptionThrownEvent;
                bool disposeException;
                if (isUnhandled) {
                    sendExceptionThrownEvent = (ThreadData.Stack.Depth <= 1) && !sessions.IsEmpty();
                    disposeException = sendExceptionThrownEvent;
                } else {
                    sendExceptionThrownEvent = !sessions.IsEmpty();
                    disposeException = true;
                }
                if (sendExceptionThrownEvent) {
                    ExceptionData lastException = ThreadData.LastExceptionThrown;
                    if (lastException.Stack.Top != null) {
                        //#150502 Clean current breakpoint type so we get expected results on SS
                        lastException.Stack.Top.CurrentBreakpointType = BreakpointType.Normal;
                    }
                    ThreadData.SendBreakpointEventAndWaitForCommand(
                        sessions,
                        new ExceptionThrownEvent(lastException), null, null);
                }
                if (disposeException) {
                    ThreadData.LastExceptionThrown = null;
                }
            } catch (Exception e2) {
                DebuggerTrace.Log(e2);
            }
        }

        public static void ClearLastException() {
            ThreadData.LastExceptionThrown = null;
        }

        public static void HandleUnhandledException() {
            try {
                ExceptionData lastException = ThreadData.LastExceptionThrown;
                if (lastException.Stack.Top != null) {
                    //#150502 Clean current breakpoint type so we get expected results on SS
                    lastException.Stack.Top.CurrentBreakpointType = BreakpointType.Normal;
                }
                IEnumerable<DebugSession> sessions = debugSessions.GetSessionsForCurrentRequest().Where(s => s.ExceptionMode == HandleExceptionMode.BreakOnAll);
                ThreadData.SendBreakpointEventAndWaitForCommand(
                    sessions,
                    new ExceptionThrownEvent(lastException), null, null);

                ThreadData.LastExceptionThrown = null;
                CleanCurrentProcessInfo(false);
            } catch (Exception e) {
                DebuggerTrace.Log(e);
            }
        }

        protected static bool IsThreadAbortException(Exception e) {
            return e.GetType() == typeof(ThreadAbortException);
        }

        public static DebuggerEvent GetDebugEvent(string debugSessionToken, long lastEventReceived, int timeoutInMs, out long eventId) {
            // TODO: if clustered, must also get events from the other Front-end Servers
            // Investigate the best way to do this:
            // - use threads here and call GetDebugEvent for all of the other Front-end Servers
            //   (but this means a lot of threads are wasted -> we need one for each Front-end Server
            //    and eSpace)
            // - have a centralized "event repository": one of the Debuggers acts as the master
            //   (less threads used...)

            DebugSession debugSession = debugSessions.GetByToken(debugSessionToken);
            if (debugSession != null) {
                return debugSession.GetDebugEvent(lastEventReceived, timeoutInMs, out eventId);
            } else {
                throw new DebuggerException("Session is no longer available");
            }
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static LocalState Push(string eSpaceName, string functionId, string functionName, string functionType) {
            return Push(eSpaceName, functionId, functionName, functionType, (IVarsBag)null, (IVarsBag)null);
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static void Push(LocalState state) {
            ThreadData.Stack.UpdateSession();
            ThreadData.Stack.Push(state);
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static LocalState Push(string eSpaceName, string functionId, string functionName, string functionType, IVarsBag page, params IVarsBag[] list) {
            try {
                if (Debugger.IsRunning) {
                    RuntimePlatformUtils.SetScriptTimeout(REQUEST_TIMEOUT_IN_SECONDS);
                }
                ThreadData.Stack.UpdateSession();
                return ThreadData.Stack.Push(eSpaceName, functionId, functionName, functionType, page, list);
            } finally {
                if (DEBUG_STACK_METHODS) {
                    DebuggerTrace.Log("Push(" + functionName + "); StackDepth=" + ThreadData.Stack.Depth);
                }
            }
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static void SetRequestName(string name) {
            ThreadData.ThreadName = name;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static void SetRequestNameFirstTime(string name) {
            if (ThreadData.ThreadName == null) {
                ThreadData.ThreadName = name;
            }
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static void Pop(LocalState stateToPop, bool keepThread) {
            try {
                if (!ThreadDataExists)
                    return;

                DebugSession debugSession = ThreadData.DebugSession;
                if (ThreadData.Stack.Pop(stateToPop) && ThreadData.Stack.Depth == 0) {
                    if (DEBUG_STACK_METHODS) {
                        DebuggerTrace.Log("Pop(" + stateToPop.FunctionName + ", " + keepThread + "); StackDepth=" + ThreadData.Stack.Depth);
                    }

                    // if an exception has occurred and has not been processed yet, we must keep the thread
                    if (ThreadData.LastExceptionThrown != null) {
                        keepThread = true;
                    }

                    // send end thread event if the thread had been suspended to the debugger
                    if (!keepThread) {
                        if (ThreadData.WasSuspended) {
                            SendThreadEndEvent(ThreadData.ThreadId, debugSession);
                        }

                        RemoveThread(ThreadData.ThreadId);
                    }

                    if (DEBUG_STACK_METHODS) {
                        DebuggerTrace.Log("Number of active threads = " + threads.Count);
                    }
                }
            } catch (Exception e) {
                DebuggerTrace.Log(e);
            }
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static void PopAll() {
            try {
                if (!ThreadDataExists)
                    return;

                DebugSession debugSession = ThreadData.DebugSession;
                ThreadData.Stack.PopAll();
                if (DEBUG_STACK_METHODS) {
                    DebuggerTrace.Log("PopAll(); StackDepth=" + ThreadData.Stack.Depth);
                }

                // if an exception has occurred and has not been processed yet, we must keep the thread
                if (ThreadData.LastExceptionThrown == null) {

                    // remove thread
                    // send debug event if the thread had been suspended
                    if (ThreadData.WasSuspended) {
                        SendThreadEndEvent(ThreadData.ThreadId, debugSession);
                    }

                    CleanCurrentProcessInfo(false);
                    RemoveThread(ThreadData.ThreadId);
                }

                if (DEBUG_STACK_METHODS) {
                    DebuggerTrace.Log("Number of active threads = " + threads.Count);
                }
            } catch (Exception e) {
                DebuggerTrace.Log(e);
            }
        }

        public static void OnEndRequest() {
            try {
                if (ThreadDataExists) {
                    if (ThreadData.LastExceptionThrown != null) {
                        HandleUnhandledException();
                    }
                    PopAll();
                }
            } finally {
                ClearThreadPrivateData();
            }
        }

        public static void SetPhase(string phase) {
            if (ThreadDataExists && ThreadData.Stack.Top != null) {
                ThreadData.Stack.Top.Phase = phase;
            }
        }

        public static void AddExtraVariable(string name, object value) {
            if (ThreadData.Stack.Top != null) {
                ThreadData.Stack.Top.AddExtraVariable(name, value);
            }
        }

        public static LocalState Top {
            get {
                return ThreadDataExists ? ThreadData.Stack.Top : null;
            }
        }

        private bool IsLocalThread(string threadId) {
            return !clustered || GetHostFromThreadId(threadId) == machineId;
        }

        private string GetHostFromThreadId(string threadId) {
            return threadId.Substring(threadId.IndexOf("@") + 1);
        }

        private _Debugger[] GetDebuggerWebServices() {
            // TODO: return all but local machine
            return new _Debugger[] { };
        }

        private _Debugger GetDebuggerWebService(string host) {
            // TODO: check if we should use a pool of debugger objects instead of always creating
            // new ones
            string url = DebuggerUrl(host, RunningInfo.EspaceName, /*tenantName*/null, RunningInfo.PAName);
            _Debugger dbg = new _Debugger(url);
            return dbg;
        }

        public static void ClearThreadPrivateData() {
            ClearThreadData();
            CleanThreadId();
            CleanSessionsForCurrentBreakpoint();
            CleanCurrentProcessInfo(true);
        }
    }

    public class DebuggerException : Exception {
        public DebuggerException(string msg)
            : base(msg) {
        }
    }

    /// <summary>
    /// 
    /// </summary>
    enum CallerType {
        ServiceStudio,
        Debugger,
        DeployService,
        Unknown
    }

    public enum HandleExceptionMode {
        BreakOnAll,
        DoNotBreak
    }


    /// <summary>
    /// 
    /// </summary>
    class EventQueue {
        // the session token is used only for debug purposes (for writing messages
        // to the debug.txt file)
        DebugSession ownerSession;

        long lastId = 0;
        List<Pair<long, DebuggerEvent>> events = new List<Pair<long, DebuggerEvent>>();
        bool sessionHasBeenStopped = false;

        // the time (in ms) that an event will be kept in the queue. This value must be
        // higher that then expected time Service Studio takes to reconnect after a broken
        // connection.
        const int MAX_EVENT_KEEP_TIME = 20000;

        public EventQueue(DebugSession ownerSession) {
            this.ownerSession = ownerSession;
            Thread cleanupThread = new Thread(new ThreadStart(RemoveOldEvents));
            cleanupThread.Start();
        }

        private void RemoveOldEvents() {
            RuntimePlatformUtils.SetupCurrentThreadCulture();
            while (true) {
                long pastTime = DateTime.Now.Ticks;
                Thread.Sleep(MAX_EVENT_KEEP_TIME);

                bool isValidToken = Debugger.DebugSessions.IsValidToken(ownerSession.Token);

                lock (events) {
                    int eventsToRemove;
                    for (eventsToRemove = 0; eventsToRemove < events.Count; eventsToRemove++) {
                        var idAndEvent = events[eventsToRemove];
                        DebuggerEvent _event = idAndEvent.Second;
                        if (_event.CreationTime > pastTime)
                            break;
                    }

                    if (eventsToRemove != 0) {
                        DebuggerTrace.Log("Removing " + eventsToRemove + " old events for session " + ownerSession.Token);
                        for (int i = 0; i < eventsToRemove; i++)
                            events.RemoveAt(0);
                        DebuggerTrace.Log("Queue now has " + events.Count + " events");
                    }

                    // remove event queue if no longer needed
                    if ((sessionHasBeenStopped || !isValidToken) && events.Count == 0) {
                        DebuggerTrace.Log("Removing unused event queue for session " + ownerSession.Token);
                        Debugger.Remove(ownerSession);
                        return;
                    }
                }
            }
        }

        public void Clear() {
            lock (events) {
                events.Clear();
            }
        }

        public void Enqueue(DebuggerEvent _event) {
            lock (events) {
                DebuggerTrace.Log("QueueEvent " + _event);
                _event.CreationTime = DateTime.Now.Ticks;
                events.Add(Pair.Create(++lastId, _event));
                if (_event is StopDebugSessionEvent || _event is ApplicationIsBeingRedeployedEvent) {
                    sessionHasBeenStopped = true;
                }

                Monitor.PulseAll(events);
            }
        }


        private bool HasNewEvent(long lastEventReceived) {
            if (events.Count == 0)
                return false;

            if (lastEventReceived == lastId)
                return false;

            return true;
        }

        public DebuggerEvent Dequeue(long lastEventReceived, int timeoutInMs, out long eventId) {
            lock (events) {
                eventId = -1;

                // if no event in queue, wait a bit for a new one (don't block forever
                // since this is being called from a web service and timeouts will occur)
                if (!HasNewEvent(lastEventReceived)) {
                    if (timeoutInMs > 0) {
                        Monitor.Wait(events, timeoutInMs);
                    } else {
                        return null;
                    }
                }

                if (!HasNewEvent(lastEventReceived)) {
                    return null;
                } else {
                    Pair<long, DebuggerEvent> idAndEvent = events[0];
                    eventId = idAndEvent.First;

                    int offset = (int)((lastEventReceived + 1) - eventId);
                    if (offset > 0 && offset < events.Count) {
                        idAndEvent = events[offset];
                        eventId = idAndEvent.First;
                    }

                    eventId = idAndEvent.First;
                    DebuggerEvent _event = idAndEvent.Second;

                    long _eventId = eventId;
                    DebuggerTrace.Log(() => "Got event " + _event.ToXml(_eventId, !Debugger.IsInPublicArea, ownerSession));
                    return _event;
                }
            }
        }
    }

    #region Debug events
    /// <summary>
    /// Abstract class for debug events. These are generated by the server and sent
    /// to all listening Service Studios.
    /// All events include the following data:
    /// 
    /// - eventId: this is a serial number that is used to keep track of which events
    ///   Service Studio has already received, so that we can gracefuly recover from
    ///   connection errors;
    ///   
    /// - threadId: the thread that generated the event. This is used by Service Studio
    ///   to identify the target of continue/step commands
    /// </summary>
    [DoNotObfuscateType]
    public abstract class DebuggerEvent {
        [NonSerialized]
        protected long creationTime;

        // this field is filled only by the events for which we need info
        // on the user for which the event was originally created: ConcurrentAtBreakpoint
        // and ThreadEndEvent
        [NonSerialized]
        protected string userName;

        protected string threadId;
        protected string requestId;
        protected string threadName;
        protected bool isLongLivedRequest;
        protected int clientThreadId;

        public long CreationTime {
            get {
                return creationTime;
            }
            set {
                creationTime = value;
            }
        }

        protected DebuggerEvent() {
        }

        protected DebuggerEvent(ThreadData threadData) {
            Init(threadData);
        }

        private void Init(ThreadData threadData) {
            this.threadId = threadData.ThreadId;
            this.requestId = threadData.RequestId;
            this.threadName = threadData.ThreadName;
            this.clientThreadId = threadData.ClientSideCallContextId;
            this.isLongLivedRequest = threadData.IsLongLivedRequest;
        }

        protected DebuggerEvent(string threadId) {
            ThreadData threadData = Debugger.GetThreadData(threadId);
            if (threadData == null) {
                this.threadId = threadId;
            } else {
                Init(threadData);
            }
        }

        private string GetTypeName() {
            string name = this.GetType().Name;
            int lastDotPos = name.LastIndexOf(".");
            if (lastDotPos != -1)
                name = name.Substring(lastDotPos + 1);
            return name;
        }

        public string ToXml(long eventId, bool inPTA, DebugSession debugSession) {
            using (StringWriter result = new StringWriter()) {
                using (XmlWriter writer = XmlWriter.Create(result)) {

                    writer.WriteStartElement(GetTypeName());
                    writer.WriteAttributeString("eventId", eventId.ToString());
                    writer.WriteAttributeString("inPTA", inPTA.ToString());

                    // write username. For backward compatibility with the debugger tests, only send the username
                    // if the session is from a different user
                    if (!userName.IsEmpty()) {
                        if (debugSession == null || debugSession.UserName != userName) {
                            writer.WriteAttributeString("userName", userName);
                        }
                    }

                    InnerToXml(writer);
                    writer.WriteEndElement();
                }
                return result.ToString();
            }
        }

        protected virtual void InnerToXml(XmlWriter writer) {
            foreach (FieldInfo field in this.GetType().GetFields(BindingFlags.Instance | BindingFlags.NonPublic).OrderBy(f => f.Name)) {
                if (!field.GetCustomAttributes(typeof(NonSerializedAttribute), /*inherit*/true).IsEmpty()) {
                    continue;
                }

                object val = field.GetValue(this);
                string strVal;
                if (val != null) {
                    if (val is IDebuggerSerializable) {
                        strVal = ((IDebuggerSerializable)val).SerializationString;
                    } else {
                        strVal = val.ToString();
                    }

                    if (strVal != null) {
                        writer.WriteAttributeString(field.Name, strVal);
                    }
                }
            }

        }
    }

    [DoNotObfuscateType]
    public abstract class EventWithStack : DebuggerEvent {
        protected StackManager stack;

        public StackManager Stack {
            get {
                return stack;
            }
        }

        public EventWithStack(ThreadData threadData, StackManager stack)
            : base(threadData) {
            this.stack = stack;
        }

        protected override void InnerToXml(XmlWriter writer) {
            // add stack as a child
            base.InnerToXml(writer);
            if (stack != null && !stack.IsEmpty) {
                stack.Save(writer);
            }
        }
    }

    /// <summary>
    /// This event is generated whenever a breakpoint is reached. This event has
    /// the following data:
    /// 
    /// - breakpointId: id of the breakpointable object where the thread has been
    ///   suspended.
    /// - stack: thread's stack at the moment it was suspended. The stack includes
    ///   only breakpoint ids, not the local state (which must be obtained via
    ///   the debugger's Evaluate method)
    /// </summary>
    [DoNotObfuscateType]
    public class AtBreakpointEvent : EventWithStack {
        protected string breakpointType;
        protected string extraInfo;

        public AtBreakpointEvent(ThreadData threadData)
            : base(threadData, threadData.Stack) {

            BreakpointType bt = threadData.Stack.Top.CurrentBreakpointType;
            if (bt != BreakpointType.Normal)
                this.breakpointType = bt.ToString();
            this.extraInfo = threadData.Stack.Top.CurrentBreakpointExtraInfo;
        }
    }

    /// <summary>
    /// This event is generated when an exception is thrown
    /// </summary>
    [DoNotObfuscateType]
    public class ExceptionThrownEvent : EventWithStack {
        protected string message;

        public ExceptionThrownEvent(ExceptionData data)
            : base(data.Thread, data.Stack) {

            this.message = data.Exception.Message;
            this.threadName = data.Thread.ThreadName;
        }
    }

    /// <summary>
    /// When a request gets suspended in a debug session, this event is sent to all of the
    /// other debug sessions so that the users are aware of concurrent debug activity.
    /// </summary>
    [DoNotObfuscateType]
    public class ConcurrentAtBreakpointEvent : EventWithStack {

        public ConcurrentAtBreakpointEvent(ThreadData threadData, DebugSession session)
            : base(threadData, threadData.LastExceptionThrown == null ? threadData.Stack : threadData.LastExceptionThrown.Stack) {
            userName = session.UserName;
        }
    }

    /// <summary>
    /// This event is generated whenever a thread exits from its suspended state.
    /// It is used by Service Studio to update the thread's state and debugger
    /// buttons status.
    /// </summary>
    [DoNotObfuscateType]
    public class ContinueEvent : DebuggerEvent {

        public ContinueEvent(ThreadData threadData)
            : base(threadData) {
        }
    }

    /// <summary>
    /// This event is generated whenever a thread receives a request to be suspended
    /// but before it reaches a breakpoint.
    /// </summary>
    [DoNotObfuscateType]
    public class BeforeSuspendEvent : DebuggerEvent {

        public BeforeSuspendEvent(ThreadData threadData)
            : base(threadData) {
        }
    }

    /// <summary>
    /// This is event is generated when a thread ends. It is used by Service Studio
    /// to remove the thread from the threads list.
    /// </summary>
    [DoNotObfuscateType]
    public class ThreadEndEvent : DebuggerEvent {

        protected BreakpointId lastBreakpoint;
        protected DebugCommandType lastCommand;

        public ThreadEndEvent(string threadId, DebugSession affinedSession)
            : base(threadId) {

            ThreadData thread = Debugger.GetThreadData(threadId);
            if (thread != null) {
                if (thread.LastDebugCommand != null) {
                    if (thread.LastDebugCommand.Stack.Top != null) {
                        this.lastBreakpoint = thread.LastDebugCommand.Stack.Top.CurrentBreakpointId;
                    }
                    this.lastCommand = thread.LastDebugCommand.Command;
                }
            }
            this.userName = affinedSession == null ? null : affinedSession.UserName;
        }
    }

    /// <summary>
    /// This is event is generated when a thread is handled by an user and sent to all
    /// other connected users. It is used by Service Studio to remove the thread from the threads list.
    /// </summary>
    [DoNotObfuscateType]
    public class ThreadHandledByAnotherUserEvent : DebuggerEvent {

        public ThreadHandledByAnotherUserEvent(ThreadData threadData)
            : base(threadData) {
        }
    }

    /// <summary>
    /// This event is generated whenever the list of logged in users changes. It is used by Service Studio
    /// to update the list of concurrent debug sessions
    /// </summary>
    [DoNotObfuscateType]
    public class LoggedInUsersChangedEvent : DebuggerEvent {
        string loggedInUsers;

        public LoggedInUsersChangedEvent(IEnumerable<string> loggedInUsers) {
            this.loggedInUsers = loggedInUsers.StrCat(",");
        }
    }

    /// <summary>
    /// This event is not specific to a given thread. It is used to signal that 
    /// the debug session has been stopped by Service Studio. It is used to notify
    /// all attached Service Studios that they must update their UI in order to
    /// show that the session is closed.
    /// </summary>
    [DoNotObfuscateType]
    public class StopDebugSessionEvent : DebuggerEvent {
        string msgId;

        public StopDebugSessionEvent() {
        }

        public StopDebugSessionEvent(string msgId) {
            this.msgId = msgId;
        }
    }

    /// <summary>
    /// This event is sent when the debug session is being stopped by the server
    /// because the app is being redeployed. SS will then try to reconnect.
    /// </summary>
    [DoNotObfuscateType]
    public class ApplicationIsBeingRedeployedEvent : DebuggerEvent {

        bool hasSuspendedThreads;
        bool fromRedeployEvent;

        public ApplicationIsBeingRedeployedEvent(bool fromRedeployEvent) {
            this.fromRedeployEvent = fromRedeployEvent;
        }

        public ApplicationIsBeingRedeployedEvent(DebugSession debugSession, bool fromRedeployEvent) {
            hasSuspendedThreads = Debugger.HasSuspendedThreads(debugSession.Token);
            this.fromRedeployEvent = fromRedeployEvent;
        }
    }

    /// <summary>
    /// This event is sent when the debug session is has been successfully started.
    /// </summary>
    [DoNotObfuscateType]
    public class DebugSessionStartedEvent : DebuggerEvent {

        protected string eSpaceHash;
        protected int eSpaceVersionId;

        public DebugSessionStartedEvent() {
            this.eSpaceHash = RunningInfo.ESpaceHash;
            this.eSpaceVersionId = RunningInfo.ESpaceVersionId;
        }
    }
    #endregion

    /// <summary>
    /// This class is used to collect data about a suspended thread. It provides
    /// methods to command the thread and also to obtain data about it.
    /// </summary>
    public class ThreadData {

        /// <summary>
        /// This class is used to store info on a request that must be available for
        /// long-lived requests. E.g., when debugging a process we're actually running
        /// in different requests over time, but we want it to work as if it was a single
        /// request, namely wrt the StepOver/Out/etc behavior.
        /// 
        /// Note that the data here is not specific to long-lived requests - for regular
        /// requests we also need this data, but the difference is that we won't store
        /// it to reuse for later requests
        /// </summary>
        class LongLivedRequestData {

            private readonly bool isLongLived;
            private readonly string requestId;
            private static int nextRequestId = 0;
            private DateTime lastAccessTime = DateTime.Now;
            private bool hasSuccessor;
            private static Thread cleanupThread;

            // used for request affinity
            private string debugSessionToken;

            // true if the thread was ever suspended during the current request. This is
            // used to decide if we should send a ThreadEndEvent when the request ends
            // (we only send it for threads that have been suspended, since Service Studio
            // never knows - or cares - about the other threads)
            private bool threadWasSuspended;

            // target of the "Run to" command
            private BreakpointId runToBreakpoint;

            // last command received by the thread. This is used to determine the
            // thread's behaviour when a breakpointable object is reached. E.g., if the
            // last command was StepInto, then we'll suspend the thread at the next
            // breakpointable object, even if no breakpoint is defined there.
            private DebugCommand lastDebugCommand = null;

            // used when executions comes from client debugger and we want to stop immediately
            private bool stopImmediately = false;

            // this flag is used to decide if we should generate the
            // ContinueEvent when we reach a new potential breakpoint
            // after the thread has been continued
            private bool generateContinueEventOnNextBreakpoint;

            // persisted data. Data is indexed by process id, and then by activity id.
            private static Dictionary<int, Dictionary<int, LongLivedRequestData>> persistedData = new Dictionary<int, Dictionary<int, LongLivedRequestData>>();

            // copy of the Debugger's process info structure. We create a copy because by the time the ThreadEnd event
            // is called the original process info may have already been cleaned up
            private ProcessInfo processInfo;
            public ProcessInfo ProcessInfo {
                get { return processInfo; }
            }

            public bool IsLongLivedRequest {
                get { return isLongLived; }
            }

            public string RequestId {
                get { return requestId; }
            }

            public BreakpointId RunToBreakpoint {
                get { return runToBreakpoint; }
                set { runToBreakpoint = value; }
            }

            public bool ThreadWasSuspended {
                get { return threadWasSuspended; }
                set { threadWasSuspended = value; }
            }

            public DebugCommand LastDebugCommand {
                get { return lastDebugCommand; }
                set { lastDebugCommand = value; }
            }

            public bool StopImmediately {
                get { return stopImmediately; }
                set { stopImmediately = value; }
            }

            public bool GenerateContinueEventOnNextBreakpoint {
                get { return generateContinueEventOnNextBreakpoint; }
                set { generateContinueEventOnNextBreakpoint = value; }
            }

            public string DebugSessionToken {
                get { return debugSessionToken; }
                set { debugSessionToken = value; }
            }

            private static string GetNewRequestId() {
                return "R" + (nextRequestId++);
            }

            private LongLivedRequestData(bool isLongLived, string requestId) {
                this.isLongLived = isLongLived;
                this.requestId = requestId;
            }

            public static LongLivedRequestData Get(ThreadData threadData, LongLivedRequestData previousDataForThisThread) {
                LongLivedRequestData result = InnerGet(threadData);
                result.processInfo = Debugger.ProcessInfo;
                result.lastAccessTime = DateTime.Now;

                if (previousDataForThisThread != null) {
                    result.ThreadWasSuspended |= previousDataForThisThread.ThreadWasSuspended;
                }

                return result;
            }

            private static LongLivedRequestData InnerGet(ThreadData threadData) {
                if (!Debugger.IsLongLivedRequest) {
                    return new LongLivedRequestData(/*isLongLived*/false, /*requestId*/null);
                }

                lock (persistedData) {
                    // quick check
                    if (persistedData.IsEmpty()) {
                        return new LongLivedRequestData(/*isLongLived*/true, GetNewRequestId());
                    }

                    // try to get stored data
                    LongLivedRequestData result = null;
                    Dictionary<int, LongLivedRequestData> dataForProcess;
                    if (persistedData.TryGetValue(Debugger.ProcessInfo.TopProcessId, out dataForProcess)) {

                        // found data for the process. Now check if there's data for this activity...
                        if (dataForProcess.TryGetValue(Debugger.ProcessInfo.ActivityId, out result)) {
                            return result;
                        }

                        // ... or its precedent activity
                        if (dataForProcess.TryGetValue(Debugger.ProcessInfo.PrecedentActivityId, out result)) {

                            // if there's a single successor, reuse the data
                            if (Debugger.ProcessInfo.PrecedentActivitySuccessorsCount <= 1) {
                                return result;
                            }

                            // The process will branch, so we need to keep the previous data - the successor
                            // activities will be created in sequence, and all of them need to reuse the
                            // data from the precedent activities.
                            // We'll keep the request id only for the 1st successor
                            string requestId;
                            if (result.hasSuccessor) {
                                requestId = GetNewRequestId();
                            } else {
                                requestId = result.requestId;
                                result.hasSuccessor = true;
                            }

                            return result.Duplicate(requestId);
                        }
                    }

                    return new LongLivedRequestData(/*isLongLived*/true, GetNewRequestId());
                }
            }

            public void Store() {
                if (isLongLived) {

                    // only store if the thread was suspended
                    if (ThreadWasSuspended) {
                        lock (persistedData) {

                            Dictionary<int, LongLivedRequestData> dataForProcess;
                            if (!persistedData.TryGetValue(processInfo.TopProcessId, out dataForProcess)) {
                                dataForProcess = new Dictionary<int, LongLivedRequestData>();
                                persistedData[processInfo.TopProcessId] = dataForProcess;
                            }

                            dataForProcess[processInfo.ActivityId] = this;
                        }

                        if (cleanupThread == null) {
                            Thread t = new Thread(CleanupThreadMethod);
                            t.IsBackground = true;
                            t.Start();
                            cleanupThread = t;
                        }
                    }
                }
            }

            public void RemoveUnneededData() {
                if (isLongLived) {
                    if (LastDebugCommand != null) {
                        LastDebugCommand.RemoveUnneededData();
                    }
                }
            }

            private LongLivedRequestData Duplicate(string newRequestId) {
                LongLivedRequestData result = new LongLivedRequestData(isLongLived, newRequestId);

                // copy data
                result.GenerateContinueEventOnNextBreakpoint = this.GenerateContinueEventOnNextBreakpoint;
                if (this.LastDebugCommand != null) {
                    result.LastDebugCommand = this.LastDebugCommand.CloneCommand();
                }
                result.RunToBreakpoint = this.RunToBreakpoint;
                result.ThreadWasSuspended = this.ThreadWasSuspended;
                result.DebugSessionToken = this.DebugSessionToken;

                return result;
            }

            // remove data for requests that have expired
            static void CleanupThreadMethod() {
                RuntimePlatformUtils.SetupCurrentThreadCulture();
                while (true) {
                    int minExpirationTimeInSecs = Debugger.REQUEST_TIMEOUT_IN_SECONDS;

                    lock (persistedData) {
                        DateTime currTime = DateTime.Now;
                        List<int> processDataToRemove = new List<int>();

                        foreach (var processDataAux in persistedData) {
                            var processData = processDataAux;
                            List<int> activityDataToRemove = new List<int>();

                            foreach (var data in processData.Value) {
                                int inactiveTime = (int)(currTime - data.Value.lastAccessTime).TotalSeconds;
                                if (inactiveTime >= Debugger.REQUEST_TIMEOUT_IN_SECONDS) {
                                    activityDataToRemove.Add(data.Key);
                                } else {
                                    int remainingTime = Debugger.REQUEST_TIMEOUT_IN_SECONDS - inactiveTime;
                                    if (remainingTime < minExpirationTimeInSecs) {
                                        minExpirationTimeInSecs = remainingTime;
                                    }
                                }
                            }

                            activityDataToRemove.Apply(k => processData.Value.Remove(k));
                            if (processData.Value.IsEmpty()) {
                                processDataToRemove.Add(processData.Key);
                            }
                        }

                        processDataToRemove.Apply(k => persistedData.Remove(k));
                    }

                    // sleep at least for 1min
                    if (minExpirationTimeInSecs < 60) {
                        minExpirationTimeInSecs = 60;
                    }
                    Thread.Sleep(minExpirationTimeInSecs * 1000);
                }
            }

            public static void Save(XmlWriter writer, string elementName) {

                writer.WriteStartElement(elementName);
                writer.WriteAttributeString("nextRequestId", nextRequestId.ToString());

                foreach (var p in persistedData) {
                    int processId = p.Key;
                    Dictionary<int, LongLivedRequestData> processData = p.Value;
                    if (processData.IsEmpty()) {
                        continue;
                    }

                    writer.WriteStartElement("Process");
                    writer.WriteAttributeString("processId", processId.ToString());

                    foreach (var p2 in processData) {
                        int activityId = p2.Key;
                        LongLivedRequestData data = p2.Value;

                        writer.WriteStartElement("Activity");

                        writer.WriteAttributeString("activityId", activityId.ToString());

                        writer.WriteAttributeString("requestId", data.requestId);
                        writer.WriteAttributeString("generateContinueEventOnNextBreakpoint", data.GenerateContinueEventOnNextBreakpoint.ToString());
                        writer.WriteAttributeString("hasSuccessor", data.hasSuccessor.ToString());
                        writer.WriteAttributeString("threadWasSuspended", data.ThreadWasSuspended.ToString());
                        writer.WriteAttributeString("debugSessionToken", data.DebugSessionToken);
                        writer.WriteAttributeString("lastAccessTime", data.lastAccessTime.Ticks.ToString());
                        if (data.RunToBreakpoint != null) {
                            writer.WriteAttributeString("runToBreakpoint", data.RunToBreakpoint.ToString());
                        }

                        if (data.LastDebugCommand != null) {
                            data.LastDebugCommand.Save(writer, "LastDebugCommand");
                        }

                        writer.WriteEndElement();
                    }

                    writer.WriteEndElement();
                }

                writer.WriteEndElement();
            }

            public static void Load(XmlElement root) {
                nextRequestId = Convert.ToInt32(root.GetAttribute("nextRequestId"));

                foreach (XmlElement process in root.SelectNodes("Process")) {
                    int processId = Convert.ToInt32(process.GetAttribute("processId"));
                    DebuggerTrace.Log("Loading process data for process " + processId);
                    var processData = new Dictionary<int, LongLivedRequestData>();
                    persistedData.Add(processId, processData);

                    foreach (XmlElement activity in process.SelectNodes("Activity")) {
                        int activityId = Convert.ToInt32(activity.GetAttribute("activityId"));
                        string requestId = activity.GetAttribute("requestId");

                        LongLivedRequestData data = new LongLivedRequestData(/*isLongLived*/true, requestId);
                        processData.Add(activityId, data);

                        data.GenerateContinueEventOnNextBreakpoint = Convert.ToBoolean(activity.GetAttribute("generateContinueEventOnNextBreakpoint"));
                        data.hasSuccessor = Convert.ToBoolean(activity.GetAttribute("hasSuccessor"));
                        data.ThreadWasSuspended = Convert.ToBoolean(activity.GetAttribute("threadWasSuspended"));
                        data.DebugSessionToken = activity.GetAttribute("debugSessionToken");
                        data.lastAccessTime = new DateTime(Convert.ToInt64(activity.GetAttribute("lastAccessTime")));
                        XmlElement lastCommandElement = (XmlElement)activity.SelectSingleNode("LastDebugCommand");
                        if (lastCommandElement != null) {
                            data.LastDebugCommand = DebugCommand.Load(lastCommandElement);
                        }

                        string runToBreakpoint = activity.GetAttribute("runToBreakpoint");
                        if (!runToBreakpoint.IsEmpty()) {
                            BreakpointId breakpointId = null;
                            if (BreakpointId.TryParse(runToBreakpoint, out breakpointId)) {
                                data.RunToBreakpoint = breakpointId;
                            }
                        }
                    }
                }
            }
        }

        private string threadId;
        private string threadName;

        // the maximum time (in ms) that a suspended thread waits for a 
        // continue/step command before aborting
        private const int MAX_SUSPEND_TIMEOUT = 30 * 60 * 1000;

        // the time (is ms) that a suspended thread waits before
        // checking if the debug session is still active
        private const int CHECK_DEBUG_SESSION_TIMEOUT = 5 * 1000;

        // the thread's command queue. This queue is used to send commands to 
        // a suspended thread
        private Queue<DebugCommandType> commandsQueue = new Queue<DebugCommandType>();

        // the thread's stack
        private StackManager stackManager;

        private bool isSuspended;
        public bool IsSuspended {
            get { return isSuspended; }
        }

        // last exception throw by this thread
        private ExceptionData lastExceptionThrown;

        private LongLivedRequestData _longLivedRequestData;
        private LongLivedRequestData longLivedRequestData {
            get {
                Debugger.LoadDebugSessionData();

                // if the process info changed we need to create/get a new object
                if (_longLivedRequestData != null) {
                    if (this.threadId == Debugger.ThreadId && !Debugger.ProcessInfo.Equals(_longLivedRequestData.ProcessInfo)) {
                        _longLivedRequestData.Store();
                        _longLivedRequestData.RemoveUnneededData();
                        _longLivedRequestData = LongLivedRequestData.Get(this, _longLivedRequestData);
                    }
                } else {
                    _longLivedRequestData = LongLivedRequestData.Get(this, null);
                }
                return _longLivedRequestData;
            }
        }

        public ThreadData(string threadId) {
            this.threadId = threadId;
            this.stackManager = new StackManager();
        }

        public string ThreadId {
            get { return threadId; }
        }

        public bool Discarded { get; set; }

        public string RequestId {
            get { return longLivedRequestData.RequestId ?? threadId; }
        }

        public string ThreadName {
            get { return threadName; }
            set { threadName = value; }
        }

        public bool IsLongLivedRequest {
            get { return longLivedRequestData.IsLongLivedRequest; }
        }

        public StackManager Stack {
            get { return stackManager; }
        }

        public DebugCommand LastDebugCommand {
            get { return longLivedRequestData.LastDebugCommand; }
            set { longLivedRequestData.LastDebugCommand = value; }
        }

        public BreakpointId RunToBreakpoint {
            get { return longLivedRequestData.RunToBreakpoint; }
            set { longLivedRequestData.RunToBreakpoint = value; }
        }

        public bool StopImmediately {
            get { return longLivedRequestData.StopImmediately; }
            set { longLivedRequestData.StopImmediately = value; }
        }

        private bool GenerateContinueEventOnNextBreakpoint {
            get { return longLivedRequestData.GenerateContinueEventOnNextBreakpoint; }
            set { longLivedRequestData.GenerateContinueEventOnNextBreakpoint = value; }
        }

        public bool WasSuspended {
            get { return longLivedRequestData.ThreadWasSuspended; }
            private set { longLivedRequestData.ThreadWasSuspended = value; }
        }

        internal ExceptionData LastExceptionThrown {
            get { return lastExceptionThrown; }
            set { lastExceptionThrown = value; }
        }

        public string DebugSessionToken {
            get { return longLivedRequestData.DebugSessionToken; }
            private set { longLivedRequestData.DebugSessionToken = value; }
        }

        /// <summary>
        /// Token sent by client (browser) to identify this request
        /// </summary>
        public string ClientRequestToken {
            get;
            set;
        }

        /// <summary>
        /// CallContextId used to identify the client thread associated
        /// </summary>
        public int ClientSideCallContextId {
            get;
            set;
        }

        public DebugSession DebugSession {
            get { return DebugSessionToken.IsEmpty() ? null : Debugger.DebugSessions.GetByToken(DebugSessionToken); }
        }

        public void Evaluate(XmlElement var) {
            try {
                if (lastExceptionThrown != null) {
                    lastExceptionThrown.Stack.Evaluate(var);
                } else {
                    this.Stack.Evaluate(var);
                }
            } catch (Exception e) {
                DebuggerTrace.Log(e);
                var.InnerText = e.Message;
            }
        }

        // Sends the Stop command to the suspended thread
        public void Stop() {
            if (isSuspended)
                SendCommand(DebugCommandType.Stop);
        }

        // Sends the StepInto command to the suspended thread
        public void StepInto() {
            if (isSuspended)
                SendCommand(DebugCommandType.StepInto);
        }

        // Sends the StepOver command to the suspended thread
        public void StepOver() {
            if (isSuspended)
                SendCommand(DebugCommandType.StepOver);
        }

        // Sends the StepOut command to the suspended thread
        public void StepOut() {
            if (isSuspended)
                SendCommand(DebugCommandType.StepOut);
        }

        // Sends the Continue command to the suspended thread
        public void ContinueThread() {
            if (isSuspended)
                SendCommand(DebugCommandType.ContinueThread);
        }

        public void Suspend() {
            this.LastDebugCommand = new DebugCommand(DebugCommandType.Suspend, this);
        }

        // Sends a command to the suspended thread
        private void SendCommand(DebugCommandType commandType) {
            lock (commandsQueue) {
                commandsQueue.Enqueue(commandType);
                Monitor.Pulse(commandsQueue);
            }
        }

        // Sends a AtBreakpointEvent and then blocks the thread until it receives a command.
        // The thread is not suspended forever - if the maximum time elapses, then the
        // current request is aborted.
        public void SendBreakpointEventAndWaitForCommand(IEnumerable<DebugSession> sessions, EventWithStack breakpointEvent) {
            SendBreakpointEventAndWaitForCommand(sessions, breakpointEvent, /*functionLeft*/null, /*returnValue*/null);
        }

        public void SendBreakpointEventAndWaitForCommand(IEnumerable<DebugSession> sessions, EventWithStack breakpointEvent, string functionLeft, Object returnValue) {
            // if there are no sessions to which this breakpoint applies, just return
            if (sessions == null || sessions.IsEmpty()) {
                return;
            }

            LocalState state = this.Stack.Top;
            if (state != null) {
                // store return value
                state.StoreReturnValue(functionLeft, returnValue);

                // reset breakpoint count
                state.VisitedBreakpoints = 0;
            }

            lock (commandsQueue) {
                // set thread affinity now if sending the event to only one thread
                if (sessions.IsSingle()) {
                    DebugSession session = sessions.Single();
                    SetAffinity(session, /*notifyOtherUsers*/false);
                }

                // Load the session now, otherwise the evaluate requests that we
                // receive in the other thread (the one for the SS web service requests)
                // will load the wrong data.
                stackManager.ForceSessionIDLoad();

                // send debug event
                WasSuspended = true;
                isSuspended = true;
                Debugger.DebugSessions.Enqueue(breakpointEvent, sessions);

                // notify concurrent users (only if in public area)
                if (Debugger.IsInPublicArea && Debugger.DebugSessions.Count > 1) {
                    foreach (DebugSession session in sessions) {
                        IEnumerable<DebugSession> otherSessions = Debugger.DebugSessions.GetRemainingSessions(session);
                        ConcurrentAtBreakpointEvent concurrentEvent = new ConcurrentAtBreakpointEvent(this, session);

                        Debugger.DebugSessions.Enqueue(concurrentEvent, otherSessions);
                    }
                }

                // wait for a command for the thread. We'll wait a maximum time of
                // MAX_SUSPEND_TIMEOUT, but check regularly to see if the debug session
                // is still active
                long totalTime = 0;
                while (commandsQueue.Count == 0) {
                    Monitor.Wait(commandsQueue, CHECK_DEBUG_SESSION_TIMEOUT);
                    if (commandsQueue.Count == 0) {
                        if (!Debugger.HasConnectedClients(this.DebugSessionToken)) {
                            // if there are no connected clients, stop the debug sesion
                            // and continue the thread
                            Debugger.Stop(this.DebugSessionToken);
                            return;
                        }

                        totalTime += CHECK_DEBUG_SESSION_TIMEOUT;
                        if (totalTime >= MAX_SUSPEND_TIMEOUT) {
                            Debugger.SendThreadEndEventAndRemoveThread(threadId, DebugSession);
                            throw new DebuggerException("Waited too long for debug command");
                        }
                    }
                }

                isSuspended = false;

                this.LastDebugCommand = new DebugCommand(commandsQueue.Dequeue(), this);
                longLivedRequestData.Store();

                DebuggerTrace.Log("Received command " + this.LastDebugCommand);

                if (this.LastDebugCommand.Command == DebugCommandType.Stop) {
                    Debugger.SendThreadEndEventAndRemoveThread(threadId, DebugSession);
                    throw new DebuggerException("Thread has been stopped");
                }

                this.GenerateContinueEventOnNextBreakpoint = true;

                Debugger.SaveDebugSessionsData();
            }
        }

        public void OnThreadEnded() {
            if (_longLivedRequestData != null) {
                _longLivedRequestData.RemoveUnneededData();
            }
        }

        public void SendContinueEvent() {
            if (this.GenerateContinueEventOnNextBreakpoint) {
                this.GenerateContinueEventOnNextBreakpoint = false;
                Debugger.DebugSessions.Enqueue(new ContinueEvent(this), this.DebugSessionToken);
            }
        }

        public void SetAffinity(DebugSession debugSession) {
            SetAffinity(debugSession, /*notifyOtherUsers*/true);
        }

        public void SetAffinity(DebugSession debugSession, bool notifyOtherUsers) {
            if (this.DebugSessionToken == null) {
                this.DebugSessionToken = debugSession.Token;

                if (notifyOtherUsers) {
                    Debugger.DebugSessions.EnqueueHandledByAnotherUserEvent(new ThreadHandledByAnotherUserEvent(this), debugSession.Token);
                }
            }
        }

        public static void Save(XmlWriter writer) {
            LongLivedRequestData.Save(writer, "ThreadData");
        }

        public static void Load(XmlElement elem) {
            LongLivedRequestData.Load((XmlElement)elem.SelectSingleNode("ThreadData"));
        }
    }

    public class ExceptionData {
        public ThreadData Thread;
        public Exception Exception;
        public StackManager Stack;
        public BreakpointId BreakpointId;
        public BreakpointId PreviousBreakpointId;

        public ExceptionData(Exception e, ThreadData thread) {
            this.Thread = thread;
            this.Exception = e;
            this.Stack = thread.Stack.CloneStack();
            this.BreakpointId = Stack.Top.CurrentBreakpointId;
            this.PreviousBreakpointId = Stack.Top.PreviousBreakpointId;
        }
    }

    /// <summary>
    /// This class is used to keep track of the call stack of a given thread.
    /// </summary>
    public class StackManager : IDebuggerSerializable {
        private SessionInfo sessionInfo;

        private List<LocalState> callStack = new List<LocalState>();

        string IDebuggerSerializable.SerializationString { get { return null; } }

        public StackManager() {
            sessionInfo = AppInfo.GetAppInfo().OsContext.Session;
        }

        public void UpdateSession() {
            sessionInfo = AppInfo.GetAppInfo().OsContext.Session;
        }

        public int CurrentTenantId {
            get { return sessionInfo.TenantId; }
        }

        public void ForceSessionIDLoad() {
            sessionInfo.ForceSessionIDLoad();
        }

        public StackManager CloneStack() {
            StackManager newStackMngr = new StackManager();
            newStackMngr.callStack = new List<LocalState>(callStack);
            newStackMngr.sessionInfo = sessionInfo;
            return newStackMngr;
        }

        public LocalState Push(string eSpaceName, string functionId, string functionName, string functionType, object page, params IVarsBag[] list) {
            LocalState state = new LocalState(eSpaceName, functionId, functionName, functionType, page, list);
            callStack.Add(state);
            return state;
        }

        public void Push(LocalState state) {
            callStack.Add(state);
        }

        // Pops the stack up to (and including) stateToPop. 
        // If it is not found in the stack then leave it as is (this may happen when there are 
        // server transfers - in those cases we remove the current page from the call stack
        // to make it simpler to the user to interpret the call stack)
        public bool Pop(LocalState stateToPop) {
            if (callStack.Count != 0 && stateToPop != null) {
                int index = callStack.IndexOf(stateToPop);
                if (index != -1) {
                    int toRemove = callStack.Count - index;
                    for (int i = 0; i < toRemove; i++)
                        callStack.RemoveAt(callStack.Count - 1);
                    return true;
                }
            }
            return false;
        }

        public void PopAll() {
            callStack.Clear();
        }

        public int Depth {
            get {
                return callStack.Count;
            }
        }

        public LocalState Top {
            get {
                if (callStack.Count == 0)
                    return null;
                else
                    return callStack[callStack.Count - 1];
            }
        }

        public List<LocalState> Elements {
            get {
                return callStack;
            }
        }

        public bool Contains(LocalState state) {
            if (callStack.Count == 0)
                return false;

            if (callStack.IndexOf(state) != -1)
                return true;

            // because of the way screen actions are handled, the flow and screen may be
            // represented by different instances of LocalState over the same request.
            // Also, for processes usually we'll have several requests over time
            // instead of a single request.
            foreach (LocalState currState in callStack) {
                if (currState.FunctionId == state.FunctionId)
                    return true;
            }

            return false;
        }

        public object Evaluate(string varName, int stackLevel) {
            string varType;
            if (varName.StartsWith("Timers."))
                varType = "timer";
            else if (varName.StartsWith("Session."))
                varType = "session";
            else if (varName.StartsWith("Site."))
                varType = "site";
            else
                varType = "local";

            VarValue varValue = Evaluate(varName, varType, -1, stackLevel);
            return varValue.Value;
        }

        public void Evaluate(XmlElement var) {
            string varName = var.GetAttribute("name").Trim().Replace(":", ".");
            int detailLevel = 0;
            int stackLevel = -1;
            bool ignoreIfUnavailable = false;
            if (var.Attributes["detail"] != null) {
                detailLevel = Convert.ToInt32(var.GetAttribute("detail"));
            }
            if (var.Attributes["level"] != null) {
                stackLevel = Convert.ToInt32(var.GetAttribute("level"));
            }
            if (var.Attributes["ignoreIfUnavailable"] != null) {
                ignoreIfUnavailable = (var.GetAttribute("ignoreIfUnavailable").ToLower() == "true");
            }

            VarValue varValue = Evaluate(varName, var.Name, detailLevel, stackLevel);
            if (!varValue.Found && ignoreIfUnavailable) {
                var.ParentNode.RemoveChild(var);
            } else {
                varValue.Store(var, detailLevel);
            }
        }

        private VarValue Evaluate(string varName, string varType, int detailLevel, int stackLevel) {
            string baseVarName = varName;
            int sepPos;
            object val;
            VarValue varValue = new VarValue(this, stackLevel);

            switch (varType) {
                case "timer":
                    baseVarName = VarValue.GetHead(varName);
                    varValue.Value = Debugger.Timers[baseVarName];
                    break;

                case "session":
                    sepPos = varName.IndexOf(".");
                    sepPos = varName.IndexOf(".", sepPos + 1);
                    if (sepPos != -1)
                        baseVarName = varName.Substring(0, sepPos);
                    val = sessionInfo[baseVarName];
                    if (val == null)
                        val = sessionInfo[baseVarName.Substring(baseVarName.IndexOf(".") + 1)];
                    varValue.Value = val;
                    break;

                case "site":
                    sepPos = varName.IndexOf(".");
                    sepPos = varName.IndexOf(".", sepPos + 1);
                    if (sepPos != -1)
                        baseVarName = varName.Substring(0, sepPos);
                    var appInfo = AppInfo.GetAppInfo();

                    var sitePropertiesInfo = appInfo.Espace(appInfo.eSpaceId).EspaceSiteProperties;

                    val = sitePropertiesInfo.GetSafe(baseVarName);
                    if (val == null)
                        val = sitePropertiesInfo[baseVarName.Substring(baseVarName.IndexOf(".") + 1)];
                    varValue.Value = val;
                    break;

                case "local":
                    string widgetName = VarValue.GetHead(varName, /*normalizeCase*/false);
                    baseVarName = VarValue.GetHead(varName);
                    EvaluateLocalVariable(baseVarName, stackLevel, varValue);

                    // extra processing for widgets
                    object page = GetPage(stackLevel);
                    bool isWebScreen = (page is System.Web.UI.Control);

                    if (page != null) {
                        string controlId = null;
                        Object control = null;
                        if (isWebScreen) {
                            controlId = GetControlId(page, widgetName, out control);
                        }
                        if (controlId != null) {
                            if (!varValue.Found) {
                                varValue.Value = new UnknownWidgetRtWidget(controlId);
                            }
                            if (varValue.Value is IRtWidget) {
                                IRtWidget widget = (IRtWidget)varValue.Value;
                                widget.Id = controlId;
                                widget.Control = control;
                                widget.Page = page;
                            }
                        }
                    }

                    break;
            }

            if (varValue.Found && baseVarName.Length != varName.Length && varValue.Value != null) {
                varValue.EvaluateFields(null, null, varName.Substring(baseVarName.Length));
            }
            return varValue;
        }

        private static string GetControlId(object page_, string widgetName, out Object control) {
            IScreen page = (IScreen)page_;
            control = page.FindControlByName(widgetName);
            return control == null ? null : ((System.Web.UI.Control)control).ClientID;
        }

        private void EvaluateLocalVariable(string baseVarName, int stackLevel, VarValue varValue) {
            if (stackLevel < callStack.Count) {
                LocalState state = callStack[stackLevel];
                if (state.HasVariable(baseVarName)) {
                    varValue.Value = state.GetVariable(baseVarName);
                }
            }
        }

        private object EvaluateLocalVariable(string baseVarName, int stackLevel) {
            if (stackLevel < callStack.Count) {
                LocalState state = callStack[stackLevel];
                if (state.HasVariable(baseVarName))
                    return state.GetVariable(baseVarName);
            }
            return null;
        }

        private object GetPage(int stackLevel) {
            if (stackLevel < callStack.Count) {
                LocalState state = callStack[stackLevel];
                return state.Page;
            }
            return null;
        }

        public bool IsEmpty {
            get { return callStack.IsEmpty(); }
        }

        public void Save(XmlWriter writer) {
            Save(writer, "Stack");
        }

        public void Save(XmlWriter writer, string elementName) {
            writer.WriteStartElement(elementName);

            for (int i = 0; i < callStack.Count; i++) {
                writer.WriteStartElement("StackElem");
                callStack[i].Save(writer);
            }

            for (int i = 0; i < callStack.Count; i++) {
                writer.WriteEndElement();
            }

            writer.WriteEndElement();
        }

        public static StackManager Load(XmlElement elem) {
            return new StackManager(elem);
        }

        private StackManager(XmlElement elem) {
            callStack = new List<LocalState>();
            sessionInfo = AppInfo.GetAppInfo().OsContext.Session;

            XmlElement currElem = (XmlElement)elem.SelectSingleNode("StackElem");
            while (currElem != null) {
                callStack.Add(LocalState.Load(currElem));
                currElem = (XmlElement)currElem.SelectSingleNode("StackElem");
            }
        }

        internal void RemoveUnneededData() {
            callStack.Apply(st => st.RemoveUnneededData());
        }
    }

    public class VarValue {
        private bool found;
        private bool optimized;
        private Object varValue;
        private Object parent;
        private StackManager stackMngr;
        private int stackLevel;

        static string toXmlMethod;
        static string evaluateFieldsMethod;

        static VarValue() {
            if (BuiltInFunction.GetApplicationServerType() == ".Net") {
                toXmlMethod = "ToXml";
                evaluateFieldsMethod = "EvaluateFields";
            } else {
                toXmlMethod = "toXml";
                evaluateFieldsMethod = "evaluateFields";
            }
        }

        public bool Found {
            get { return found; }
            set { found = value; }
        }

        public bool Optimized {
            set { optimized = value; }
        }

        private string fieldName;
        public void SetFieldName(string fieldName) {
            this.fieldName = fieldName;
        }

        public Object Value {
            get {
                return varValue;
            }
            set {
                if (!(parent is RecordList && varValue is IRecord)) {
                    parent = varValue;
                }
                // unwrap holders
                if (IsHolder(value)) {
                    varValue = GetHolderValue(value);
                } else {
                    varValue = value;
                }

                Found = true;
            }
        }

        public StackManager Stack {
            get { return stackMngr; }
        }

        public int StackLevel {
            get { return stackLevel; }
        }

        public VarValue(StackManager stackMngr, int stackLevel) {
            this.stackMngr = stackMngr;
            this.stackLevel = stackLevel;
        }

        private static int GetSeparatorPos(string fields) {
            if (fields[0] == '[') {
                // if we begin with "[" then we must find the matching closing "]"
                int count = 0;
                int sepPos;
                for (sepPos = 0; sepPos < fields.Length; sepPos++) {
                    if (fields[sepPos] == '[') {
                        count++;
                    } else if (fields[sepPos] == ']') {
                        count--;
                    }
                    if (count == 0) {
                        sepPos++;
                        if (sepPos < fields.Length) {
                            return sepPos;
                        } else {
                            return -1;
                        }
                    }
                }
                return -1;
            } else {
                // just search for the next '.' or '['
                int dotPos = fields.IndexOf(".");
                int bracketPos = fields.IndexOf("[", 1);
                if (dotPos == -1) {
                    return bracketPos;
                }
                if (bracketPos == -1) {
                    return dotPos;
                }
                if (dotPos < bracketPos) {
                    return dotPos;
                } else {
                    return bracketPos;
                }
            }
        }

        public static string GetHead(string fields) {
            return GetHead(fields, /*normalizeCase*/true);
        }

        public static string GetHead(string fields, bool normalizeCase) {
            int sepPos = GetSeparatorPos(fields);
            string result;
            if (sepPos == -1) {
                result = fields;
            } else {
                result = fields.Substring(0, sepPos);
            }

            if (normalizeCase) {
                result = result.ToLower();
            }

            return result;
        }

        public static string GetTail(string fields) {
            int sepPos = GetSeparatorPos(fields);
            if (sepPos == -1) {
                return null;
            } else if (fields[sepPos] == '.') {
                return fields.Substring(sepPos + 1);
            } else {
                return fields.Substring(sepPos);
            }
        }

        public void EvaluateFields(Object parent, string baseName, string fields) {
            try {
                if (Value == null || !Found) {
                    return;
                }
                Found = false;

                if (fields[0] == '.') {
                    fields = fields.Substring(1);
                }

                // is type an hashtable?
                CaseInsensitiveHashtable ht = varValue as CaseInsensitiveHashtable;
                if (ht != null) {
                    string head = GetHead(fields);
                    string tail = GetTail(fields);
                    if (ht.ContainsKey(head)) {
                        Value = ht[head];
                        if (tail != null) {
                            EvaluateFields(Value, null, tail);
                        }
                    }
                } else {
                    // check if the "val" object has a EvaluateFields in which we can
                    // delegate

                    Type type = varValue as Type ?? varValue.GetType();

                    MethodInfo evalFields = type.GetMethod(evaluateFieldsMethod);
                    if (evalFields != null) {
                        evalFields.Invoke(varValue, new Object[] { this, parent, baseName, fields });
                    }
                }
            } catch (Exception e) {
                DebuggerTrace.Log(e);
                Value = e.Message;
            }
        }

        public void InvokeEvaluateFields(Object parent, String baseName, String fields) {
            try {
                Type type = parent.GetType();
                MethodInfo evalFields = type.GetMethod(evaluateFieldsMethod);
                if (evalFields != null) {
                    evalFields.Invoke(parent, new Object[] { this, parent, baseName, fields });
                }
            } catch (Exception e) {
                DebuggerTrace.Log(e);
                Value = e.Message;
            }
        }

        private bool InvokeToXml(object val, XmlElement baseElem, string fieldName, int detailLevel) {
            return InvokeToXml(val, parent, baseElem, fieldName, detailLevel);
        }

        public static bool InvokeToXml(object val, Object parent, XmlElement baseElem, string fieldName, int detailLevel) {
            if (val == null) {
                return false;
            }

            MethodInfo toXml = val.GetType().GetMethod(toXmlMethod);
            if (toXml == null) {
                return false;
            }

            // use ToXml method to serialize the field's value
            try {
                toXml.Invoke(val, new object[] { parent, baseElem, fieldName, detailLevel });
            } catch (TargetInvocationException e) {
                DebuggerTrace.Log(e.InnerException);
                baseElem.InnerText = e.InnerException.Message;
            } catch (Exception e) {
                DebuggerTrace.Log(e);
                baseElem.InnerText = e.Message;
            }

            return true;
        }

        public void Store(XmlElement variable, int detailLevel) {
            if (Found) {
                Store(variable, varValue, detailLevel);
            } else {
                variable.InnerText = "-unavailable in current context-";
            }
        }

        private void Store(XmlElement variable, object val, int detailLevel) {
            if (val != null && val is CaseInsensitiveHashtable) {
                CaseInsensitiveHashtable ht = (CaseInsensitiveHashtable)val;

                if (detailLevel >= 0) {
                    // for now, hashtables only appear in the context of Execute Action results
                    XmlElement htElem = AppendChild(variable, "Execute.Action");
                    if (detailLevel >= 1) {
                        string firstKey = null;
                        foreach (string key in ht.Keys) {
                            object childVal = ht[key];
                            firstKey = key;
                            if (!InvokeToXml(childVal, htElem, key, detailLevel - 1)) {
                                AppendAttribute(htElem, key, childVal, detailLevel - 1);
                            }
                        }
                    } else {
                        AppendDeferredEvaluationElement(htElem);
                    }
                } else {
                    AppendDeferredEvaluationElement(variable);
                }
            }

            // try calling the ToXml method. If that fails, return the variable valueas a string
            else if (!InvokeToXml(val, variable, fieldName, detailLevel)) {
                bool wasTrimmed;
                variable.InnerText = ValToString(detailLevel, optimized, val, out wasTrimmed);
                if (wasTrimmed) {
                    AppendAttribute(variable, Constants.TrimmedAttribute, "Yes");
                }
            }
        }

        public static string ValToString(int detailLevel, bool optimized, object val) {
            bool wasTrimmed;
            return ValToString(detailLevel, optimized, val, TypeKind.None, out wasTrimmed);
        }

        public static string ValToString(int detailLevel, bool optimized, object val, out bool wasTrimmed) {
            return ValToString(detailLevel, optimized, val, TypeKind.None, out wasTrimmed);
        }

        public static string ValToString(int detailLevel, bool optimized, object val, TypeKind kind) {
            bool wasTrimmed;
            return ValToString(detailLevel, optimized, val, kind, out wasTrimmed);
        }

        public static string ValToString(int detailLevel, bool optimized, object val, TypeKind kind, out bool wasTrimmed) {
            wasTrimmed = false;

            if (optimized) {
                return "-optimized-";
            }

            if (val == null) {
                return "-undefined-";
            }

            string strVal = val as string;
            if (strVal != null) {
                strVal = "\"" + strVal.Replace("\"", "\"\"") + "\"";
                if (detailLevel <= 1) {
                    strVal = TrimString(strVal, out wasTrimmed);
                }
                return strVal;
            }

            if (val is DateTime) {
                if (kind == TypeKind.Time) {
                    return "#" + BuiltInFunction.TimeToText((DateTime)val) + "#";
                }
                if (kind == TypeKind.Date) {
                    return "#" + BuiltInFunction.DateToText((DateTime)val) + "#";
                }
                return "#" + BuiltInFunction.DateTimeToText((DateTime)val) + "#";
            }

            if (val is decimal) {
                return BuiltInFunction.DecimalToText((Decimal)val);
            }

            if (val is bool) {
                return ((bool)val) ? "true" : "false";
            }

            if (IsByteArray(val)) {
                byte[] data = (byte[])val;
                if (data.Length == 1) {
                    return "BinaryData (1 byte)";
                } else {
                    return "BinaryData (" + data.Length + " bytes)";
                }
            }

            return val.ToString();
        }

        private static bool IsByteArray(object val) {
            return val.GetType() == typeof(byte[]);
        }

        private static bool IsHolder(object val) {
            return false;
        }

        private static object GetHolderValue(object holder) {
            return null;
        }

        public static string TrimString(string val, out bool wasTrimmed) {
            wasTrimmed = false;

            if (val.Length > Constants.DEBUGGER_MAX_STRING_LENGTH + 4) {
                val = val.Substring(0, Constants.DEBUGGER_MAX_STRING_LENGTH) + "...\"";
                wasTrimmed = true;
            }
            return val;
        }

        #region Xml construction functions
        public static XmlElement AppendChild(XmlElement root, string name) {
            XmlElement newElem = root.OwnerDocument.CreateElement(name);
            root.AppendChild(newElem);
            return newElem;
        }

        public static XmlElement AppendChild(XmlElement root, string name, object val) {
            XmlElement newElem = root.OwnerDocument.CreateElement(name);
            root.AppendChild(newElem);
            if (val == null) {
                newElem.InnerText = "-undefined-";
            } else {
                newElem.InnerText = val.ToString();
            }
            return newElem;
        }

        public static XmlAttribute AppendOptimizedAttribute(XmlElement root, string name) {
            XmlAttribute attr = root.OwnerDocument.CreateAttribute(name);
            root.Attributes.Append(attr);
            bool wasTrimmed;
            attr.Value = ValToString(-1, true, null, out wasTrimmed);
            return attr;
        }

        public static XmlAttribute AppendAttribute(XmlElement root, string name, object val) {
            return AppendAttribute(root, name, val, TypeKind.None);
        }

        public static XmlAttribute AppendAttribute(XmlElement root, string name, object val, TypeKind kind) {
            return AppendAttribute(root, name, val, 1, kind);
        }

        public static XmlAttribute AppendAttribute(XmlElement root, string name, object val, int detailLevel) {
            return AppendAttribute(root, name, val, detailLevel, TypeKind.None);
        }

        public static XmlAttribute AppendAttribute(XmlElement root, string name, object val, int detailLevel, TypeKind kind) {
            XmlAttribute attr = root.OwnerDocument.CreateAttribute(name);
            root.Attributes.Append(attr);
            if (name.StartsWith("debug.")) {
                attr.Value = val.ToString();
            } else {
                bool wasTrimmed;
                attr.Value = ValToString(detailLevel, false, val, kind, out wasTrimmed);
                if (wasTrimmed) {
                    AppendAttribute(root, Constants.TrimmedAttribute + "." + name, "Yes");
                }
            }
            return attr;
        }

        public static XmlElement AppendAttributeAsChild(XmlElement root, string name, object val, int detailLevel) {
            // Some names are not valid in XML (namely [0]), so we need to encode an "attribute" as an element
            // so that we can provide both the name via "debug.field" and a value via "debug.value".

            // "local" is used because SS's VariableTypeExtensions.ToVarType is mapping it to a Scalar
            // TODO: refactor the enum to Common, to stop relying on name conventions
            var valueElem = VarValue.AppendChild(root, "local");
            VarValue.AppendAttribute(valueElem, "debug.field", name);

            bool wasTrimmed;
            var valueStr = VarValue.ValToString(detailLevel, false, val, out wasTrimmed);
            VarValue.AppendAttribute(valueElem, "debug.value", valueStr, detailLevel);
            if (wasTrimmed) {
                VarValue.AppendAttribute(valueElem, Constants.TrimmedAttribute, "Yes");
            }

            return valueElem;
        }

        public static XmlElement AppendDeferredEvaluationElement(XmlElement root) {
            return AppendChild(root, "DeferredEvaluation");
        }

        public static bool FieldIsOptimized(Object parent, string fieldInLowerCase) {
            RecordList parentRecList = parent as RecordList;
            if (parentRecList != null && parentRecList.OptimizedFields != null) {
                return parentRecList.OptimizedFields.IndexOf("," + fieldInLowerCase + ",") != -1;
            }
            return false;
        }
        #endregion
    }

    public interface IVarsBag {
        void EvaluateFields(VarValue variable, object parent, string baseName, string fields);

        object GetVariableValue(string varName);

        bool HasVariable(string varName);

        void ToXml(object parent, System.Xml.XmlElement baseElem, string fieldName, int detailLevel);

        string[] VarNames { get; }

        void SetNewOrigin(object origin);

        void InitVars(string[] varNames, string[] varRtNames);
    }

    public class VarsBag : IVarsBag {
        private string[] varNames;
        private string[] varRtNames;
        private object origin = null;

        public VarsBag() {
        }

        public string[] VarNames {
            get {
                return varNames;
            }
        }

        public void InitVars(string[] varNames, string[] varRtNames) {
            Init(varNames, varRtNames);
        }

        protected void Init(string[] varNames, string[] varRtNames) {
            if (varNames.Length == varRtNames.Length) {
                this.varNames = varNames;
                this.varRtNames = varRtNames;
                origin = this;
            }
        }

        private int GetVariableIndex(string varName) {
            if (varNames == null)
                return -1;

            varName = varName.ToLower();
            for (int i = 0; i < varNames.Length; i++) {
                if (varNames[i].ToLower() == varName)
                    return i;
            }
            return -1;
        }

        public bool HasVariable(string varName) {
            int varIndex = GetVariableIndex(varName);
            return varIndex != -1;
        }

        public object GetVariableValue(string varName) {
            // See if the cache already contains the field
            object targetObject;
            MemberInfo varField = GetVariableMember(GetVariableIndex(varName), out targetObject);

            if (varField == null) {
                return null;
            }

            return GetMemberValue(varField, targetObject);
        }

        protected object GetMemberValue(MemberInfo member, object targetObject) {
            if (member is FieldInfo) {
                return ((FieldInfo)member).GetValue(targetObject);
            } else if (member is PropertyInfo) {
                return ((PropertyInfo)member).GetValue(targetObject, null);
            } else {
                return null;
            }
        }

        private object GetVariableValue(int varIndex) {
            return GetVariableValue(varNames[varIndex]);
        }

        private MemberInfo GetVariableMember(int varIndex, out object targetObject) {
            if (varIndex != -1) {
                targetObject = origin;
                string[] varRtNameParts = varRtNames[varIndex].Split('.');
                MemberInfo result = null;

                for (int i = 0; i < varRtNameParts.Length; i++) {
                    result = GetVariablePartMember(targetObject, varRtNameParts[i]);

                    // If we are not at the last part, then the target object is the new member value
                    if (i < varRtNameParts.Length - 1) {
                        targetObject = GetMemberValue(result, targetObject);
                    }
                }

                return result;
            }

            targetObject = null;
            return null;
        }

        public virtual void ToXml(Object parent, XmlElement baseElem, String fieldName, int detailLevel) {
            if (detailLevel >= 0) {
                // for now, the only variables whose value is a VarsBag are the result of Execute Action results
                XmlElement bagElem = VarValue.AppendChild(baseElem, "Execute.Action");

                if (detailLevel >= 1) {	// Only dump the childreen if the detail level includes them
                    if (varNames != null) {
                        for (int i = 0; i < varNames.Length; i++) {
                            object childVal = GetVariableValue(i);
                            if (!VarValue.InvokeToXml(childVal, origin, bagElem, varNames[i], detailLevel - 1)) {
                                VarValue.AppendAttribute(bagElem, varNames[i], childVal, detailLevel - 1);
                            }
                        }
                    }
                } else {
                    VarValue.AppendDeferredEvaluationElement(bagElem);
                }
            } else {
                VarValue.AppendDeferredEvaluationElement(baseElem);
            }
        }

        public virtual void EvaluateFields(VarValue variable, Object parent, String baseName, String fields) {
            String head = VarValue.GetHead(fields);
            String tail = VarValue.GetTail(fields);
            variable.Found = false;
            if (HasVariable(head)) {
                variable.Value = GetVariableValue(head);
            }
            if (variable.Found && tail != null) {
                variable.EvaluateFields(origin, head, tail);
            }
        }

        public void SetNewOrigin(object origin) {
            this.origin = origin;
        }

        private static MemberInfo GetVariablePartMember(object targetObject, string variablePart) {
            BindingFlags flags = BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy | BindingFlags.Public;

            FieldInfo field = targetObject.GetType().GetField(variablePart, flags);
            if (field == null) {
                field = targetObject.GetType().BaseType.GetField(variablePart, flags);
            }
            if (field != null) {
                return field;
            }

            PropertyInfo property = targetObject.GetType().GetProperty(variablePart, flags);
            if (property == null) {
                property = targetObject.GetType().BaseType.GetProperty(variablePart, flags);
            }
            if (property != null)
                return property;

            throw new DebuggerException("Field '" + variablePart + "' does not exist");
        }
    }

    /// <summary>
    /// This class contains information about a given element in the thread's call
    /// stack. This info includes:
    /// 
    /// - eSpaceName: the name of the eSpace we're in. This is useful when debugging 
    ///   Producer/Consumer eSpaces, since different elements in the stack may correspond
    ///   to different eSpaces. It is used by Service Studio to provide feedback on
    ///   the breakpoints that are not in the currently open eSpace.
    ///   
    /// - functionId: id of the function we're in. This is a BreakpointId.
    /// 
    /// - functionName: name of the function. See comment on eSpaceName.
    /// 
    /// - breakpointId: id of the breakpointable object where the thread is suspended
    /// 
    /// - vars: value of the local variables by the time the thread was suspended. This
    ///   enables us to evaluate expressions.
    /// </summary>
    public class LocalState {
        private string eSpaceName;
        private BreakpointId functionId;
        private string functionType;
        private string functionName;
        private string phase;
        private Dictionary<string, CaseInsensitiveHashtable> vars = new Dictionary<string, CaseInsensitiveHashtable>(StringComparer.OrdinalIgnoreCase);
        private string functionLeft;
        private object returnValue;
        private List<IVarsBag> varsCollection;
        private object page;
        private Dictionary<string, object> extraVariables = new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase);

        // number of breakpoints visited since the last time the thread was suspended
        private int visitedBreakpoints;

        // last breakpoint the thread reached and the breakpoint before that
        // (this one will be used for the AutoVariables calculation)
        private BreakpointId currentBreakpointId;
        private string currentBreakpointExtraInfo;
        private BreakpointId previousBreakpointId;
        private BreakpointType currentBreakpointType;
        private BreakpointType previousBreakpointType;

        public LocalState(string eSpaceName, string functionIdStr, string functionName, string functionType, object page, params IVarsBag[] list) {
            this.eSpaceName = eSpaceName;
            BreakpointId breakpointId = null;
            if (BreakpointId.TryParse(functionIdStr, out breakpointId)) {
                this.functionId = breakpointId;
            }
            this.functionName = functionName;
            this.functionType = functionType;

            this.page = page;
            foreach (var param in list) {
                Add(param);
            }
            Add(page as IVarsBag); // shouldn't be necessary
        }

        private void Add(IVarsBag localVars) {
            if (localVars == null)
                return;
            if (varsCollection == null)
                varsCollection = new List<IVarsBag>();
            varsCollection.Add(localVars);
        }

        public string ESpaceName {
            get {
                return eSpaceName;
            }
        }

        public BreakpointId FunctionId {
            get {
                return functionId;
            }
        }

        public string FunctionType {
            get {
                return functionType;
            }
        }

        public string FunctionName {
            get {
                if (phase != null)
                    return phase + " " + functionName;
                else
                    return functionName;
            }
            set {
                functionName = value;
            }
        }

        public string Phase {
            get {
                return phase;
            }
            set {
                phase = value;
            }
        }

        public string FunctionLeft {
            get {
                return functionLeft;
            }
        }

        public BreakpointId CurrentBreakpointId {
            get {
                return currentBreakpointId;
            }
            set {
                if (currentBreakpointId != value) {
                    previousBreakpointId = currentBreakpointId;
                    currentBreakpointId = value;
                }
            }
        }

        public string CurrentBreakpointExtraInfo {
            get {
                return currentBreakpointExtraInfo;
            }
            set {
                currentBreakpointExtraInfo = value;
            }
        }

        public BreakpointType CurrentBreakpointType {
            get {
                return currentBreakpointType;
            }
            set {
                if (currentBreakpointType != value) {
                    previousBreakpointType = currentBreakpointType;
                    currentBreakpointType = value;
                }
            }
        }

        public BreakpointId PreviousBreakpointId {
            get {
                return previousBreakpointId;
            }
        }

        public BreakpointType PreviousBreakpointType {
            get {
                return previousBreakpointType;
            }
        }

        public int VisitedBreakpoints {
            get {
                return visitedBreakpoints;
            }
            set {
                visitedBreakpoints = value;
            }
        }

        public object Page {
            get {
                return page;
            }
        }

        public void AddExtraVariable(string name, object value) {
            extraVariables[name] = value;
        }

        private bool StoreWidgetField(object obj, string fieldName, object fieldValue) {
            if (obj == null) {
                return false;
            }

            if (obj is IListRecordRtWidget) {
                IListRecordRtWidget list = (IListRecordRtWidget)obj;
                if (fieldName.ToLower() == "list") {
                    list.List = (IOSList)fieldValue;
                }
                return true;
            } else if (obj is IRecordRtWidget) {
                IRecordRtWidget record = (IRecordRtWidget)obj;
                if (fieldName.ToLower() == "record") {
                    record.Record = fieldValue;
                }
                return true;
            } else if (obj is IListBoxRtWidget) {
                IListBoxRtWidget listBox = (IListBoxRtWidget)obj;
                if (fieldName.ToLower() == "list") {
                    listBox.List = (IOSList)fieldValue;
                }
                return true;
            } else if (obj is IRtCustomWidget) {
                IRtCustomWidget customWidget = (IRtCustomWidget)obj;
                customWidget.StoreRuntimeProperty(fieldName, fieldValue);
                return true;
            }

            return false;
        }

        private void ProcessStructuredVars() {
            if (varsCollection != null) {
                foreach (IVarsBag bag in varsCollection) {

                    for (int i = 0; i < bag.VarNames.Length; i++) {
                        try {
                            string varName = bag.VarNames[i];

                            string baseName = VarValue.GetHead(varName);
                            string fieldName = VarValue.GetTail(varName);
                            if (fieldName != null) {
                                object varValue = bag.GetVariableValue(varName);
                                object val = bag.GetVariableValue(baseName);

                                if (!StoreWidgetField(val, fieldName, varValue)) {
                                    CaseInsensitiveHashtable subVars = (CaseInsensitiveHashtable)val;

                                    if (subVars == null) {
                                        vars.TryGetValue(baseName, out subVars);
                                    }
                                    if (subVars == null) {
                                        subVars = new CaseInsensitiveHashtable();
                                        vars[baseName] = subVars;
                                    }

                                    subVars[fieldName] = varValue;
                                }
                            }
                        } catch (Exception e) {
                            DebuggerTrace.Log(e);
                        }
                    }
                }
            }
        }

        public void StoreReturnValue(string functionLeft, object returnValue) {
            this.functionLeft = functionLeft;
            this.returnValue = returnValue;
        }

        public bool HasVariable(string varName) {
            ProcessStructuredVars();

            if (varName == "$return") {
                return true;
            } else if (varName == "$page") {
                return page != null;
            } else if (vars.ContainsKey(varName)) {
                return true;
            } else if (extraVariables.ContainsKey(varName)) {
                return true;
            } else if (varsCollection != null) {
                foreach (IVarsBag localVars in varsCollection) {
                    if (localVars.HasVariable(varName))
                        return true;
                }
            }
            return false;
        }

        public Object GetVariable(string varName) {
            try {
                ProcessStructuredVars();

                if (varName == "$return") {
                    return returnValue;
                } else if (varName == "$page") {
                    return page;
                } else if (vars.ContainsKey(varName)) {
                    return vars[varName];
                } else if (extraVariables.ContainsKey(varName)) {
                    return extraVariables[varName];
                } else if (varsCollection != null) {
                    foreach (IVarsBag localVars in varsCollection) {
                        if (localVars.HasVariable(varName))
                            return localVars.GetVariableValue(varName);
                    }
                }
            } catch (Exception) { }
            return null;
        }

        internal void RemoveUnneededData() {
            vars = null;
            returnValue = null;
            varsCollection = null;
            page = null;
            extraVariables = null;
        }

        public void Save(XmlWriter writer) {
            writer.WriteAttributeString("eSpaceName", eSpaceName);
            writer.WriteAttributeString("functionName", functionName);
            WriteBreakpointId(writer, "functionId", functionId);
            writer.WriteAttributeString("functionType", functionType);
            WriteBreakpointId(writer, "breakpoint", currentBreakpointId);
            WriteBreakpointId(writer, "previousBreakpoint", previousBreakpointId);
            if (currentBreakpointType != BreakpointType.Normal) {
                writer.WriteAttributeString("breakpointType", currentBreakpointType.ToString());
            }
            if (functionLeft != null) {
                writer.WriteAttributeString("functionLeft", functionLeft);
            }
        }

        public static LocalState Load(XmlElement elem) {
            return new LocalState(elem);
        }

        private LocalState(XmlElement elem) {
            eSpaceName = elem.GetAttribute("eSpaceName");
            functionName = elem.GetAttribute("functionName");
            functionId = GetBreakpointId(elem, "functionId");
            functionType = elem.GetAttribute("functionType");
            currentBreakpointId = GetBreakpointId(elem, "breakpoint");
            previousBreakpointId = GetBreakpointId(elem, "previousBreakpoint");
            string breakpointTypeStr = elem.GetAttribute("breakpointType");
            if (breakpointTypeStr.IsEmpty()) {
                currentBreakpointType = BreakpointType.Normal;
            } else {
                currentBreakpointType = (BreakpointType)Enum.Parse(typeof(BreakpointType), breakpointTypeStr);
            }
            functionLeft = elem.GetAttribute("functionLeft");
        }

        private static void WriteBreakpointId(XmlWriter writer, string attrName, BreakpointId value) {
            if (value != null) {
                writer.WriteAttributeString(attrName, value.ToString());
            }
        }

        private static BreakpointId GetBreakpointId(XmlElement elem, string attrName) {
            string breakpointIdStr = elem.GetAttribute(attrName);
            if (breakpointIdStr.IsEmpty()) {
                return null;
            } else {
                BreakpointId breakpointId = null;
                BreakpointId.TryParse(breakpointIdStr, out breakpointId);
                return breakpointId;
            }
        }
    }

    /// <summary>
    /// Types of debug commands
    /// </summary>
    public enum DebugCommandType {
        None,
        ContinueThread,
        StepInto,
        StepOver,
        StepOut,
        Stop,
        Suspend
    }

    /// <summary>
    /// This class is used to represent commands sent to suspended threads.
    /// </summary>
    public class DebugCommand {
        private DebugCommandType command;
        public DebugCommandType Command {
            get { return command; }
        }

        // the stack state by the time the command was received by the suspended thread.
        // This is used to implement StepOver/StepOut commands.
        private StackManager stack;
        public StackManager Stack {
            get { return stack; }
        }

        private int activityId;
        public int ActivityId {
            get { return activityId; }
        }

        private DebugCommand() {
        }

        public DebugCommand(DebugCommandType command, ThreadData threadData) {
            this.command = command;
            this.stack = threadData.LastExceptionThrown == null ? threadData.Stack.CloneStack() : threadData.LastExceptionThrown.Stack.CloneStack();
            this.activityId = Debugger.ProcessInfo.ActivityId;
        }

        public override string ToString() {
            return Command.ToString();
        }

        internal void RemoveUnneededData() {
            Stack.RemoveUnneededData();
        }

        public DebugCommand CloneCommand() {
            DebugCommand result = new DebugCommand();
            result.command = this.command;
            result.stack = this.stack.CloneStack();
            result.activityId = this.activityId;
            return result;
        }

        public void Save(XmlWriter writer, string elementName) {
            writer.WriteStartElement(elementName);
            writer.WriteAttributeString("command", command.ToString());
            writer.WriteAttributeString("activityId", activityId.ToString());
            stack.Save(writer, "Stack");
            writer.WriteEndElement();
        }

        public static DebugCommand Load(XmlElement element) {
            return new DebugCommand(element);
        }

        private DebugCommand(XmlElement element) {
            command = (DebugCommandType)Enum.Parse(typeof(DebugCommandType), element.GetAttribute("command"));
            activityId = Convert.ToInt32(element.GetAttribute("activityId"));
            stack = StackManager.Load((XmlElement)element.SelectSingleNode("Stack"));
        }
    }

    public class DebuggerEventsData {
        private ObjectKey _eSpaceUID;
        private string _debugSessionToken, lastConnectedIp;

        internal DebuggerEventsData(HttpContext context, string sessionToken) {
            _debugSessionToken = sessionToken;
            _eSpaceUID = ObjectKey.Parse(context.Request.Params["eSpaceUID"]);
            RefreshClientIp(context);
        }

        internal string LastConnectedIp {
            get {
                return lastConnectedIp;
            }
        }

        internal void RefreshClientIp(HttpContext context) {
            lastConnectedIp = RuntimePlatformUtils.GetRequestRealIP(context.Request);
        }

        public ObjectKey eSpaceUID {
            get {
                return _eSpaceUID;
            }
        }

        public string DebugSessionToken {
            get {
                return _debugSessionToken;
            }
        }

        public DebugSession DebugSession {
            get { return Debugger.DebugSessions.GetByToken(_debugSessionToken); }
        }

        public override bool Equals(object obj) {
            if (!(obj is DebuggerEventsData)) {
                return false;
            }

            DebuggerEventsData otherObj = (DebuggerEventsData)obj;
            return ((_debugSessionToken == otherObj._debugSessionToken) && (_eSpaceUID == otherObj._eSpaceUID));
        }

        public override int GetHashCode() {
            return base.GetHashCode();
        }

    }

    /// <summary>
    /// HttpHandler used to send debug events to Service Studio.
    /// 
    /// For Java, this class must be mapped into a name finishing with Servlet, since in 
    /// JBossWS servlet class names must end with "Servlet" otherwise they are considered 
    /// as web services
    /// http://www.jboss.com/index.html?module=bb&amp;op=viewtopic&amp;t=85503
    /// </summary>
    public class DebuggerEvents : IHttpHandler {

        private struct EventAndId {
            public DebuggerEvent Event;
            public long Id;

            public bool IsStopDebugSessionEvent { get { return Event is StopDebugSessionEvent; } }
        }

        private struct ClientAndExpirationDate {
            public DebuggerEventsData ClientSessionEventsData;
            public long ExpirationTimeInTicks;
        }

        private class Clients {
            private LinkedList<ClientAndExpirationDate> disconnectedClients = new LinkedList<ClientAndExpirationDate>();

            private IDictionary<string, LinkedListNode<ClientAndExpirationDate>> sessionTokenToClientAndExpirationDateNode =
                new Dictionary<string, LinkedListNode<ClientAndExpirationDate>>();

            private Thread waitToDisconnectClientsThread;

            private void RemoveClientFromExpiration(LinkedListNode<ClientAndExpirationDate> clientToRemove) {
                if (clientToRemove != null) {
                    lock (this) {
                        disconnectedClients.Remove(clientToRemove);
                        sessionTokenToClientAndExpirationDateNode.Remove(clientToRemove.Value.ClientSessionEventsData.DebugSessionToken);
                    }
                }
            }

            private void WaitToDisconnectClientsThread() {
                lock (this) {
                    for (;;) {
                        long currentTimeInTicks = DateTime.Now.Ticks;
                        LinkedListNode<ClientAndExpirationDate> nextToExpireNode = disconnectedClients.First;

                        while ((nextToExpireNode != null) && (nextToExpireNode.Value.ExpirationTimeInTicks <= currentTimeInTicks)) {
                            RemoveClientFromExpiration(nextToExpireNode);
                            Debugger.RemoveClient(nextToExpireNode.Value.ClientSessionEventsData);
                            nextToExpireNode = disconnectedClients.First;
                        }

                        if (nextToExpireNode == null) {
                            waitToDisconnectClientsThread = null;
                            return;
                        } else {
                            Monitor.Wait(this, TimeSpan.FromTicks(nextToExpireNode.Value.ExpirationTimeInTicks - currentTimeInTicks));
                        }
                    }
                }
            }

            public DebuggerEventsData Add(HttpContext context, string sessionToken, bool useShortRequests) {
                if (useShortRequests) {
                    lock (this) {
                        LinkedListNode<ClientAndExpirationDate> previousClient;
                        DebuggerEventsData result;

                        if (sessionTokenToClientAndExpirationDateNode.TryGetValue(sessionToken, out previousClient)) {
                            result = previousClient.Value.ClientSessionEventsData;
                            RemoveClientFromExpiration(previousClient);
                            result.RefreshClientIp(context);
                        } else {
                            result = new DebuggerEventsData(context, sessionToken);
                            Debugger.AddClient(result);
                        }

                        Monitor.Pulse(this);
                        return result;
                    }
                } else {
                    var result = new DebuggerEventsData(context, sessionToken);
                    Debugger.AddClient(result);
                    return result;
                }
            }

            public void Remove(DebuggerEventsData client, bool useShortRequests) {
                if (useShortRequests) {
                    lock (this) {
                        var clientAndExpirationDate = new ClientAndExpirationDate() {
                            ClientSessionEventsData = client,
                            ExpirationTimeInTicks = DateTime.Now.Ticks + Debugger.REMOVE_CLIENT_TOLERANCE
                        };

                        LinkedListNode<ClientAndExpirationDate> insertedNode = disconnectedClients.AddLast(clientAndExpirationDate);
                        sessionTokenToClientAndExpirationDateNode[client.DebugSessionToken] = insertedNode;

                        if (waitToDisconnectClientsThread == null) {
                            waitToDisconnectClientsThread = new Thread(WaitToDisconnectClientsThread);
                            waitToDisconnectClientsThread.Start();
                        }
                    }
                } else {
                    Debugger.RemoveClient(client);
                }
            }
        }

        public const bool USE_SHORT_REQUESTS_DEFAULT = false;

        private static readonly Clients clients = new Clients();

        private bool IsClientConnected(HttpContext context) {
            return context.Response.IsClientConnected;
        }

        private void SendData(HttpContext context, string data) {
            if (IsClientConnected(context)) {
                context.Response.Write(data + "\r\n<end/>\r\n");
                context.Response.Flush();
            }
        }

        private void SendEvent(HttpContext context, DebugSession debugSession, string debugSessionToken, DebuggerEvent _event, long eventId) {
            if (_event != null) {
                string xml = _event.ToXml(eventId, !Debugger.IsInPublicArea, debugSession);
                DebuggerTrace.Log("Sending event to session " + debugSessionToken + ": " + xml);
                SendData(context, xml);
            }
        }

        private bool GetAndSendEvent(HttpContext context, DebuggerEventsData eventsData, int getEventDefaultTimeoutMultiplier,
                ref EventAndId lastEventReceived) {

            long eventId;

            DebuggerEvent @event = Debugger.GetDebugEvent(eventsData.DebugSessionToken, lastEventReceived.Id,
                getEventDefaultTimeoutMultiplier * Debugger.GET_DEBUG_EVENT_TIMEOUT_IN_MS, out eventId);

            SendEvent(context, eventsData.DebugSession, eventsData.DebugSessionToken, @event, eventId);

            if (@event == null) {
                return false;
            } else {
                lastEventReceived.Event = @event;
                lastEventReceived.Id = eventId;
                return true;
            }
        }

        public void ProcessRequest(HttpContext context) {
            RuntimePlatformUtils.SetScriptTimeout(Debugger.REQUEST_TIMEOUT_IN_SECONDS);

            // send marker so that real data can be distinguished from the response headers
            SendData(context, "");

            string sessionToken = context.Request.Params["debugSessionToken"];

            string useSRMParam = context.Request.Params["useSRM"];
            bool useShortRequests = false;
            if (useSRMParam != null) {
                Boolean.TryParse(useSRMParam, out useShortRequests);
            } else {
                useShortRequests = RuntimePlatformSettings.Debug.UseShortRequestsOnDebugger.GetValue();
            }

            // is the app being redeployed?
            if (Debugger.AppIsBeingRedeployed) {
                SendEvent(context, null, sessionToken, new ApplicationIsBeingRedeployedEvent(/*fromRedeployEvent*/false), -1);
                return;
            }

            // is there an active session?
            if (!Debugger.IsRunning) {
                SendEvent(context, null, sessionToken, new StopDebugSessionEvent("Debugger_SessionEnded"), -1);
                return;
            }

            // is the active session the one we wish to connect to?
            if (!Debugger.IsValidDebugSessionToken(sessionToken)) {
                SendEvent(context, null, sessionToken, new StopDebugSessionEvent("Debugger_CannotJoinSession"), -1);
                return;
            }


            // register this eSpace as being open
            DebuggerEventsData eventsData = clients.Add(context, sessionToken, useShortRequests);
            bool isReconnect;
            Boolean.TryParse(context.Request.Params["isReconnect"], out isReconnect);

            if (!isReconnect) {
                DebuggerTrace.Log("SS is now connected");

                // notify SS that the session has been successfully started
                SendEvent(context, eventsData.DebugSession, sessionToken, new DebugSessionStartedEvent(), -1);
            }

            string lastEventReceivedAux = context.Request.Params["lastEventReceived"];
            var lastEventReceived = new EventAndId();

            try {
                lastEventReceived.Id = Convert.ToInt64(lastEventReceivedAux);
            } catch {
            }

            try {
                if (useShortRequests) {
                    // wait for one event
                    GetAndSendEvent(context, eventsData, 3, ref lastEventReceived);

                    // send also other events that may be available now
                    while (true) {
                        if (!GetAndSendEvent(context, eventsData, 0, ref lastEventReceived)) {
                            break;
                        }
                    }

                    if (!lastEventReceived.IsStopDebugSessionEvent) {
                        SendData(context, "<Reconnect/>");
                    }

                    // Closes the socket so the Service Studio can reconnect
                    context.Response.OutputStream.Close();
                } else {
                    // cycle forever while client is still connected
                    while (true) {


                        // Writing to the response from time to time will keep the connection alive
                        // and will let us know if the client has disconnected
                        // (e.g. network issues, abrupt power failure, etc)
                        if (!IsClientConnected(context))
							break;

                        if (!GetAndSendEvent(context, eventsData, 1, ref lastEventReceived)) {
                            SendData(context, "<PingEvent/>");
                        }
                    }
                }
            } catch (DebuggerException de) {
                DebuggerTrace.Log(de);
            } catch (Exception e) {
                DebuggerTrace.Log(e);
            }

            if (!useShortRequests || lastEventReceived.IsStopDebugSessionEvent) {
                DebuggerTrace.Log("SS is now disconnected");
            }

            clients.Remove(eventsData, useShortRequests);
        }

        public bool IsReusable {
            get {
                return false;
            }
        }
    }

    public class DebuggerTrace {
        private static bool PrintHasBreakpointInformation = false;
        private static bool PrintHasBreakpointVerboseInformation = false;

        private static string Header {
            get {
                string requestPath = string.Empty;
                if (HttpContext.Current != null && HttpContext.Current.Request != null && HttpContext.Current.Request.Path != null) {
                    requestPath = HttpContext.Current.Request.Path;
                }
                return "Debugger (" + (Debugger.ThreadId ?? "") + ") " + (!requestPath.IsEmpty() ? requestPath + " - " : "");
            }
        }

        public static void Log(Exception e) {
            Log(e.Message + "\n" + e.StackTrace);
        }

        public static void Log(Func<string> msg) {
            lock (typeof(DebuggerTrace)) {
                if (OSTrace.LogLevel.TraceVerbose) {
                    OSTrace.Debug(Header + msg());
                }
            }
        }

        public static void Log(string msg) {
            lock (typeof(DebuggerTrace)) {
                OSTrace.Debug(Header + msg);
            }
        }

        private static void Log(string format, params object[] args) {
            lock (typeof(DebuggerTrace)) {
                OSTrace.Debug(format, args);
            }
        }

        public static void LogHasBreakpoint(BreakpointId breakpoint, DebugSessions sessions, bool hasBreakpoint) {
            if (!PrintHasBreakpointInformation) {
                return;
            }

            Log("HasBreakpoint {0}: {1}", breakpoint, hasBreakpoint);

            if (!PrintHasBreakpointVerboseInformation) {
                return;
            }

            foreach (DebugSession session in sessions.GetSessionsForCurrentRequest()) {
                Log("\tSession {0} - {1}:", session.Token, session.UserName);
                Log("\t\t{0}", session.Breakpoints.StrCat(","));
            }
        }
    }

    public class CaseInsensitiveHashtable {
        Hashtable data = new Hashtable();
        ArrayList allKeys = new ArrayList();

        public CaseInsensitiveHashtable() {
        }

        public object this[string key] {
            get {
                return data[key.ToLower()];
            }
            set {
                string lKey = key.ToLower();
                if (!data.ContainsKey(lKey))
                    allKeys.Add(key);
                data[lKey] = value;
            }
        }

        public bool ContainsKey(string key) {
            return data.ContainsKey(key.ToLower());
        }

        public ArrayList Keys {
            get {
                return allKeys;
            }
        }
    }

    public class DebugSessions {
        // info on the all the active debug sessions. We may have several Service Studios connected
        // to the same application, either from the same user or from different users (the latter
        // only for the public area)
        readonly List<DebugSession> debugSessions = new List<DebugSession>();

        public bool IsEmpty {
            get {
                lock (this) {
                    return debugSessions.IsEmpty();
                }
            }
        }

        public int Count {
            get {
                lock (this) {
                    return debugSessions.Count;
                }
            }
        }

        public bool IsValidToken(string token) {
            lock (this) {
                return debugSessions.Any(s => s.Token == token);
            }
        }

        public DebugSessions() {
        }

        public DebugSession GetOrCreate(string userName) {
            lock (this) {
                DebugSession session = debugSessions.SingleOrDefault(s => s.UserName == userName);
                if (session == null) {
                    session = new DebugSession(userName);
                    debugSessions.Add(session);
                }

                return session;
            }
        }

        public DebugSession GetByToken(string debugSessionToken) {
            lock (this) {
                return debugSessions.SingleOrDefault(s => s.Token == debugSessionToken);
            }
        }

        // used for debug purposes only
        public IEnumerable<string> ActiveDebugSessionTokens {
            get {
                lock (this) {
                    return debugSessions.Select(s => s.Token).ToArray();
                }
            }
        }

        public void Apply(Action<DebugSession> action) {
            lock (this) {
                debugSessions.ToArray().Apply(s => action(s));
            }
        }

        public void Stop(DebugSession debugSession, Func<DebugSession, DebuggerEvent> getEventToSend, bool willReconnect) {
            if (debugSession != null) {
                lock (this) {
                    debugSession.Stop(getEventToSend, willReconnect);
                    if (!willReconnect) {
                        debugSessions.Remove(debugSession);
                    }
                }
            }
        }

        public void Stop(string debugSessionToken, Func<DebugSession, DebuggerEvent> getEventToSend, bool willReconnect) {
            lock (this) {
                Stop(GetByToken(debugSessionToken), getEventToSend, willReconnect);
            }
        }

        public void Remove(DebugSession debugSession) {
            if (debugSession != null) {
                lock (this) {
                    debugSessions.Remove(debugSession);
                }
            }
        }

        public bool HasBreakpoints() {
            lock (this) {
                return debugSessions.Any(s => s.HasBreakpoints);
            }
        }

        public void Reset() {
            lock (this) {
                debugSessions.Clear();
            }
        }

        public IEnumerable<DebugSession> GetSessionsForCurrentRequest() {
            lock (this) {
                if (debugSessions.IsEmpty()) {
                    return Enumerable.Empty<DebugSession>();
                } else if (Debugger.ThreadData.DebugSessionToken.IsEmpty()) {
                    return debugSessions.Where(s => s.RequestAppliesToSession()).ToArray();
                } else {
                    return debugSessions.Where(s => s.Token == Debugger.ThreadData.DebugSessionToken).ToArray();
                }
            }
        }

        public IEnumerable<DebugSession> GetSessionsForBreakpoint(ThreadData threadData, BreakpointId breakpointId, bool isExpressionlessWidget, BreakpointType breakpointType, string extraInfo) {
            lock (this) {
                if (debugSessions.IsEmpty()) {
                    return Enumerable.Empty<DebugSession>();
                } else {
                    // remove inactive sessions
                    List<DebugSession> inactiveSessions = null;
                    foreach (DebugSession session in debugSessions.Where(s => !s.HasConnectedClients)) {
                        if (inactiveSessions == null) {
                            inactiveSessions = new List<DebugSession>();
                        }
                        inactiveSessions.Add(session);
                    }
                    if (inactiveSessions != null) {
                        inactiveSessions.Apply(s => Remove(s));
                    }

                    // Get the sessions where execution should be suspended in the given point (breakpointId).
                    // Debug session affinity is also taken into account.
                    return debugSessions.Where(s =>
                        (threadData.DebugSessionToken == null || threadData.DebugSessionToken == s.Token) &&
                        s.HasBreakpoint(threadData, breakpointId, isExpressionlessWidget, breakpointType, extraInfo)).ToArray();
                }
            }
        }

        public IEnumerable<DebugSession> GetRemainingSessions(DebugSession sessionToExclude) {
            lock (this) {
                return debugSessions.Where(s => s != sessionToExclude).ToArray();
            }
        }

        public void Enqueue(DebuggerEvent debugEvent, string debugSessionToken) {
            if (debugSessionToken == null) {
                Enqueue(debugEvent);
            } else {
                DebugSession session = GetByToken(debugSessionToken);
                if (session != null) {
                    session.Enqueue(debugEvent);
                }
            }
        }

        public void Enqueue(DebuggerEvent debugEvent, IEnumerable<DebugSession> sessions) {
            lock (this) {
                (sessions ?? this.debugSessions).Apply(s => s.Enqueue(debugEvent));
            }
        }

        public void Enqueue(DebuggerEvent debugEvent) {
            Enqueue(debugEvent, debugSessions);
        }

        public void EnqueueHandledByAnotherUserEvent(ThreadHandledByAnotherUserEvent debugEvent, string associatedDebugSessionToken) {
            Enqueue(debugEvent, debugSessions.Where(s => s.Token != associatedDebugSessionToken));
        }

        internal void SendLoggedInUsers() {
            lock (this) {
                Enqueue(new LoggedInUsersChangedEvent(debugSessions.Select(s => s.UserName)));
            }
        }

        internal bool IsSingle() {
            lock (this) {
                return debugSessions.IsSingle();
            }
        }

        internal bool HasConnectedClients(string debugSessionToken) {
            lock (this) {
                IEnumerable<DebugSession> sessions =
                    debugSessionToken == null ?
                        debugSessions :
                        debugSessions.Where(s => s.Token == debugSessionToken);
                return sessions.Any(s => s.HasConnectedClients);
            }
        }

        public void Save(XmlWriter writer) {
            writer.WriteStartElement("DebugSessions");
            debugSessions.Apply(s => s.Save(writer));
            writer.WriteEndElement();
        }

        public void Load(XmlElement elem) {
            foreach (XmlElement sessionElem in elem.SelectSingleNode("DebugSessions").SelectNodes("DebugSession")) {
                debugSessions.Add(DebugSession.Load(sessionElem));
            }
        }
    }

    public class DebugSession {

        // actual timeout value value 
        private long removeClientTolerance;

        private readonly string token;
        public HandleExceptionMode ExceptionMode = HandleExceptionMode.DoNotBreak;

        public string Token {
            get { return token; }
        }

        // The list of clients (i.e., SS instances) that are connected to this session
        private List<DebuggerEventsData> clients = new List<DebuggerEventsData>();

        // the time at which the last client for for the debug session disconnected. 
        // This is used to determine if there are still connected clients (we do 
        // not look directly at the number of connected clients since connections 
        // may be broken due to network problems and will be restored asap)
        private long removedLastClientAt;

        // this hashtable contains the breakpoints that have been set by Service Studio
        private readonly HashSet<BreakpointId> breakpoints = new HashSet<BreakpointId>();

        public bool HasBreakpoints {
            get { return !breakpoints.IsEmpty(); }
        }

        // the queue contains all debug events generated inside the current application
        // that we've determined to be relevant for this session
        private readonly EventQueue eventQueue;

        private readonly string userName;
        public string UserName {
            get { return userName; }
        }

        public DebugSession(string userName) {
            this.token = Guid.NewGuid().ToString();
            this.userName = userName;
            this.eventQueue = new EventQueue(this);
            removedLastClientAt = DateTime.Now.Ticks;
            removeClientTolerance = Debugger.REMOVE_CLIENT_TOLERANCE;
        }

        public DebuggerEvent GetDebugEvent(long lastEventReceived, int timeoutInMs, out long eventId) {
            return eventQueue.Dequeue(lastEventReceived, timeoutInMs, out eventId);
        }

        public void ClearEventQueue() {
            eventQueue.Clear();
        }

        public void Enqueue(DebuggerEvent debugEvent) {
            eventQueue.Enqueue(debugEvent);
        }

        public void Stop(Func<DebugSession, DebuggerEvent> getEventToSend, bool willReconnect) {
            if (!willReconnect) {
                breakpoints.Clear();
            }

            eventQueue.Clear();

            if (!willReconnect || getEventToSend != null) {
                eventQueue.Enqueue(getEventToSend == null ? new StopDebugSessionEvent() : getEventToSend(this));
            }
        }

        public void Add(BreakpointId breakpointId) {
            breakpoints.Add(breakpointId);
        }

        public void Remove(BreakpointId breakpointId) {
            breakpoints.Remove(breakpointId);
        }

        public void ClearBreakpoints() {
            breakpoints.Clear();
        }

        private bool IsLocalConnection(string ip) {
            return NetworkInterfaceUtils.IsLoopbackAddress(ip);
        }

        public string GetRequestRealIP(HttpRequest request) {
            return RuntimePlatformUtils.GetRequestRealIP(request);
        }

        private static bool IsWebServiceRequest() {
            return AppInfo.GetAppInfo(HttpContext.Current).OsContext.IsWebServiceRequest;
        }

        private static bool IsServiceAction() {
            return AppInfo.GetAppInfo(HttpContext.Current).OsContext.IsServiceAction;
        }

        private static bool IsNewRuntimeApplication() {
            return AppInfo.GetAppInfo(HttpContext.Current).IsMobileRuntime;
        }

        public bool RequestAppliesToSession() {
            // requests to web services apply to all sessions
            if (IsWebServiceRequest()) {
                return true;
            }

            // requests to service actions apply to all sessions
            if (IsServiceAction()) {
                return true;
            }

            // requests for new runtime espaces doesn't have ip restrictions to allow developers to debug from mobile devices
            if (IsNewRuntimeApplication()) {
                return true;
            }

            // - local requests apply to all sessions
            // - remote requests apply only to clients with the same ip
            string requestIp = GetRequestRealIP(HttpContext.Current.Request);
            if (IsLocalConnection(requestIp) || clients.Exists(c => c.LastConnectedIp == requestIp)) {
                return true;
            }
            return false;
        }


        public bool HasBreakpoint(ThreadData threadData, BreakpointId breakpointId, bool isExpressionlessWidget, BreakpointType breakpointType, string extraInfo) {

            LocalState stackTop = threadData.Stack.Top;

            // The breakpoint is only available for localhost connections and IP's with open session
            if (!RequestAppliesToSession())
                return false;


            if (stackTop != null && breakpointId != null) {

                stackTop.CurrentBreakpointId = breakpointId;
                stackTop.CurrentBreakpointExtraInfo = extraInfo;
                stackTop.CurrentBreakpointType = breakpointType;

                // is there a "Run To" breakpoint here? If so, stop only at that particular
                // breakpoint (but clear it after reaching there)
                if (threadData.RunToBreakpoint != null) {
                    if (breakpointId == threadData.RunToBreakpoint) {
                        DebuggerTrace.Log("Reached RunTo breakpoint " + threadData.RunToBreakpoint);
                        threadData.RunToBreakpoint = null;
                        return true;
                    } else {
                        return false;
                    }
                }

                // is there a global breakpoint at this point?
                if (threadData.StopImmediately || (breakpoints != null && breakpointType == BreakpointType.Normal &&
                    breakpoints.Contains(breakpointId))) {
                    threadData.StopImmediately = false;
                    return true;
                }

                DebugCommand lastCommand = threadData.LastDebugCommand;

                if (lastCommand != null) {
                    int lastStackDepth = lastCommand.Stack.Depth;
                    bool inSameStack =
                        threadData.Stack.Depth == 1 ||
                        lastCommand.Stack.Contains(threadData.Stack.Top) ||
                        threadData.Stack.Contains(lastCommand.Stack.Top);

                    // was the last command a Suspend? In that case we break at the next
                    // breakpointable object
                    if (lastCommand.Command == DebugCommandType.Suspend)
                        return true;

                    // are we at an expressionless widget? Then we stop here only if
                    // there is an explicit breakpoint
                    if (isExpressionlessWidget) {
                        return false;
                    }

                    // if the breakpoint is inside an eSpace that is not currently open,
                    // ignore it
                    ObjectKey eSpaceUID = breakpointId.ESpaceKey;
                    if (!Debugger.IsESpaceOpen(eSpaceUID)) {
                        return false;
                    }

                    // was the last command a StepInto? In that case, we want to break
                    // at the next breakpointable object
                    if (lastCommand.Command == DebugCommandType.StepInto) {
                        // if in same stack, break here
                        if (inSameStack)
                            return true;

                        // if the complete stack is from the currently open eSpace,
                        // break even if the stack root has changed
                        foreach (LocalState state in threadData.Stack.Elements) {
                            if (!Debugger.IsESpaceOpen(state.FunctionId.ESpaceKey))
                                return false;
                        }
                        return true;
                    }

                    // was the last command a StepOver and we're at a stack element
                    // below or at the same level than the one where we were before?
                    if (lastCommand.Command == DebugCommandType.StepOver &&
                        ((threadData.Stack.Depth <= lastStackDepth && breakpointType == BreakpointType.Normal)
                        || threadData.Stack.Depth < lastStackDepth)) {

                        // in the particular case of processes we must be in a different activity
                        if (Debugger.ProcessInfo.ActivityId != 0 &&
                            Debugger.ProcessInfo.ActivityId == lastCommand.ActivityId &&
                            IsAProcess(stackTop)) {

                            return false;
                        }

                        return inSameStack;
                    }

                    // was the last command a StepOut and we're at a stack element
                    // below the one where we were before?
                    if (lastCommand.Command == DebugCommandType.StepOut &&
                        threadData.Stack.Depth < lastStackDepth) {
                        return inSameStack;
                    }
                }
            }

            return false;
        }

        public void AddClient(DebuggerEventsData client) {
            clients.Add(client);
            removedLastClientAt = 0;
            removeClientTolerance = Debugger.REMOVE_CLIENT_TOLERANCE;
        }

        public void RemoveClient(DebuggerEventsData client) {
            clients.Remove(client);

            if (clients.IsEmpty()) {
                removedLastClientAt = DateTime.Now.Ticks;
            }
        }

        public bool HasConnectedClients {
            get {
                if (removedLastClientAt == 0) {
                    return true;
                } else {
                    return (DateTime.Now.Ticks - removedLastClientAt) <= removeClientTolerance;
                }
            }
        }

        public void Save(XmlWriter writer) {
            writer.WriteStartElement("DebugSession");

            writer.WriteAttributeString("userName", userName);
            writer.WriteAttributeString("token", token);
            writer.WriteAttributeString("exceptionMode", ExceptionMode.ToString());

            writer.WriteStartElement("Breakpoints");
            foreach (BreakpointId bp in breakpoints) {
                writer.WriteStartElement("Breakpoint");
                writer.WriteValue(bp.ToString());
                writer.WriteEndElement();
            }
            writer.WriteEndElement();

            writer.WriteEndElement();
        }

        public static DebugSession Load(XmlElement elem) {
            return new DebugSession(elem);
        }

        private DebugSession(XmlElement elem) {
            userName = elem.GetAttribute("userName");
            DebuggerTrace.Log("Loading session data for user " + userName);
            token = elem.GetAttribute("token");
            ExceptionMode = (HandleExceptionMode)Enum.Parse(typeof(HandleExceptionMode), elem.GetAttribute("exceptionMode"));

            foreach (XmlElement breakpointElem in elem.SelectSingleNode("Breakpoints").SelectNodes("Breakpoint")) {
                BreakpointId breakpointId = null;
                if (BreakpointId.TryParse(breakpointElem.InnerText, out breakpointId)) {
                    breakpoints.Add(breakpointId);
                }
            }

            eventQueue = new EventQueue(this);

            // This constructor is used when recreating stored debug sessions after a server recycly
            // or app deployement, so initially we've no connected clients. We've to "simulate" that
            // a client just disconnected now, otherwise if no client ever reconnects we'll keep
            // the debug session indefinetely!
            removedLastClientAt = DateTime.Now.Ticks;
            removeClientTolerance = Debugger.REMOVE_CLIENT_TOLERANCE_AFTER_RESTART;
        }

        internal IEnumerable<BreakpointId> Breakpoints { get { return breakpoints; } }

        private static bool IsAProcess(LocalState state) {
            return state.FunctionType == "Flows.Process" || state.FunctionType == "ReferenceProcess";
        }
    }


    // this is a struct on purpose - we need to create copies without changing the initial values
    internal struct ProcessInfo {
        // process id. Set only when the current request is executing process related stuff
        internal int ProcessId;

        // activity id. Set only when the current request is executing process related stuff
        internal int ActivityId;

        // precedent activity id. Set only when the current request is executing process related stuff
        internal int PrecedentActivityId;

        // the number of successors of the precedent activity. Used to determine if we can reuse the
        // long-lived request data or should instead create a clone
        internal int PrecedentActivitySuccessorsCount;

        // The root process Id
        internal int TopProcessId;

        public override bool Equals(object obj) {
            if (obj is ProcessInfo) {
                ProcessInfo other = (ProcessInfo)obj;
                return ProcessId == other.ProcessId &&
                       ActivityId == other.ActivityId &&
                       PrecedentActivityId == other.PrecedentActivityId &&
                       PrecedentActivitySuccessorsCount == other.PrecedentActivitySuccessorsCount &&
                       TopProcessId == other.TopProcessId;
            } else {
                return false;
            }
        }

        public override int GetHashCode() {
            return TopProcessId.GetHashCode();
        }
    }


    public static class DebuggerHelper {

        [ThreadStatic]
        public static BreakpointId RunToBreakpoint;
        [ThreadStatic]
        public static bool StopImmediately;

        public static bool IsRunning {
            get { return Debugger.IsRunning; }
        }

        public static void SetCurrentRequestClientToken(string requestToken) {
            Debugger.ThreadData.ClientRequestToken = requestToken;
        }

        public static void SetCurrentCallContextId(string callContextId) {
            int id;
            if (int.TryParse(callContextId, out id)) {
                Debugger.ThreadData.ClientSideCallContextId = id;
            }
        }

        // Called by generated code to save debugger Headers
        public static void SaveResponseData() {
            var lastCommand = Debugger.ThreadData.LastDebugCommand;
            var runToBreakpoint = Debugger.ThreadData.RunToBreakpoint;

            if (runToBreakpoint == null) {
                RunToBreakpoint = null;
                StopImmediately = lastCommand == null ? false :
                    lastCommand.Command == DebugCommandType.StepInto || lastCommand.Command == DebugCommandType.StepOut || lastCommand.Command == DebugCommandType.StepOver;
            } else {
                RunToBreakpoint = runToBreakpoint;
                StopImmediately = false;
            }
        }

        public static void SetCurrentRunToBreakpoint(string breakpointStr) {
            BreakpointId parsed;
            if (BreakpointId.TryParse(breakpointStr, out parsed)) {
                Debugger.ThreadData.RunToBreakpoint = parsed;
            }
        }

        public static void SetCurrentStopImmediately(string stopImmediatelyStr) {
            bool parsed;
            if (bool.TryParse(stopImmediatelyStr, out parsed)) {
                Debugger.ThreadData.StopImmediately = parsed;
            }
        }

        public static bool HasSuspendedThreadWithRequestToken(string requestToken) {
            return Debugger.HasSuspendedThreadWithRequestToken(requestToken);
        }
    }
}
