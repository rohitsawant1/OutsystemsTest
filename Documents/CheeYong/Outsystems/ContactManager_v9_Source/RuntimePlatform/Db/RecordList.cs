/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Xml;
using OutSystems.HubEdition.RuntimePlatform.NewRuntime;
using OutSystems.Internal.Db;
using OutSystems.RuntimeCommon;

namespace OutSystems.HubEdition.RuntimePlatform.Db {

    public interface IOSList : IEnumerable, IEnumerator, ISerializable, IDisposable {

        int CurrentRowNumber { get; set; }
        bool Empty { get; }
        int Length { get; }

        [Obsolete("Deprecated since 4.2.3.0. Use Length property instead.")]
        int ReturnedRowCount { get; }
        int MaxRecords { get; set; }

        void StartIteration();
        void EndIteration();
        bool Advance();
        bool Advance(int count);
        void SetPosition(int rownumber);

        bool Iterating { get; }
        bool Bof { get; }
        bool Eof { get; }
        bool HasHiddenRow { get; set; }

        void Set(int index, object value);
        void Insert(object record, int position);
        void Remove(int position);
        void FillFromOther(IOSList other);

        void RestoreRecordListEmptyState(bool empty);
        void RestoreRecordListState(int currentRowNumberState, bool eofState);
        void ToXml(Object parent, XmlElement baseElem, String fieldName, int detailLevel);
        void EvaluateFields(VarValue variable, Object parent, String baseName, String fields);

        Transaction Transaction { set; }
        IDataReader Reader { set; }

        void Sort(IComparer comparer);
        void Clear();
        void CloseDataReader();
        void InternalRecursiveSave();
        void RecursiveReset();
        void Read();
    }

    [Serializable()]
    public class RecordListInitializationException : Exception {
        public RecordListInitializationException(Exception e) : base(e.Message, e) { }
    }

    [Serializable()]
    public class IListWrapper<T> : IList<T>, ISerializable {
        // The ArrayList to hold the Data.
        // This is necessary due a .Net Framework x64 bug related to the method Add while adding a "giant" structure.
        // With ArrayList, everything works fine
        private ArrayList _realData = new ArrayList();

        public IListWrapper() { }

        public IListWrapper(SerializationInfo info, StreamingContext context) {
            _realData = (ArrayList)info.GetValue("_data", typeof(ArrayList));
        }

        public void Add(T item) {
            _realData.Add(item);
        }

        public void Clear() {
            _realData.Clear();
        }

        public bool Contains(T item) {
            return _realData.Contains(item);
        }

        public void CopyTo(T[] array, int arrayIndex) {
            _realData.CopyTo(array, arrayIndex);
        }

        public int IndexOf(T item) {
            return _realData.IndexOf(item);
        }

        public void Insert(int index, T item) {
            _realData.Insert(index, item);
        }

        public bool Remove(T item) {
            int nrItems = Count;
            _realData.Remove(item);
            return nrItems > Count;
        }

        public void RemoveAt(int index) {
            _realData.RemoveAt(index);
        }

        public void Sort(IComparer comparer) {
            _realData.Sort(comparer);
        }

        public T this[int index] {
            get { return (T)_realData[index]; }
            set { _realData[index] = value; }
        }

        public int Count {
            get { return _realData.Count; }
        }

        public bool IsReadOnly {
            get { return _realData.IsReadOnly; }
        }

        IEnumerator IEnumerable.GetEnumerator() {
            return _realData.GetEnumerator();
        }

        IEnumerator<T> IEnumerable<T>.GetEnumerator() {
            return _realData.Cast<T>().GetEnumerator();
        }

        #region ISerializable Members

        public void GetObjectData(SerializationInfo info, StreamingContext context) {
            info.AddValue("_data", _realData);
        }

        #endregion
    }

    /// <summary>
    /// Abstract class that implements basic list behavior and 
    /// from which all other lists must derive.
    /// </summary>
    [Serializable()]
    public abstract class OSList<T> : IOSList {

        /// <summary>
        /// Contains the records when operating as an 
        /// in-memory list. Always points to an arraylist in case of an in 
        /// memory list.
        /// </summary>
        /// <remarks>
        /// Set to null when not being used.
        /// </remarks>
        protected IList<T> _data = new IListWrapper<T>();
        protected BitArray[] _optimizedAttributes;

        public void Add(object obj) {
            Append((T)obj);
        }

        public BitArray[] AllOptimizedAttributes {
            set {
                _optimizedAttributes = value;
            }
            get {
                if (_optimizedAttributes == null) {
                    _optimizedAttributes = GetDefaultOptimizedValues();
                }
                return _optimizedAttributes;
            }
        }

        public abstract BitArray[] GetDefaultOptimizedValues();

        public void Clear() {
            // Clear is not valid for database records
            if (_data == null) {
                throw new InvalidOperationException("Clear is not valid for database lists");
            }

            if (_iterating) {
                throw new InvalidOperationException("Clear is not a valid operation inside a StartIteration/EndIteration block.");
            }

            _data.Clear();
            _firstRead = true;
            _bof = true;
            _eof = true;
            _empty = true;
            _hasHiddenRow = false;
            _currentRowNumber = 0;
            CurrentRec = GetElementDefaultValue();
        }

        /// <summary>
        /// Contains the records when operating as an 
        /// in-memory list.
        /// </summary>
        public IList<T> Data {
            get {
                return _data;
            }
        }

        /// <summary>
        /// The IDataReader used by the list when reading data
        /// from the database.
        /// </summary>
        /// <remarks>
        /// Set to null when not being used.
        /// </remarks>
        protected IDataReader _reader = null;

        /// <summary>
        /// Property that only sets internal field _reader
        /// </summary>
        public IDataReader Reader {
            set {
                // Save the new reader
                _reader = value;
                _data = null;

                // Set the flag so that MoveNext behaves properly
                _firstRead = true;

                // If we can read the record next record
                if (_reader.Read()) {
                    // Reset eof
                    // TODO: eof must return T if there is only one row (automatic advance...)
                    _eof = false;
                    // Set bof
                    _bof = true;
                    // Reset empty
                    _empty = false;
                    // Set row number
                    _currentRowNumber = 0;
                } else { // Otherwise (If we can read the record next record)
                    // Set eof
                    _eof = true;
                    // Set bof
                    _bof = true;
                    // Set empty
                    _empty = true;
                    // Set row number
                    _currentRowNumber = 0;
                    // Close data reader and dispose
                    CloseDataReader();
                }

                if (!_empty) {
                    Read();
                }
            }
        }

        /// <summary>
        /// Maximum number of records in the record list.
        /// </summary>
        /// <remarks>
        /// If set to 0, means infinity (read all records).
        /// </remarks>
        private int _maxRecords = 0;

        public int MaxRecords {
            get { return _maxRecords; }
            set { _maxRecords = value; }
        }

        /// <summary>
        /// Zero based number of the row.
        /// </summary>
        /// <remarks>
        /// If set to -1 then we are not positioned. 
        /// Otherwise it is the zero based number of the row.
        /// </remarks>
        protected int _currentRowNumber = 0;

        /// <summary>
        /// Zero based number of the row.
        /// </summary>
        /// <remarks>
        /// If set to -1 then we are before the the first record. 
        /// Otherwise it is the zero based number of the row.
        /// </remarks>
        public int CurrentRowNumber {
            get { return _currentRowNumber; }
            set {
                _currentRowNumber = value;
                _bof = _currentRowNumber == 0;
                _eof = false;
            }
        }

        protected bool _saveRec = false;

        /// <summary>
        /// The number of records stored in the list.
        /// </summary>
        /// <remarks>
        /// Database lists always return -1 while in-memory
        /// records return the current number of records stored.
        /// </remarks>
        public int Length {
            get {
                if (_data != null) {
                    var maxRecords = MaxRecords > 0 ? MaxRecords : int.MaxValue;
                    return Math.Min(_data.Count, maxRecords);
                } else {
                    return -1;
                }
            }
        }

        [Obsolete("Deprecated since 4.2.3.0. Use Length property instead.")]
        public int ReturnedRowCount {
            get { return Length; }
        }

        /// <summary>
        /// Specifies if we are currently at the beggining of the 
        /// list.
        /// </summary>
        protected bool _bof = true;

        /// <summary>
        /// Specifies if we are currently at the beggining of the 
        /// list.
        /// </summary>
        /// <remarks>
        /// Set to true the list has reached BOF, otherwise BOF has not
        /// been reached.
        /// </remarks>
        public bool Bof {
            get { return _bof; }
        }

        /// <summary>
        /// Specifies if we are currently at the end of the 
        /// list.
        /// </summary>
        protected bool _eof = true;

        /// <summary>
        /// Specifies if we are currently at the end of the 
        /// list.
        /// </summary>
        /// <remarks>
        /// Set to true the list has reached EOF, otherwise EOF has not
        /// been reached.
        /// </remarks>
        public bool Eof {
            get { return _eof; }
        }

        /// <summary>
        /// Specifies if the Editable Table has the hidden row in 
        /// the list
        /// </summary>
        protected bool _hasHiddenRow = false;

        /// <summary>
        /// Specifies if the Editable Table has the hidden row in 
        /// the list
        /// </summary>
        /// <remarks>
        /// Set to true if the list has the hidden row of the Editable Table.
        /// This is not needed for the other widgets.
        /// </remarks>
        public bool HasHiddenRow {
            get { return _hasHiddenRow; }
            set { _hasHiddenRow = value; }
        }

        /// <summary>
        /// Specifies if the record list is empty
        /// </summary>
        protected bool _empty = true;

        /// <summary>
        /// Specifies if the record list is empty
        /// </summary>
        /// <remarks>
        /// Set to true if the list is empty, otherwise the list is not empty.
        /// </remarks>
        public bool Empty {
            get { return _empty; }
        }

        protected Transaction _transaction;

        public Transaction Transaction {
            set {
                _transaction = value;
            }
        }

        /// <summary>
        /// Specifies if this is the first time the list is read.
        /// </summary>
        protected bool _firstRead = true;

        /// <summary>
        /// Specifies if the list is being iterated or not.
        /// </summary>
        protected bool _iterating = false;
        public bool Iterating {
            get { return _iterating; }
        }

        /// <summary>
        /// Contains the list of fields that were not retrieved from the database
        /// </summary>
        protected string _optimizedFields;
        public string OptimizedFields {
            get { return _optimizedFields; }
            set { _optimizedFields = value; }
        }

        public OSList() {
            CurrentRec = GetElementDefaultValue();
        }

        public OSList(IDisposable obj) {
            CurrentRec = GetElementDefaultValue();
        }

        [Obsolete("Use the Default Constructor and set the Transaction afterwards.")]
        public OSList(IDbTransaction trans) : this(trans, null) {
        }

        [Obsolete("Use the Default Constructor and set the Transaction afterwards.")]
        public OSList(IDbTransaction trans, ReadDBMethodDelegate alternateReadDBMethod) : this() {
            if (trans != null) {
                try {
                    Transaction = new ManagedTransaction(DatabaseAccess.GetProviderForTransaction(trans).TransactionManager, trans, DatabaseAccess.DatabaseBehaviours);
                } catch (Exception e) {
                    /* 
                     * The old method didn't throw checked exceptions in java because it was a simple assignment. 
                     * Now the methods used to wrap the transaction throw checked exceptions so we catch 
                     * them all here and rethrow them as an unchecked exception to preserve the method signature.
                     */
                    throw new RecordListInitializationException(e);
                }
            }
            this.alternateReadDBMethod = alternateReadDBMethod;
        }

        /// <summary>
        /// Create the object from serialized data.
        /// </summary>
        public OSList(SerializationInfo info, StreamingContext context) {
            // IMPORTANT - Java compatibility
            // The order by which the fields are being retrieved here must be
            // the same by which they are stored in the GetObjectData method

            // Load empty flag
            _empty = info.GetBoolean("_empty");
            // Load eof flag
            _eof = info.GetBoolean("_eof");
            // Load bof flag
            _bof = info.GetBoolean("_bof");
            // Load current row number
            _currentRowNumber = info.GetInt32("_currentRowNumber");
            // Load in-memory record list
            object value = info.GetValue("_data", typeof(IList<T>));
            _data = (IList<T>)value;
            if (_data == null) {
                _data = new IListWrapper<T>();
            }

            // Reset reader
            _reader = null;

            CurrentRec = (T)info.GetValue("CurrentRec", typeof(T));
        }

        /// <summary>
        /// Saves the object data for serialization.
        /// </summary>
        public void GetObjectData(SerializationInfo info, StreamingContext context) {
            // IMPORTANT - Java compatibility
            // The order by which the fields are being store here must be
            // the same by which they are retrieved in the constructor above

            // Save empty flag
            info.AddValue("_empty", _empty);
            // Save eof flag
            info.AddValue("_eof", _eof);
            // Save bof flag
            info.AddValue("_bof", _bof);
            // Save current row number
            info.AddValue("_currentRowNumber", _currentRowNumber);
            // Save in-memory record list
            info.AddValue("_data", _data);

            info.AddValue("CurrentRec", (object)CurrentRec);
        }

        /// <summary>
        /// Close the datareader and, maybe, disposes conn object.
        /// </summary>
        /// <remarks>
        /// Set disposeObject to true, unless this method is being called by 
        /// the "disposer" (eg: DbConnManager.CloseConn())
        /// </remarks>
        public void CloseDataReader() {
            // If we don't have a reader exit
            if (_reader == null) {
                return;
            }

            // If the reader is not closed ...
            if (_reader != null && !_reader.IsClosed) {
                // Close the reader
                _reader.Close();
            }

            // Reset the reader
            _reader = null;

            // Release the transaction
            _transaction.SafeRelease();
        }

        /// <summary>
        /// Saves the current record to the list buffer.
        /// </summary>
        /// <remarks>
        /// This should be called to save the current record before
        /// operating on the record list (advancing, serializing, etc).
        /// </remarks>
        public virtual void InternalRecursiveSave() {
            if (_saveRec) {
                if (_data != null) {
                    if (_currentRowNumber >= 0 && _currentRowNumber < _data.Count) {
                        _data[_currentRowNumber] = ShallowDuplicate(CurrentRec);
                    }
                }

                _saveRec = false;
            }
        }

        protected void Save() {
            InternalRecursiveSave();
        }

        /// <summary>
        /// Reads the current record from the source.
        /// </summary>
        public abstract void Read();

        public void StartIteration() {
            // If we're iterating then StartIteration is invalid
            if (_iterating) {
                throw new RecursiveIterationException("Detected a recursive iteration over the same list.");
            }

            // Reset iteration flag
            _iterating = true;

            Reset();
            if (!Eof) {
                Read();
            }
        }

        public void EndIteration() {
            // If we're not iterating then EndIteration is invalid
            if (!_iterating) {
                throw new RecursiveIterationException("Called EndIteration while the list was not being iterated...");
            }

            // Reset iteration flag
            _iterating = false;

            Save();
            if (_data != null && CurrentRowNumber < _data.Count) {
                _saveRec = true;
            }
            CloseDataReader();
        }

        /// <summary>
        /// Resets the list to its initial position.
        /// </summary>
        /// <remarks>Cannot be used more than once when using a 
        /// database list.
        /// </remarks>
        public void Reset() {
            // Reset first read flag so that when MoveNext is called
            // it will position the current record correctly.
            _firstRead = true;

            // If the is an in-memory list save the current record
            // and reset the eof and bof flags.
            if (_data != null) {
                // Save the record
                Save();
                // If the list has records ...
                if (_data.Count > 0) {
                    // clean the bof and eof flags
                    _bof = true;
                    _eof = false;
                    _empty = false;
                } else { // Otherwise (If the list DOES NOT have records ...)
                    // set the bof and eof flags
                    _bof = true;
                    _eof = true;
                    _empty = true;
                }
            }

            // Reset the current record position
            _currentRowNumber = 0;
        }

        /// <summary>
        /// Advances the current record to the next record in the list.
        /// </summary>
        /// <remarks>
        /// <para>After an enumerator is created or after a call to 
        /// Reset, an enumerator is positioned before the first element
        /// of the collection, and the first call to MoveNext moves the
        /// enumerator over the first element of the collection.</para>
        /// <para>After the end of the collection is passed, subsequent
        /// calls to MoveNext return false until Reset is called.</para>
        /// </remarks>
        public bool Advance() {
            // If we reached eof then ...
            if (_eof) {
                // Set _saveRec to false. Important for in memory record lists (check #70735)
                _saveRec = false;
                // Fail
                return false;
            }
            // If we're a database list
            if (_data == null) {
                // If the reader is not closed and we can read a record
                if (_reader != null && !_reader.IsClosed && _reader.Read()) {
                    // Increment the row number
                    _currentRowNumber++;
                    // Reset bof
                    _bof = false;
                    // Set eof if MaxRecords is specified
                    _eof = (MaxRecords > 0 ? _currentRowNumber == MaxRecords : false);
                } else { // Otherwise (If the reader is not closed and we can read a record)
                    // We've reached eof
                    _eof = true;
                }
                if (_eof) {
                    // Close the reader
                    CloseDataReader();
                }
            } else { // Otherwise (if we're an in-memory list)
                // If we're not in the last record
                var maxRecords = MaxRecords > 0 ? MaxRecords : int.MaxValue;
                if (_currentRowNumber + 1 < Math.Min(_data.Count, maxRecords)) {
                    // Save the current record
                    Save();
                    // Jump to the next row
                    _currentRowNumber++;
                    // Reset bof
                    _bof = false;
                } else { // Otherwise (If we ARE in the last record)
                    // Save the current record
                    Save();
                    // Set eof
                    _eof = true;
                }
            }

            if (!_eof) {
                Read();
            }

            // Return success if we haven't reached eof
            return !_eof;
        }

        /// <summary>
        /// Advances <paramref>count</paramref> records in the list.
        /// </summary>
        /// <param name="count">Number of records to skip.</param>
        /// <remarks>
        /// <para>After an enumerator is created or after a call to 
        /// Reset, an enumerator is positioned before the first element
        /// of the collection, and the first call to MoveNext moves the
        /// enumerator over the first element of the collection.</para>
        /// <para>After the end of the collection is passed, subsequent
        /// calls to MoveNext return false until Reset is called.</para>
        /// </remarks>
        public bool Advance(int count) {
            // While count is bigger than zero, decrement count and...
            while (count-- > 0) {
                // Advance the record list
                Advance();
            }
            // Return success if we haven't reached eof
            return !_eof;
        }

        public virtual object Current {
            get { return CurrentRec; }
        }

        public IEnumerator GetEnumerator() {
            return this;
        }

        public bool MoveNext() {
            if (!_firstRead) {
                this.Advance();
            } else {
                _firstRead = false;
            }
            return !this.Eof;
        }

        // These functions are not implemented here but are present
        // in children classes in order to provide type checking
        // 
        // public abstract RECORDTYPE this[int index];

        void IOSList.Set(int index, object value) {
            _data[index] = (T)value;
        }

        public void Insert(object record, int position) {
            Insert((T)record, position);
        }

        public void Insert(T record, int position) {
            if (_data == null) {
                throw new InvalidOperationException("Insert is not a valid operation for database lists.");
            }
            if (_iterating) {
                throw new InvalidOperationException("Insert is not a valid operation inside a StartIteration/EndIteration block.");
            }

            if (position < 0) {
                position = 0;
            }
            if (position > _data.Count) {
                position = _data.Count;
            }

            if (position == _data.Count) {
                _data.Add(DeepDuplicate(record));
            } else {
                _data.Insert(position, DeepDuplicate(record));
            }

            if (position <= _currentRowNumber) {
                _currentRowNumber++;
            }

            if (position == 0 && _data.Count == 1) {
                _currentRowNumber = 0;
                Read();
                _eof = false;
            } else {
                _eof = (_currentRowNumber + 1 == _data.Count);
            }

            _bof = (_currentRowNumber == 0);
            _empty = false;
        }

        public void Append(T record) {
            if (_data == null) {
                throw new InvalidOperationException("Append is not a valid operation for database lists.");
            }
            if (_iterating) {
                throw new InvalidOperationException("Append is not a valid operation inside a StartIteration/EndIteration block.");
            }
            Insert(record, _data.Count + 1);
        }

        public void AppendAll(OSList<T> recordsToAppend) {
            if (_data == null) {
                throw new InvalidOperationException("AppendAll is not a valid operation for database lists.");
            }
            if (_iterating) {
                throw new InvalidOperationException("AppendAll is not a valid operation inside a StartIteration/EndIteration block.");
            }
            recordsToAppend.StartIteration();
            try {
                foreach (T recordToAppend in recordsToAppend) {
                    Append(recordToAppend);
                }
            } finally {
                recordsToAppend.EndIteration();
            }
        }

        public void Remove(int position) {
            bool previousEof = _eof;
            // Remove is not valid for database records
            if (_data == null) {
                throw new InvalidOperationException("Remove is not valid for database lists");
            }

            if (_iterating) {
                throw new InvalidOperationException("Remove is not a valid operation inside a StartIteration/EndIteration block.");
            }

            // Position must be >= 0 and < Count otherwise ignore
            if (position < 0 || position >= _data.Count) {
                return;
            }

            // Don't let the selected record be the deleted one
            if (_currentRowNumber == position) {
                Advance();
            }

            // Finally remove the record
            _data.RemoveAt(position);

            if (position <= _currentRowNumber) {
                _currentRowNumber--;
            }

            if (_currentRowNumber < 0) {
                _currentRowNumber = 0;
            } else {
                Read();
                Save();
            }
            _empty = (_data.Count == 0);
            _bof = (_currentRowNumber == 0);
            if (_empty) {
                _eof = true;
            } else {
                _eof = previousEof;
            }
        }

        /// <summary>
        /// For internal use only.
        /// </summary>
        /// <remarks>
        /// <para>This function is for internal use only.</para>
        /// <para>Performs a reset on the list and progates the
        /// reset to the record.</para>
        /// </remarks>
        public abstract void RecursiveReset();

        /// <summary>
        /// For internal use only.
        /// </summary>
        /// <remarks>
        /// <para>This function is for internal use only.</para>
        /// <para>Sets the position of the list thus moving CurrentRec to the new position</para>
        /// </remarks>
        public void SetPosition(int rownumber) {
            if (_data == null) {
                throw new InvalidOperationException("SetPosition is not a valid operation for database lists.");
            }
            if (rownumber < 0) {
                throw new ArgumentOutOfRangeException("rowNumber", rownumber, "rowNumber must be 0 or a positive integer value");
            }
            // If we're going to the last record
            if (rownumber < _data.Count - 1) {
                // Save the current record
                Save();
                // Jump to the next row
                _currentRowNumber = rownumber;
                // Reset bof
                _bof = false;
                // Reset eof
                _eof = false;
                // Read new content
                Read();
            }
            // Otherwise (If we ARE in the last record)
            else {
                // Save the current record
                Save();
                // Jump to the next row
                _currentRowNumber = rownumber;
                // Reset bof
                _bof = false;
                // Set eof
                _eof = true;
                // Read new content
                Read();
            }
        }

        public void ToXml(object parent, XmlElement baseElem, string fieldName, int detailLevel) {
            XmlElement listElem = VarValue.AppendChild(baseElem, "Record.List");
            if (fieldName != null) {
                VarValue.AppendAttribute(listElem, "debug.field", fieldName);
            }
            if (detailLevel > 0) {
                var elementIsRecordOrList = Current is IRecord || Current is IOSList;

                if (elementIsRecordOrList) {
                    VarValue.InvokeToXml(Current, this, listElem, "Current", detailLevel - 1);
                } else if (Current != null) {
                    VarValue.AppendAttribute(listElem, "Current", Current, detailLevel - 1);
                }

                VarValue.AppendAttribute(listElem, "EOF", Eof, TypeKind.Boolean);
                VarValue.AppendAttribute(listElem, "BOF", Bof, TypeKind.Boolean);
                VarValue.AppendAttribute(listElem, "CurrentRowNumber", CurrentRowNumber, TypeKind.Integer);

                if (Length == -1) {
                    VarValue.AppendOptimizedAttribute(listElem, "Length");
                } else {
                    VarValue.AppendAttribute(listElem, "Length", Length, TypeKind.Integer);
                }

                VarValue.AppendAttribute(listElem, "Empty", Empty, TypeKind.Boolean);

                if (_reader == null) {
                    if (_data != null) {
                        for (int i = 0; i < _data.Count && i < Constants.DEBUGGER_MAX_ROW_COUNT; i++) {
                            if (elementIsRecordOrList) {
                                VarValue.InvokeToXml(_data[i], this, listElem, "[" + i + "]", detailLevel - 1);
                            } else {
                                VarValue.AppendAttributeAsChild(listElem, "[" + i + "]", _data[i], detailLevel - 1);
                            }
                        }
                    }
                }
            } else {
                VarValue.AppendDeferredEvaluationElement(listElem);
            }
        }

        public void EvaluateFields(VarValue variable, object parent, string baseName, string fields) {
            var head = VarValue.GetHead(fields);
            var tail = VarValue.GetTail(fields);
            variable.Found = false;
            if (head == "current") {
                variable.Value = Current;
            } else if (head == "eof") {
                variable.Value = Eof;
            } else if (head == "bof") {
                variable.Value = Bof;
            } else if (head == "currentrownumber") {
                variable.Value = CurrentRowNumber;
            } else if (head == "length") {
                variable.Value = Length;
            } else if (head == "empty") {
                variable.Value = Empty;
            } else if (head.StartsWith("[") && head.EndsWith("]")) {
                EvaluateRecordAt(variable, head.Substring(1, head.Length - 2));
            }
            if (variable.Found && tail != null) {
                variable.EvaluateFields(this, head, tail);
            }
        }

        private void EvaluateRecordAt(VarValue variable, string indexStr) {
            variable.Found = false;

            // extract index and value
            int index = 0;
            try {
                index = int.Parse(indexStr);
            } catch (FormatException) {
                object idx = variable.Stack.Evaluate(indexStr, variable.StackLevel);
                if (idx == null || !(idx is int)) {
                    return;
                }
                index = (int)idx;
            }
            if (index >= 0 && index < _data.Count) {
                variable.Value = _data[index];
            }
        }

        public void RestoreRecordListState(int currentRowNumberState, bool eofState) {
            try {
                StartIteration();

                if (eofState) {
                    while (!Eof) {
                        Advance();
                    }
                } else {
                    Advance(currentRowNumberState);
                }
                _eof = eofState;
            } finally {
                EndIteration();
            }
        }

        public void RestoreRecordListEmptyState(bool empty) {
            _empty = empty;
        }

        public void FillFromOther(IOSList other) {
            if (other == null) {
                Clear();
                return;
            }

            if (other.Iterating) {
                throw new InvalidOperationException("FillFromOther is not a valid operation inside a StartIteration/EndIteration block.");
            }

            Clear();
            other.StartIteration();

            try {
                while (!other.Eof) {
                    T recordToInsert = Convert(other.Current);
                    Append(recordToInsert);
                    other.Advance();
                }
            } finally {
                other.EndIteration();
            }
        }

        public void Dispose() {
            CloseDataReader();
        }

        public static bool operator ==(OSList<T> a, OSList<T> b) {
            if (ReferenceEquals(a, null)) {
                return ReferenceEquals(b, null);
            }

            if (ReferenceEquals(b, null)) {
                return ReferenceEquals(a, null);
            }

            if (a._empty && b._empty) {
                return true;
            }

            return ReferenceEquals(a, b);
        }

        public static bool operator !=(OSList<T> a, OSList<T> b) {
            return !(a == b);
        }

        public override bool Equals(object obj) {
            if (!(obj is OSList<T>)) {
                return false;
            }
            return this == (OSList<T>)obj;
        }

        public override int GetHashCode() {
            // This check garantees the hash code principals.
            // For us, two Record lists are the same if they are both empty.
            // So their hash must be the same.
            if (_empty) {
                return 1;
            }

            return base.GetHashCode();
        }

        public delegate void ReadDBMethodDelegate(ref T rec, IDataReader r);
        protected ReadDBMethodDelegate alternateReadDBMethod;

        public ReadDBMethodDelegate AlternateReadDBMethod {
            protected get {
                return alternateReadDBMethod;
            }
            set {
                alternateReadDBMethod = value;
            }
        }

        /// <summary>
        /// Current Record variable
        /// </summary>
        public T CurrentRec;

        protected abstract OSList<T> NewList();
        protected abstract T DeepDuplicate(T value);
        protected abstract T ShallowDuplicate(T value);
        protected abstract T GetElementDefaultValue();
        protected abstract T Convert(object other);

        /// <summary>
        /// Gets the object of a given index
        /// </summary>
        /// <param name="index"> Intex of item to get</param>
        /// <returns>The object of required index</returns>
        public T this[int index] {
            get {
                if (_reader != null) {
                    throw new NotSupportedException("Database Record List doesn't support indexer property");
                }
                if (_data == null || index < 0 || index >= _data.Count) {
                    throw new IndexOutOfRangeException("index " + index + " is out of range");
                }
                if (_data.Count == 0) {
                    throw new IndexOutOfRangeException("No records exist");
                }
                if (index == _currentRowNumber) {
                    Save();
                    _saveRec = true;
                }
                return ShallowDuplicate(_data[index]);
            }
            set {
                if (_reader != null) {
                    throw new NotSupportedException("Database Record List doesn't support indexer property");
                }
                if (_data == null || index < 0 || index >= _data.Count) {
                    throw new IndexOutOfRangeException("index " + index + " is out of range");
                }
                if (_data.Count == 0) {
                    throw new IndexOutOfRangeException("No records exist");
                }
                _data[index] = ShallowDuplicate(value);
                if (index == _currentRowNumber) {
                    CurrentRec = ShallowDuplicate(value);
                }
            }
        }

        /// <summary>
        /// Duplicates the record List
        /// </summary>
        /// <returns>The duplicated record list</returns>
        public OSList<T> Duplicate() {
            if (_iterating) {
                throw new InvalidOperationException("Duplicate is not a valid operation inside a StartIteration/EndIteration block.");
            }
            var t = NewList();
            t.AllOptimizedAttributes = AllOptimizedAttributes;
            StartIteration();
            while (!Eof) {
                t.Append(CurrentRec);
                Advance();
            }
            EndIteration();
            t.OptimizedFields = OptimizedFields;
            return t;
        }

        /// <summary>
        /// Distinct the record List
        /// </summary>
        /// <returns>The distincted record list</returns>
        public OSList<T> Distinct() {
            if (_iterating) {
                throw new InvalidOperationException("Distinct is not a valid operation inside a StartIteration/EndIteration block.");
            }
            var t = NewList();
            t.AllOptimizedAttributes = AllOptimizedAttributes;
            StartIteration();
            try {
                while (!Eof) {
                    if (!t.Contains(CurrentRec)) {
                        t.Append(CurrentRec);
                    }
                    Advance();
                }
            } finally {
                EndIteration();
            }
            t.OptimizedFields = OptimizedFields;
            return t;
        }

        public bool Contains(T obj) {
            if (_iterating) {
                throw new InvalidOperationException("Contains is not a valid operation inside a StartIteration/EndIteration block.");
            }
            StartIteration();
            try {
                while (!Eof) {
                    if (CurrentRec.Equals(obj)) {
                        return true;
                    }
                    Advance();
                }
            } finally {
                EndIteration();
            }
            return false;
        }

        public static TList Convert<S, TTargetType, TList>(OSList<S> sourceList, TList targetList, ConvertFunction<S, TTargetType> conv)
            where TList : OSList<TTargetType> {

            TTargetType rec = targetList.GetElementDefaultValue();
            sourceList.StartIteration();
            while (!sourceList.Eof) {
                conv(ref sourceList.CurrentRec, ref rec);
                targetList.Append(rec);
                sourceList.Advance();
            }
            sourceList.EndIteration();

            return targetList;
        }

        void IOSList.Sort(IComparer comparer) {
            if (_iterating) {
                throw new InvalidOperationException("Attempting to sort a list while it's being iterated");
            }

            InternalRecursiveSave();
            // _data.Sort(new TypedComparer<T>(comparer));
            ((IListWrapper<T>)_data).Sort(comparer);
            Reset();
        }

        protected static OtherType[] InnerToArray<OtherType>(OSList<T> recordlist, Func<T, OtherType> converter) {
            if (recordlist == null) {
                return new OtherType[0];
            }

            OtherType[] result = new OtherType[recordlist.Length];
            recordlist.StartIteration();
            while (!recordlist.Eof) {
                result[recordlist.CurrentRowNumber] = converter(recordlist.CurrentRec);
                recordlist.Advance();
            }
            recordlist.EndIteration();
            return result;
        }

        protected void InnerFromArray(T[] array) {
            if (array != null) {
                foreach (T item in array) {
                    Append(item);
                }
            }
        }

        protected void InnerFromArray<SourceType>(SourceType[] array, Func<SourceType, T> converter) {
            if (array != null) {
                foreach (SourceType item in array) {
                    Append(converter(item));
                }
            }
        }

        public RestList<OtherType> ToRestList<OtherType>(Func<T, OtherType> converter) {
            return new RestList<OtherType>(InnerToArray(this, converter), Empty ? converter(CurrentRec) : default(OtherType));
        }

        protected void InnerFromRestList<SourceType>(RestList<SourceType> restList, Func<SourceType, T> converter) {
            if (restList != null) {
                InnerFromArray(restList.list, converter);

                if (Empty) {
                    CurrentRec = converter(restList.emptyListItem);
                } else {
                    CurrentRec = this[0];
                }
            }
        }

        private List<T> ToList() {
            return ToList(null);
        }

        private List<T> ToList(Func<T, bool> filter) {
            List<T> result = new List<T>();

            StartIteration();
            try {
                while (!Eof) {
                    if (filter == null || filter(CurrentRec)) {
                        result.Add(CurrentRec);
                    }
                    Advance();
                }
            } finally {
                EndIteration();
            }

            return result;
        }

        public OSList<T> Filter(Func<T, bool> condition) {
            if (_iterating) {
                throw new InvalidOperationException("Attempting to filter a list while it's being iterated");
            }

            OSList<T> result = NewList();
            result.AllOptimizedAttributes = this.AllOptimizedAttributes;
            StartIteration();
            try {
                while (!Eof) {
                    if (condition(CurrentRec)) {
                        result.Append(CurrentRec);
                    }
                    Advance();
                }
            } finally {
                EndIteration();
            }

            result.OptimizedFields = this.OptimizedFields;
            return result;
        }

        public void Sort<T2>(Func<T, T2> by, bool ascending) {
            if (_iterating) {
                throw new InvalidOperationException("Attempting to sort a list while it's being iterated");
            }

            List<T> result = ToList();
            result.Sort((a, b) => {
                int value = ((IComparable)by(a)).CompareTo((IComparable)by(b));
                return ascending ? value : -value;
            });
            Clear();
            result.Apply(e => Append(e));
        }

        public bool All(Func<T, bool> condition) {
            if (_iterating) {
                throw new InvalidOperationException("Attempting use All on a list while it's being iterated");
            }
            StartIteration();
            try {
                while (!Eof) {
                    if (!condition(CurrentRec)) {
                        return false;
                    }
                    Advance();
                }
            } finally {
                EndIteration();
            }

            return true;
        }

        public bool Any(Func<T, bool> condition) {
            if (_iterating) {
                throw new InvalidOperationException("Attempting use Any on a list while it's being iterated");
            }

            return !All(v => !condition(v));
        }

        public int IndexOf(Func<T, bool> condition) {
            if (_iterating) {
                throw new InvalidOperationException("Attempting use IndexOf on a list while it's being iterated");
            }

            StartIteration();
            try {
                while (!Eof) {
                    if (condition(CurrentRec)) {
                        return CurrentRowNumber;
                    }
                    Advance();
                }
            } finally {
                EndIteration();
            }

            return -1;
        }
    }

    #region Legacy classes / interfaces
    // We need this interface for compatibility reasons. Some extensions
    // expect (and use!) the old RecordList class directly, e.g. for
    // reflection purposes, instead of the concrete record lists.
    public interface RecordList : IOSList {
        string OptimizedFields { get; set; }
        void Append(IRecord rec);
        IList<IRecord> Data { get; }
        void Set(int index, IRecord value);
        BitArray[] AllOptimizedAttributes { get; set; }
        BitArray[] GetDefaultOptimizedValues();
        RecordList Duplicate();
        RecordList Distinct();
        void AppendAll(RecordList recordsToAppend);
    }

    class ListWrapper<T> : IList<IRecord> where T : ITypedRecord<T> {
        private readonly GenericRecordList<T> owner;
        private IList<T> List {
            get { return owner.Data; }
        }

        public ListWrapper(GenericRecordList<T> owner) {
            this.owner = owner;
        }

        public int IndexOf(IRecord item) {
            return List.IndexOf((T)item);
        }

        public void Insert(int index, IRecord item) {
            List.Insert(index, (T)item);
        }

        public void RemoveAt(int index) {
            List.RemoveAt(index);
        }

        public IRecord this[int index] {
            get {
                return List[index];
            }
            set {
                List[index] = (T)value;
            }
        }

        public void Add(IRecord item) {
            List.Add((T)item);
        }

        public void Clear() {
            List.Clear();
        }

        public bool Contains(IRecord item) {
            return List.Contains((T)item);
        }

        public void CopyTo(IRecord[] array, int arrayIndex) {
            for (int i = 0; i < List.Count; i++) {
                array[i + arrayIndex] = List[i];
            }
        }

        public int Count {
            get { return List.Count; }
        }

        public bool IsReadOnly {
            get { return false; }
        }

        public bool Remove(IRecord item) {
            return List.Remove((T)item);
        }

        public IEnumerator<IRecord> GetEnumerator() {
            return List.Cast<IRecord>().GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator() {
            return List.GetEnumerator();
        }
    }

    class TypedComparer<T> : IComparer<T> {

        private readonly IComparer untypedComparer;

        public TypedComparer(IComparer untypedComparer) {
            this.untypedComparer = untypedComparer;
        }

        public int Compare(T x, T y) {
            return untypedComparer.Compare((T)x, (T)y);
        }
    }
    #endregion

    /// <summary>
    /// Class that implements basic recordlist behavior and 
    /// from which all other recordlists must derive.
    /// </summary>
    [Serializable()]
    public abstract class GenericRecordList<T> : OSList<T>, RecordList where T : ITypedRecord<T> {

        public GenericRecordList()
            : base() {
        }

        public GenericRecordList(IDisposable obj) : base(obj) {
        }

        void RecordList.Append(IRecord rec) {
            Append((T)rec);
        }

        void RecordList.AppendAll(RecordList recordsToAppend) {
            AppendAll((OSList<T>)recordsToAppend);
        }

        RecordList RecordList.Duplicate() {
            return (RecordList)Duplicate();
        }

        RecordList RecordList.Distinct() {
            return (RecordList)Distinct();
        }

        IList<IRecord> RecordList.Data {
            get {
                if (_data == null) {
                    return null;
                } else {
                    return new ListWrapper<T>(this);
                }
            }
        }

        public int Count {
            get {
                if (_data == null) {
                    return 0;
                } else {
                    return _data.Count;
                }
            }
        }

        void RecordList.Set(int index, IRecord value) {
            _data[index] = (T)value;
        }

        [Obsolete("Use the Default Constructor and set the Transaction afterwards.")]
        public GenericRecordList(IDbTransaction trans) : base(trans) { }

        [Obsolete("Use the Default Constructor and set the Transaction afterwards.")]
        public GenericRecordList(IDbTransaction trans, ReadDBMethodDelegate alternateReadDBMethod)
            : base(trans, alternateReadDBMethod) {
        }

        /// <summary>
        /// Create the object from serialized data.
        /// </summary>
        public GenericRecordList(SerializationInfo info, StreamingContext context)
            : base(info, context) {
        }
        [MethodImpl(MethodImplOptions.NoInlining)]
        protected override T DeepDuplicate(T value) {
            return (T)value.Duplicate();
        }

        public override object Current {
            get {
                return CurrentRec;
            }
        }

        protected override T ShallowDuplicate(T value) {
            return value;
        }

        protected override T Convert(object other) {
            T newValue = GetElementDefaultValue();
            newValue.FillFromOther((IRecord)other);
            return newValue;
        }

        public override void Read() {
            if (_reader != null) {
                if (alternateReadDBMethod == null) {
                    CurrentRec.ReadDB(_reader);
                } else {
                    alternateReadDBMethod(ref CurrentRec, _reader);
                }
                CurrentRec.AllOptimizedAttributes = AllOptimizedAttributes;
            } else if (_data != null) {
                CurrentRec.ReadIM(_data[_currentRowNumber]);
                CurrentRec.AllOptimizedAttributes = _data[_currentRowNumber].AllOptimizedAttributes;
                _saveRec = true;
                CurrentRec.RecursiveReset();
            }
        }

        public override void InternalRecursiveSave() {
            base.InternalRecursiveSave();
            CurrentRec.InternalRecursiveSave();
        }


        /// <summary>
        /// Performs a recursive reset
        /// </summary>
        public override void RecursiveReset() {
            Reset();
            CurrentRec.RecursiveReset();
            if (_data != null && _data.Count > _currentRowNumber) {
                CurrentRec.ReadIM(_data[_currentRowNumber]);
                CurrentRec.AllOptimizedAttributes = _data[_currentRowNumber].AllOptimizedAttributes;
            }
        }

        protected override T GetElementDefaultValue() {
            return default(T);
        }

        public override BitArray[] GetDefaultOptimizedValues() {
            return new BitArray[0];
        }
    }

    /// <summary>
    /// Class for lists of basic type.
    /// </summary>
    [Serializable()]
    public sealed class BasicTypeList<T> : OSList<T> {
        public BasicTypeList()
            : base() {
        }

        public BasicTypeList(IDisposable obj)
            : base(obj) {
        }

        [Obsolete("Use the Default Constructor and set the Transaction afterwards.")]
        public BasicTypeList(IDbTransaction trans, ReadDBMethodDelegate alternateReadDBMethod)
            : base(trans, alternateReadDBMethod) {
        }

        /// <summary>
        /// Create the object from serialized data.
        /// </summary>
        public BasicTypeList(SerializationInfo info, StreamingContext context)
            : base(info, context) {
        }
        [MethodImpl(MethodImplOptions.NoInlining)]
        protected override T DeepDuplicate(T value) {
            return value;
        }

        protected override T ShallowDuplicate(T value) {
            return value;
        }

        protected override T GetElementDefaultValue() {
            var typeT = typeof(T);
            if (typeT == typeof(string)) {
                return (T)((object)string.Empty);
            } else if (typeT == typeof(DateTime)) {
                return (T)((object)ScriptableBuiltInFunction.NullDate());
            }

            return default(T);
        }

        public override BitArray[] GetDefaultOptimizedValues() {
            return new BitArray[0];
        }

        public override void Read() {
            if (_reader != null) {
                if (alternateReadDBMethod == null) {
                    // TODO...
                    //CurrentRec.ReadDB(_reader);
                    throw new NotImplementedException();
                } else {
                    alternateReadDBMethod(ref CurrentRec, _reader);
                }
            } else if (_data != null) {
                CurrentRec = _data[_currentRowNumber];
                _saveRec = true;
            }
        }

        protected override OSList<T> NewList() {
            return new BasicTypeList<T>();
        }

        protected override T Convert(object other) {
            return (T)other;
        }

        /// <summary>
        /// Performs a recursive reset
        /// </summary>
        public override void RecursiveReset() {
            Reset();
            if (_data != null && _data.Count > _currentRowNumber) {
                CurrentRec = _data[_currentRowNumber];
            }
        }

        private static T SameTypeConverter(T elem) {
            return elem;
        }

        public T[] ToArray() {
            return ToArray<T>(this, SameTypeConverter);
        }

        public static T[] ToArray(BasicTypeList<T> rl) {
            return ToArray<T>(rl, SameTypeConverter);
        }

        public OtherType[] ToArray<OtherType>(Func<T, OtherType> converter) {
            return ToArray<OtherType>(this, converter);
        }

        public static OtherType[] ToArray<OtherType>(BasicTypeList<T> rl, Func<T, OtherType> converter) {
            return InnerToArray(rl, converter);
        }

        public static BasicTypeList<T> ToList(T[] array) {
            return ToList<T>(array, SameTypeConverter);
        }

        public static BasicTypeList<T> ToList<OtherType>(OtherType[] array, Func<OtherType, T> converter) {
            BasicTypeList<T> rl = new BasicTypeList<T>(null);
            if (array != null) {
                foreach (OtherType item in array) {
                    rl.Append(converter(item));
                }
            }
            return rl;
        }

        public RestList<T> ToRestList() {
            return new RestList<T>(ToArray(), Empty ? CurrentRec : default(T));
        }

        public static BasicTypeList<T> FromRestList(RestList<T> restList) {
            return FromRestList(restList, SameTypeConverter);
        }

        public static BasicTypeList<T> FromRestList<SourceType>(RestList<SourceType> restList, Func<SourceType, T> converter) {
            BasicTypeList<T> result = new BasicTypeList<T>();
            result.InnerFromRestList(restList, converter);
            return result;
        }

        public static implicit operator T[] (BasicTypeList<T> rl) {
            return ToArray(rl);
        }

        public static implicit operator BasicTypeList<T>(T[] array) {
            return ToList(array);
        }
    }
}
