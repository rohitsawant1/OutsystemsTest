/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using OutSystems.Internal.Db;
using OutSystems.ObjectKeys;
using OutSystems.RuntimeCommon;

namespace OutSystems.HubEdition.RuntimePlatform.Processes {

    public abstract class BPMRuntime {

        public abstract ActivityKind Kind { get; }
        public abstract string Name { get; }
        public abstract IProcess GetCurrentProcess();

        protected bool CloseActivityInstance(HeContext heContext, int activityId, bool terminateProcess, out bool processEnded) {
            processEnded = false;
            bool notAlreadyClosed;

            using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                int tenantId = heContext.AppInfo.Tenant.Id;
                int processId = GetCurrentProcess().ProcessId;
                ActivityStatus currentStatus;

                using (IDataReader reader = DBRuntimePlatform.Instance.GetActivity(trans, tenantId, activityId, false)) {
                    if (reader.Read()) {
                        currentStatus = (ActivityStatus) reader.SafeGet<int>("STATUS_ID");
                    } else {
                        throw new InvalidOperationException("Could not close activity '" + Name + "' (#" + activityId 
                            + ") because the activity does not exist.");
                    }
                }

                notAlreadyClosed = !currentStatus.IsTerminal();

                // If it's a terminating node
                if (Kind.IsTerminal()) {
                    DBRuntimePlatform.Instance.GetProcessForUpdate(trans, tenantId, processId).SafeClose();
                    if (notAlreadyClosed) {
                        InnerSetActivityStatus(heContext, processId, activityId, ActivityStatus.Closed);
                    }

                    if ((DBRuntimePlatform.Instance.CountBlockingNonTerminatedActivities(trans, tenantId, processId) == 0)) {
                        CloseProcessInstance(heContext, GetCurrentProcess(), processId, false);
                        processEnded = true;
                    } else if (terminateProcess) {
                        TerminateProcessInstance(heContext, GetCurrentProcess(), processId);
                    }
                } else {
                    if (notAlreadyClosed) {
                        InnerSetActivityStatus(heContext, processId, activityId, ActivityStatus.Closed);
                    }
                }
            }

            return notAlreadyClosed;
        }

        /// <summary>
        /// Closes a process, all its activities and sets the parent activity (if any) to execute
        /// </summary>
        /// <param name="heContext"></param>
        /// <param name="processDefiniton">Instance of the process to close, can be a dummy instance</param>
        /// <param name="processId">Id of the process, cannot be dummy</param>
        /// <param name="manualTerminate"></param>
        private static void CloseProcessInstance(HeContext heContext, IProcess processDefiniton, int processId, bool manualTerminate) {
            using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                int tenantId = heContext.AppInfo.Tenant.Id;
                List<Pair<int, ObjectKey>> nonTerminatedActivities = new List<Pair<int, ObjectKey>>();
                int userId = manualTerminate? heContext.Session.UserId: 0;
                int parentActivityId = 0;
                ProcessStatus processStatus = ProcessStatus.Unknown;

                using (IDataReader reader = DBRuntimePlatform.Instance.GetProcessForUpdate(trans, tenantId, processId)) {
                    if (reader.Read()) {
                        parentActivityId = reader.SafeGet<int>("PARENT_ACTIVITY_ID");
                        processStatus = (ProcessStatus) reader.SafeGet<int>("STATUS_ID");
                    } else {
                        throw new InvalidOperationException("Could not close process #" + processId + " because the process does not exist.");
                    }
                }

                using (IDataReader reader = DBRuntimePlatform.Instance.GetNonTerminatedActivities(trans, tenantId, processId)) {
                    while (reader.Read()) {
                        nonTerminatedActivities.Add(Pair.Create(reader.SafeGet<int>("ID"), ObjectKey.Parse(reader.SafeGet<string>("SS_Key"))));
                    }
                }

                foreach (var nonTerminatedActivity in nonTerminatedActivities) {
                    //Change all the pending activity status WITHOUT any commits
                    InnerSetActivityStatus(heContext, processId, nonTerminatedActivity.First, ActivityStatus.Closed, manualTerminate? heContext.Session.UserId: userId);

                    IProcessActivity activityToClose;
                    if (processDefiniton.GetProcessActivityInstance(processId, nonTerminatedActivity.First, nonTerminatedActivity.Second, false, out activityToClose)) {
                        //We cant call the StartRemoveEventFilters here because that would make an implicit commit
                        ((ProcessBase.AbstractProcessActivityBase) activityToClose).RemoveEventFilters(heContext);
                    }
                }

                if (processStatus == ProcessStatus.Closed) {
                    return;
                }

                if (parentActivityId != 0) {
                    int parentTenantId;
                    DBRuntimePlatform.Instance.GetParentProcessId(trans, parentActivityId, out parentTenantId);

                    //Change status of parent activity and reschedule it
                    DBRuntimePlatform.Instance.UpdateActivity(trans, parentTenantId, parentActivityId, null, null, null, null, null, null, null,
                        ActivityStatus.Closing, null, null, null, null, true, null, null, null, null, null, null);
                }

                DBRuntimePlatform.Instance.SetProcessStatus(trans, tenantId, processId, ProcessStatus.Closed, userId);
            }
        }

        /// <summary>
        /// Closes a process, all its activities and sets the parent activity (if any) to execute
        /// </summary>
        /// <param name="heContext"></param>
        /// <param name="processDefiniton">Instance of the process to close, can be a dummy instance</param>
        /// <param name="processId">Id of the process, cannot be dummy</param>
        /// <param name="recursive"></param>
        private static void TerminateProcessInstance(HeContext heContext, IProcess processDefiniton, int processId, bool recursive) {
            using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                int tenantId = heContext.AppInfo.Tenant.Id;
                int parentActivityId = 0;
                List<Pair<int, ObjectKey>> nonTerminatedActivities = new List<Pair<int, ObjectKey>>();
                ProcessStatus processStatus = ProcessStatus.Unknown;

                using (IDataReader reader = DBRuntimePlatform.Instance.GetProcessForUpdate(trans, tenantId, processId)) {
                    if (reader.Read()) {
                        parentActivityId = reader.SafeGet<int>("PARENT_ACTIVITY_ID");
                        processStatus = (ProcessStatus) reader.SafeGet<int>("STATUS_ID");
                    } else {
                        throw new InvalidOperationException("Could not close process #" + processId + " because the process does not exist.");
                    }
                }

                using (IDataReader reader = DBRuntimePlatform.Instance.GetNonTerminatedActivities(trans, tenantId, processId)) {
                    while (reader.Read()) {
                        nonTerminatedActivities.Add(Pair.Create(reader.SafeGet<int>("ID"), ObjectKey.Parse(reader.SafeGet<string>("SS_Key"))));
                    }
                }

                foreach (var nonTerminatedActivity in nonTerminatedActivities) {
                    IProcessActivity activityToClose;
                    if (processDefiniton.GetProcessActivityInstance(processId, nonTerminatedActivity.First, nonTerminatedActivity.Second, false, out activityToClose)) {
                        bool success = activityToClose.TerminateActivity(heContext, recursive);
                        if (!success)
                            throw new InvalidOperationException("Could not terminate activity " + activityToClose.ActivityId);
                    }
                }

                if (processStatus == ProcessStatus.Closed || processStatus == ProcessStatus.Terminated) {
                    return;
                }

                if (parentActivityId != 0) {
                    int parentTenantId;
                    DBRuntimePlatform.Instance.GetParentProcessId(trans, parentActivityId, out parentTenantId);

                    DBRuntimePlatform.Instance.UpdateActivity(trans, parentTenantId, parentActivityId, null, null, null, null, null, null, null,
                        ActivityStatus.Closing, null, null, null, null, true, null, null, null, null, null, null);
                }

                DBRuntimePlatform.Instance.SetProcessStatus(trans, tenantId, processId, ProcessStatus.Terminated, heContext.Session.UserId);
            }
        }

        protected virtual void SetCurrentProcessInfo(int processId, int activityId, int precedentActivityId, int precedentActivitySuccessorsCount,  int rootProcessId) {
            Debugger.SetCurrentProcessInfo(processId, activityId, precedentActivityId, precedentActivitySuccessorsCount, rootProcessId);
        }

        protected void StartActivityExecution(HeContext heContext, int activityId, int processId, out bool runnable, out ActivityStatus currentStatus) {
            StartActivityExecution(heContext, activityId, processId, null, out runnable, out currentStatus);
        }

        protected void StartActivityExecution(HeContext heContext, int activityId, int processId, ActivityStatus? forInitialStatus, out bool runnable, out ActivityStatus currentStatus) {
            StartActivityExecution(heContext, activityId, processId, null, out runnable, out currentStatus, BuiltInFunction.NullDate());
        }

        protected void StartActivityExecution(HeContext heContext, int activityId, int processId, ActivityStatus? forInitialStatus, out bool runnable, out ActivityStatus currentStatus, DateTime previousNextRun) {
            runnable = false;

            using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                int tenantId = heContext.AppInfo.Tenant.Id;
                int precedentActivityId;
                int precedentActivitySuccessorsCount;
                int rootProcessId;
                if (Debugger.IsRunning) {
                    rootProcessId = DBRuntimePlatform.Instance.GetTopProcessId(trans, processId);
                    precedentActivityId = DBRuntimePlatform.Instance.GetPrecedentActivityId(trans, activityId);
                    if (precedentActivityId == BuiltInFunction.NullIdentifier() && rootProcessId != processId) {
                        // the precendent activity is the activity that launched the subprocess. We need to get
                        // an activity from the same eSpace we're in, because external processes are not executed
                        // in the same web app (contrary to what happens when debugging reference actions, whose code
                        // is all in the consumer eSpace)
                        precedentActivityId = DBRuntimePlatform.Instance.GetAncestorActivityIdInTenant(trans, processId, tenantId);
                    }

                    precedentActivitySuccessorsCount = DBRuntimePlatform.Instance.GetActivitySuccessorsCount(trans, precedentActivityId);
                } else {
                    rootProcessId = 0;
                    precedentActivityId = -1;
                    precedentActivitySuccessorsCount = 0;
                }
                SetCurrentProcessInfo(processId, activityId, precedentActivityId, precedentActivitySuccessorsCount, rootProcessId);
                                
                if (DBRuntimePlatform.Instance.GetProcessStatus(trans, processId) == ProcessStatus.Suspended) {
                    throw new InvalidOperationException("Could not execute a built-in/extended action on activity '" + Name + "' (#" + activityId
                                                        + ") because its process is suspended.");
                }

                using (IDataReader reader = DBRuntimePlatform.Instance.GetActivity(trans, tenantId, activityId, true)) {
                    if (reader.Read()) {

                        DateTime nextRun = (DateTime) reader.SafeGet<DateTime>("NEXT_RUN");
                        currentStatus = (ActivityStatus) reader.SafeGet<int>("STATUS_ID");

                        DateTime isRunningSince = reader.SafeGet<DateTime>("IS_RUNNING_SINCE", BuiltInFunction.NullDate());

                        runnable = IsRunnableActivity(isRunningSince, forInitialStatus, currentStatus, previousNextRun, nextRun);

                    } else {
                        throw new InvalidOperationException("Could not execute a built-in/extended action on activity '" + Name + "' (#" + activityId
                                                            + ") because the activity does not exist.");
                    }
                }

                if (runnable) {
                    DBRuntimePlatform.Instance.UpdateActivity(trans, tenantId, activityId, null, null, null, null, null, null, null, null,
                        true, RuntimeEnvironment.MachineName, null, null, null, null, null, null, null, null, null);
                }
            }

            DatabaseAccess.CommitAllTransactions();
        }

        public static bool IsRunnableActivity(DateTime isRunningSince, ActivityStatus? forInitialStatus, ActivityStatus currentStatus, DateTime previousNextRun, DateTime nextRun) {
            //#605602 - Ensure the activity is not already running "isRunningSince"
            //Ensure the conditions that made the scheduler request the activity to run have not changed. "currentStatus" and "nextRun"
            bool runnable = (isRunningSince == BuiltInFunction.NullDate())
                && (!forInitialStatus.HasValue || forInitialStatus.Value == currentStatus)
                && (previousNextRun == BuiltInFunction.NullDate() ||
                    //#1188860 - To avoid issues with daylight saving time, use universal time to compare the two date times
                    (Math.Abs((previousNextRun.ToUniversalTime() - nextRun.ToUniversalTime()).TotalMilliseconds) < 1));

            return runnable;
        }


        protected void EndActivityExecution(HeContext heContext, int activityId) {
            EndActivityExecution(heContext, activityId, false, null, false, null);            
        }

        protected void EndActivityExecution(HeContext heContext, int activityId, bool reschedule, DateTime? explicitNextRun, bool hasError, string errorId) {
            Debugger.CleanCurrentProcessInfo(false);

            using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                DBRuntimePlatform.Instance.UpdateActivity(trans, heContext.AppInfo.Tenant.Id, activityId, null, null, null, null, null, null, null, null,
                    false, string.Empty, hasError, errorId, (reschedule? (explicitNextRun != null? false: true): (bool?) null), explicitNextRun, null, null, null, null, null);

            }

            DatabaseAccess.CommitAllTransactions();
        }

        /// <summary>
        /// Changes the status of an activity and commits the transaction.
        /// Should not be used inside the BPMRuntime
        /// </summary>
        /// <param name="heContext"></param>
        /// <param name="activityId"></param>
        /// <param name="status"></param>
        protected void SetActivityStatus(HeContext heContext, int activityId, ActivityStatus status) {
            InnerSetActivityStatus(heContext, GetCurrentProcess().ProcessId, activityId, status);
            DatabaseAccess.CommitAllTransactions();
        }

        public static void DiscardActivity(HeContext heContext, int activityId) {
            using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                InnerSetActivityStatus(heContext,
                    DBRuntimePlatform.Instance.GetActivityClosedBy(trans, activityId),
                    activityId, ActivityStatus.Discarded);
            }
        }

        protected static void InnerSetActivityStatus(HeContext heContext, int processId, int activityId, ActivityStatus status) {
            InnerSetActivityStatus(heContext, processId, activityId, status, heContext.Session.UserId);
        }

        protected static void InnerSetActivityStatus(HeContext heContext, int processId, int activityId, ActivityStatus status, int userIdForLog) {
            using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                int tenantId = heContext.AppInfo.Tenant.Id;

                bool? opened = null;
                bool? closed = null;
                bool? hasError = null; //no change unless it's a close

                if (status == ActivityStatus.Open) {
                    opened = true;
                } else if (status == ActivityStatus.Closed) {
                    closed = true;
                    hasError = false;
                }

                DBRuntimePlatform.Instance.UpdateActivity(trans, tenantId, activityId, null, null, null, null, null, opened, closed, status,
                    null, null, hasError, null, (closed != null? false: (bool?) null), null, null, null, null, null, null);
            }
        }

        public static int CreateActivityInstance(HeContext heContext, ObjectKey espaceSSKey, ObjectKey activitySSKey, int precedentActivityId, string precedentOutcome) {
            using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                int tenantId = heContext.AppInfo.Tenant.Id;

                int activityDefId;
                string activityDefName;

                using (IDataReader reader = DBRuntimePlatform.Instance.GetActivityDefinition(trans, activitySSKey, espaceSSKey)) {
                    if (reader.Read()) {
                        activityDefId = reader.SafeGet<int>("ID");
                        activityDefName = reader.SafeGet<string>("NAME");
                    } else {
                        throw new DataBaseException("No activity definition exists with key '" + activitySSKey + "'.");
                    }
                }

                int processId;
                
                using (IDataReader reader = DBRuntimePlatform.Instance.GetActivity(trans, tenantId, precedentActivityId, false)) {
                    if (reader.Read()) {
                        processId = reader.SafeGet<int>("PROCESS_ID");
                    } else {
                        throw new InvalidOperationException("Process precedent activity #" + precedentActivityId + " does not exist.");
                    }
                }

                return CreateActivityInstance(heContext, trans, tenantId, activityDefId, processId, activityDefName, precedentActivityId, precedentOutcome);
            }
        }

        public static int CreateProcessInstance(HeContext heContext, int tenantId, ObjectKey espaceSSKey, ObjectKey processSSKey, int parentActivityId, int parentProcessId, out Pair<int, ObjectKey> startActivity) {
            int startActivityId;
            ObjectKey activityDefKey;
            int newProcessId;
            
            using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                int processDefId = 0;
                int topProcessId = 0;
                int createdBy = 0;
                
                using (IDataReader reader = DBRuntimePlatform.Instance.GetProcessDefinition(trans, processSSKey, espaceSSKey)) {
                    if (reader.Read()) {
                        processDefId = reader.SafeGet<int>("ID");
                    } else {
                        throw new DataBaseException("No process definition exists with key '" + processSSKey + "'.");
                    }
                }


                if (parentActivityId != BuiltInFunction.NullIdentifier()) {
                    int parentTenantId;
                    parentProcessId = DBRuntimePlatform.Instance.GetParentProcessId(trans, parentActivityId, out parentTenantId);
                }

                if (parentProcessId != BuiltInFunction.NullIdentifier()) {
                    topProcessId = DBRuntimePlatform.Instance.GetTopProcessId(trans, parentProcessId);
                } else {
                    // Is not sub-process so we need to set the CreatedBy field
                    createdBy = heContext.Session.UserId;
                }

                newProcessId = DBRuntimePlatform.Instance.CreateProcess(trans, tenantId, createdBy, processDefId, parentProcessId, parentActivityId, topProcessId, ProcessStatus.Active);

                int activityDefId = 0;                
                string activityDefName;

                using (IDataReader reader = DBRuntimePlatform.Instance.GetActivityDefinitionsForKind(trans, newProcessId, ActivityKind.Start)) {
                    if (reader.Read()) {
                        activityDefId = reader.SafeGet<int>("ID");
                        activityDefKey = ObjectKey.Parse(reader.SafeGet<string>("SS_KEY"));
                        activityDefName = reader.SafeGet<string>("NAME", string.Empty);
                    } else {
                        throw new DataBaseException("No active " + ActivityKind.Start.ToString() + " activity exists for process #" + newProcessId + ".");
                    }
                }

                startActivityId = CreateActivityInstance(heContext, trans, tenantId, activityDefId, newProcessId, activityDefName, 0, null);
            }

            startActivity = Pair.Create(startActivityId, activityDefKey);

            return newProcessId;
        }

        protected void ReleaseActivity(HeContext heContext, int activityId, bool resetActivityUser) {
            using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                int tenantId = heContext.AppInfo.Tenant.Id;

                int activityDefId = 0;

                using (IDataReader reader = DBRuntimePlatform.Instance.GetActivity(trans, tenantId, activityId, false)) {
                    if (reader.Read()) {
                        activityDefId = reader.SafeGet<int>("ACTIVITY_DEF_ID");
                    } else {
                        throw new DataBaseException("No activity instance found for ActivityId = " + activityId + " with TentantId = " + tenantId);
                    }
                }

                ActivityKind activityDefKind = DBRuntimePlatform.Instance.GetActivityDefinitionKind(trans, activityDefId);

                // Must be an open Human Activity
                if (activityDefKind != ActivityKind.HumanActivity) {
                    throw new InvalidOperationException("Cannot release activity '" + Name + "' (#" + activityId + ") because it's not an open human activity.");
                }

                DBRuntimePlatform.Instance.UpdateActivity(trans, tenantId, activityId, null, null, null, (resetActivityUser? 0: (int?) null),
                    null, false, null, ActivityStatus.Ready, null, null, null, null, null, null, null, null, null, null, null);
            }

            DatabaseAccess.CommitAllTransactions();
        }
        
        protected void ScheduleActivity(HeContext heContext, int activityId, DateTime startDate) {
            using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                int tenantId = heContext.AppInfo.Tenant.Id;

                int activityDefId;

                using (IDataReader reader = DBRuntimePlatform.Instance.GetActivity(trans, tenantId, activityId, false)) {
                    if (reader.Read()) {
                        activityDefId = reader.SafeGet<int>("ACTIVITY_DEF_ID");
                    } else {
                        throw new InvalidOperationException("Activity '" + Name + "' (#" + activityId + ") does not exist.");
                    }
                }

                ActivityKind activityDefKind = DBRuntimePlatform.Instance.GetActivityDefinitionKind(trans, activityDefId);

                // Must be an open Human Activity
                if (activityDefKind != ActivityKind.HumanActivity) {
                    throw new InvalidOperationException("Cannot release activity '" + Name + "' (#" + activityId + ") because it's not an open human activity.");
                }

                DBRuntimePlatform.Instance.UpdateActivity(trans, tenantId, activityId, null, null, null, null, null, null, null,
                    ActivityStatus.Scheduled, null, null, null, null, false, startDate, null, null, null, null, null);
            }

            DatabaseAccess.CommitAllTransactions();
        }

        protected bool HasActiveActivityInProcess(HeContext heContext, ObjectKey activitySSKey, int processId) {
            using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                int tenantId = heContext.AppInfo.Tenant.Id;

                return DBRuntimePlatform.Instance.HasActiveActivityInProcess(trans, tenantId, activitySSKey, processId);
            }
        }

        public static void TerminateProcessInstance(HeContext heContext, IProcess processDefinition, int processId) {
            ProcessStatus currentStatus;

            using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                currentStatus = DBRuntimePlatform.Instance.GetProcessStatus(trans, processId);
            }

            if (currentStatus != ProcessStatus.Closed && currentStatus != ProcessStatus.Terminated) {
                TerminateProcessInstance(heContext, processDefinition, processId, true);
            }
        }

        public static void SuspendProcessInstance(HeContext heContext, int processId, bool suspend) {
            ProcessStatus currentStatus;
            
            using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                int tenantId = heContext.AppInfo.Tenant.Id;
                currentStatus = DBRuntimePlatform.Instance.GetProcessStatus(trans, processId);


                if (suspend && currentStatus == ProcessStatus.Active) {
                    DBRuntimePlatform.Instance.SetProcessStatus(trans, tenantId, processId, ProcessStatus.Suspended, heContext.Session.UserId);
                } else if (!suspend && currentStatus == ProcessStatus.Suspended) {
                    DBRuntimePlatform.Instance.SetProcessStatus(trans, tenantId, processId, ProcessStatus.Active, heContext.Session.UserId);
                    DBRuntimePlatform.Instance.RemoveSuspendedProcessUpgradeData(trans, processId);
                }
            }

            if(currentStatus == ProcessStatus.Closed) {
                throw new InvalidOperationException("Cannot " + (suspend ? "suspend" : "release") + " the process #" + processId 
                    + " because it is already closed.");
            }
        }

        protected string ProcessException(HeContext heContext, Exception e, bool skipLog) {
            return ProcessBase.ProcessException(heContext, e, String.Empty, skipLog);
        }

        protected string ProcessException(HeContext heContext, Exception ex, bool skipLog, out string errorId) {
            return ProcessBase.ProcessException(heContext, ex, string.Empty, skipLog, out errorId);
        }

        // utils
        public static void GetActivityDataForWS(int activityId, out int processId, out ActivityKind activityKind, out string activityName, out string SSKey, out string url, out int tenantId, out string espaceKey) {
            string EspaceName;
            string ProcessName;
            GetActivityDataForWS(activityId, out processId, out activityKind, out activityName, out SSKey, out url, out tenantId, out EspaceName, out ProcessName, out espaceKey);
        }


        public static void GetActivityDataForWS(int activityId, out int processId, out ActivityKind activityKind, out string activityName, out string SSKey, out string url, out int tenantId, out string EspaceName, out string processName, out string espaceKey) {
            using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                using (IDataReader reader = DBRuntimePlatform.Instance.GetActivityDataForWS(trans, activityId)) {
                    if (reader.Read()) {
                        EspaceName = Convert.ToString(reader["ESpace_Name"]);
                        SSKey = Convert.ToString(reader["SS_Key"]);
                        tenantId = reader.SafeGet<int>("Tenant_Id");
                        processId = reader.SafeGet<int>("Process_Id");
                        activityKind = (ActivityKind) reader.SafeGet<int>("ActivityKind");
                        activityName = Convert.ToString(reader["ActivityName"]);
                        processName = Convert.ToString(reader["ProcessName"]);
                        espaceKey = Convert.ToString(reader["ESPACE_KEY"]);
                    } else {
                        throw new DataBaseException("Activity #" + activityId + " does not exist.");
                    }
                }
            }

            url = GetUrlForWS(ObjectKey.Parse(espaceKey), EspaceName);
        }


        public static void GetProcessDataForWS(HeContext heContext, ObjectKey SSKey, ObjectKey eSpaceSSKey, out string url) {
            string EspaceName;
            
            using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                using (IDataReader reader = DBRuntimePlatform.Instance.GetProcessDataForWS(trans, SSKey, eSpaceSSKey)) {
                    if (reader.Read()) {
                        EspaceName = Convert.ToString(reader["ESpace_Name"]);
                    } else {
                        throw new DataBaseException("Process Definition does not exist.");
                    }
                }
            }

			url = GetUrlForWS(eSpaceSSKey, EspaceName);
        }

        public static void GetProcessDataForWS(int processId, out string SSKey, out string url, out int tenantId, out string eSpaceKey) {
            string EspaceName;

            using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                using (IDataReader reader = DBRuntimePlatform.Instance.GetProcessDataForWS(trans, processId)) {
                    if (reader.Read()) {
                        EspaceName = Convert.ToString(reader["ESpace_Name"]);
                        SSKey = Convert.ToString(reader["SS_Key"]);
                        tenantId = reader.SafeGet<int>("Tenant_Id");
                        eSpaceKey = Convert.ToString(reader["ESPACE_KEY"]);
                    } else {
                        throw new DataBaseException("Process #" + processId + " does not exist.");
                    }
                }
            }

			url = GetUrlForWS(ObjectKey.Parse(eSpaceKey), EspaceName);
        }

        private static string GetUrlForWS(ObjectKey eSpaceKey, string eSpaceName) {
            return $"{Internal.DeploymentZoneResolution.ByModuleKeyWithScheme(eSpaceKey)}/{eSpaceName}/";
        }


        public static IEnumerable<int> GetAllowedActivities(HeContext heContext, Transaction tran, IEnumerable<int> activityIds, int userId) {
            foreach (var nextId in activityIds) {
                int assignedUser;
                ActivityStatus statusId;
                bool needsPermission = DBRuntimePlatform.Instance.NeedsActivityPermissions(tran, nextId, out assignedUser, out statusId);


                if (assignedUser != BuiltInFunction.NullIdentifier()) {
                    if (assignedUser != userId) {
                        continue;
                    }

                } else {
                    
                    if (statusId != ActivityStatus.Ready) {
                        continue;
                    }

                    if (needsPermission) {
                        var roles = DBRuntimePlatform.Instance.GetActivityRoles(tran, nextId);
                        if (!roles.Any(role => GenericExtendedActions.Check(heContext, role.First, userId, role.Second))) {
                            continue;
                        }
                    }
                }

                yield return nextId;
            }
        }

        public static int GetNextHumanActivity(HeContext heContext, Transaction tran, IEnumerable<Pair<int, ActivityKind>> nextActivities, int userId) {

            var humanActivitiesIds = nextActivities.Where(pair => pair.Second == ActivityKind.HumanActivity)
                                       .Select(pair => pair.First);

            if (!humanActivitiesIds.IsEmpty()) {
                return BPMRuntime.GetAllowedActivities(heContext, tran, humanActivitiesIds, userId).FirstIfSingleOrDefault();
            }
            return BuiltInFunction.NullIdentifier();
        }

        // private actions
        private static int CreateActivityInstance(HeContext heContext, Transaction tran, int tenantId, int activityDefId, int processId,
            string activityDefName, int precedentActivityId, string precedentOutcome) {

                //dvn: adquire exclusive lock on process instance to avoid lock progression S -> X later on that can lead to deadlocks
                DBRuntimePlatform.Instance.GetProcessForUpdate(tran, tenantId, processId).SafeClose();

                int createdActivityId = DBRuntimePlatform.Instance.CreateActivity(tran, tenantId, activityDefId, processId, activityDefName, 0,
                precedentActivityId, precedentOutcome, null, null);

            return createdActivityId;
        }

        public static void FlushPendingActivityEvent(int activityId, out int processedEvents) {
            FlushPendingActivityEvent(AppInfo.GetAppInfo()?.OsContext, activityId, out processedEvents);
        }

        public static void FlushPendingActivityEvent(HeContext heContext, int activityId, out int processedEvents){
            if (activityId == 0) {
                processedEvents = 0;
                return;
            }
            
            processedEvents = 0;

            int eId =0;
            int eActivityId = 0;
            string eDataId = "";

            using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetCommitableTransaction()) {
                using (IDataReader reader = DBRuntimePlatform.Instance.DequeueNormalEventForFrontend(trans, 1, activityId, "")) {
                    if (reader.Read()) {
                        eId = reader.SafeGet<int>("Id");
                        eActivityId = reader.SafeGet<int>("Activity_Id");
                        eDataId = reader.SafeGet<string>("Data_Id");
                    }
                }
                trans.Commit();
            }

            if (eId == 0) {
                // No pending event
                return;
            }
            
            try{
                string url;
                int tenantId;
                int processId;
                ActivityKind activityKind;
                string activityName;
                string SSKey;
                string espaceKey;
                BPMRuntime.GetActivityDataForWS(eActivityId, out processId, out activityKind, out activityName, out SSKey, out url, out tenantId, out espaceKey);

                
                int timeoutInSecs = 0;
                if (Debugger.IsRunning) {
                    timeoutInSecs = Debugger.REQUEST_TIMEOUT_IN_SECONDS;
                } else {
                    timeoutInSecs = RuntimePlatformSettings.BPT.ActivitiesTimeout.GetValue();
                }
                using (IActivityHandler activityHandler = ActivityHandlerFactory.Current.GetActivityHandler(url, tenantId, heContext?.Session?.UserId ?? 0, heContext?.AppInfo?.eSpaceUID ?? string.Empty, espaceKey)) {
                    activityHandler.Timeout = (int)(1.2 * timeoutInSecs) * 1000;
                    activityHandler.ExecuteOnEvent(SSKey, eActivityId, processId, tenantId, eDataId, /*advanceProcess*/true);
                }

                using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetCommitableTransaction()) {
                    DBRuntimePlatform.Instance.DeleteEvent(trans, eId);
                    processedEvents = 1;
                    trans.Commit();
                }
            } catch {
                using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetCommitableTransaction()) {
                    DBRuntimePlatform.Instance.RequeueEvent(trans, eId, true);
                    trans.Commit();
                }
            }
        }
    }
}
