/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections.Generic;
using System.Data;
using OutSystems.ObjectKeys;
using OutSystems.HubEdition.RuntimePlatform.Processes;
using OutSystems.RuntimeCommon;
using System.Linq;
using OutSystems.HubEdition.RuntimePlatform.Db;
using OutSystems.Internal.Db;

namespace OutSystems.HubEdition.RuntimePlatform.Processes {

    public abstract partial class ProcessBase {
        public abstract class AbstractProcessActivityBase : BPMRuntime, IProcessActivity {
            protected abstract GlobalObjectKey GlobalKey { get; }

            public static readonly int DummyId = ProcessBase.DummyId;

            private readonly bool isRunning;
            /// <summary>
            /// Dummys are precendent activities that did execute in the current flow.
            /// Mostly they are caused by changes in the process with running instances
            /// </summary>
            /// <returns>Returns true if the activity is dummy, false otherwise</returns>
            protected bool IsDummy {
                get { return DummyId == ActivityId; }
            }

            /// <summary>
            /// An activity is set as running if is creeated to be executed,
            /// either on the ActivitiesHandler or after a precedent activity finishes
            /// </summary>
            /// <returns>Returns true if the activity is running, false otherwise</returns>
            protected bool IsRunning {
                get { return isRunning; }
            }

            protected virtual string ActivityUrl(HeContext heContext, string sessionId, bool requestIsSecure, string hostname) {
                return string.Empty;
            }

            protected AbstractProcessActivityBase(int processId, int activityId, bool isRunning) {
                this.processId = processId;
                this.activityId = activityId;
                this.isRunning = isRunning;
            }

            //AbstractProcessActivity interface
            protected abstract bool GetProcessActivityInstance(int processId, int activityId, ObjectKey activityKey, bool isRunning, out IProcessActivity instance);
            protected abstract IEnumerable<Triplet<int, ActivityKind, ObjectKey>> ActivateNextActivities(HeContext heContext);
            protected abstract void ExecuteMethod(HeContext heContext);

            protected virtual void AfterProcessEnded(HeContext heContext) { }

            protected abstract void SetActivityPreparationParameters(HeContext heContext);
            protected abstract void SetActivityParameters(HeContext heContext, ActivityStatus currentStatus, ref ActivityStatus nextStatus);
            
            protected abstract List<ActivityStatus> GetNextStatus(ActivityStatus currentStatus);

            protected virtual bool OnCloseTerminatesProcess { get { return false; } }
            protected bool OnCloseCreatesDuplicate { get { return Kind.IsListener(); } }
            
            protected abstract IEnumerable<Triplet<int, ActivityKind, ObjectKey>> CloseDuplicate(HeContext heContext);

            protected virtual void OnReadyCallback(HeContext heContext) { }
            protected virtual void OnStartCallback(HeContext heContext) { }
            protected virtual void OnCloseCallback(HeContext heContext) { }
            protected virtual void OnSkipCallback(HeContext heContext) { }

            protected virtual string ProcessType {
                get { return null; }
            }

            protected virtual ProcessBase CurrentProcessInstance {
                get { return null; }
            }

            protected virtual ObjectKey CurrentEspaceKey {
                get { return null; }
            }

            public virtual void PushDebuggerStack() {
                if (!RunningInfo.DebugMode) {
                    return;
                }

                int parentActivityId, parentProcessId, tenantId;
                string key, parentEspaceKey, name, url, espaceName, processName, processDetail;
                IProcessActivity parentActivity;
                ActivityKind kind;
                bool hasParent;
                List<Triplet<string, string, string>> foreign;

                using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                    foreign = new List<Triplet<string, string, string>>();

                    hasParent = DBRuntimePlatform.Instance.HasParentProcess(trans, CurrentProcessInstance.ProcessId, out parentProcessId, 
                        out parentActivityId, out parentEspaceKey, out key);

                    processDetail = DBRuntimePlatform.Instance.GetProcessLabel(trans, CurrentProcessInstance.ProcessId);
                    if (processDetail.Length > 0) {
                        processDetail = " \"" + processDetail + "\"";
                    }

                    while (hasParent && (parentEspaceKey != CurrentEspaceKey.AsGuid.ToString())) {
                        GetActivityDataForWS(parentActivityId, out parentProcessId, out kind, out name, out key, out url, out tenantId, out espaceName, 
                            out processName, out string espaceKey);
                        
                        foreign.Add(new Triplet<string, string, string>(parentEspaceKey, espaceName, processName));

                        hasParent = DBRuntimePlatform.Instance.HasParentProcess(trans, parentProcessId, out parentProcessId, out parentActivityId, 
                            out parentEspaceKey, out key);
                    }
                }
                if (hasParent) {
                    _GetProcessActivityImplementation(parentProcessId, parentActivityId, ObjectKey.Parse(key), false, out parentActivity);
                    if (parentActivity != null) {
                        AbstractProcessActivityBase act = parentActivity as AbstractProcessActivityBase;
                        act.PushDebuggerStack();
                        act.SetBreakpointId(key);
                    }
                }
                foreign.Reverse();
                foreach (Triplet<string, string, string> pair in foreign) {
                    BreakpointId functionId = new BreakpointId(ObjectKey.Parse(pair.First), null, null, null);
                    SetFlowState(Debugger.Push(pair.Second, functionId.ToString(/*includeCompoundKey*/false), pair.Third, ProcessType));
                }
                PushDebuggerStack(processDetail);
            }

            protected virtual void PushDebuggerStack(string processDetail) {
            }

            protected virtual bool _GetProcessActivityImplementation(int processId, int activityId, ObjectKey activityKey, bool isRunning, out IProcessActivity instance) {
                instance = null;
                return false;
            }

            protected virtual void SetFlowState(LocalState state) {
            }

            public virtual void SetBreakpointId(string key) { }
            
            public virtual void PopDebuggerStack() { }
            
            protected virtual void AddHandleBreakPoint(ActivityStatus status) {
                // Debugger.AddExtraVariable("$ActivityStatus", status);
            }

            //IProcessActivity interface
            private readonly int activityId;
            public int ActivityId {
                get { return activityId; }
            }

            private readonly int processId;
            public int ProcessId {
                get { return processId; }
            }

            private DateTime? closedInstant;
            public DateTime ClosedInstant {
                get {
                    if (closedInstant == null) {
                        if (IsDummy) {
                            closedInstant = BuiltInFunction.NullDate();
                        } else {
                            using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                                closedInstant = DBRuntimePlatform.Instance.GetActivityClosedInstant(trans, ActivityId);
                            }
                        }
                    }
                    return closedInstant.Value;
                }
            }

            public DateTime StartedInstant {
                get { return ClosedInstant; }
            }

            private int? closedBy;
            public int ClosedBy {
                get {
                    if (closedBy == null) {
                        if (IsDummy) {
                            closedBy = 0;
                        } else {
                            using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                                closedBy = DBRuntimePlatform.Instance.GetActivityClosedBy(trans, ActivityId);
                            }
                        }
                    }
                    return closedBy.Value;
                }
            }

            public int StartedBy {
                get { return ClosedBy; }
            }

            private int? activityClosedCount;
            public int ActivityClosedCount {
                get {
                    if (activityClosedCount == null) {
                        if (IsDummy) {
                            activityClosedCount = 0;
                        } else {
                            using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                                activityClosedCount = DBRuntimePlatform.Instance.GetActivityCloseCount(trans, ActivityId);
                            }
                        }
                    }
                    return activityClosedCount.Value;
                }
            }

            public virtual bool Expired {
                get { return false; }
            }

            public virtual bool CanBeSkipped() {
                return false;
            }
            public virtual bool Skipped {
                get { return false; }
            }

            //Activity Outputs Cache
            private Dictionary<ObjectKey, IActivityVariable> activityOutputs = null;
            protected Dictionary<ObjectKey, IActivityVariable> ActivityOutputs {
                get {
                    return activityOutputs ?? (activityOutputs = new Dictionary<ObjectKey, IActivityVariable>());
                }
            }

            protected virtual Dictionary<ObjectKey, IActivityVariable> AllActivityOutputsDefinitions {
                get { return new Dictionary<ObjectKey, IActivityVariable>(0); }
            }

            public virtual bool HasOwnOutputs {
                get { return false; }
            }

            public ActivityVariable<T> GetActivityOutput<T>(ActivityVariable<T> variableDefinition) {
                return GetVariable(ActivityOutputs, variableDefinition, DBRuntimePlatform.Instance.GetActivityOutput, ActivityId);
            }

            private void SaveActivityOutputs(HeContext heContext) {
                if (HasOwnOutputs) {
                    using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                        int tenantId = heContext.AppInfo.Tenant.Id;

                        IEnumerable<IActivityVariable> defaultOutputs = AllActivityOutputsDefinitions.Where(def => !ActivityOutputs.ContainsKey(def.Key))
                                                                                                     .Select(def => def.Value);

                        foreach (IActivityVariable variable in ActivityOutputs.Values.Concat(defaultOutputs)) {
                            if (variable.WasSet || !DBRuntimePlatform.Instance.ActivityVariableIsSaved(trans, ActivityId, tenantId, variable, true, false)) {
                                DBRuntimePlatform.Instance.AddOrUpdateActivityOutput(trans, ActivityId, tenantId, variable);
                            }
                        }
                    }
                }
            }

            protected void SaveVariables(HeContext heContext) {
                SaveActivityOutputs(heContext);
                GetCurrentProcess().SaveProcessOutputs(heContext);
            }

            //GetPrecedentActivity and activity cache
            private Dictionary<ObjectKey, IProcessActivity> precedentActivitiesCache = null;
            private Dictionary<ObjectKey, IProcessActivity> PrecedentActivitiesCache {
                get {
                    return precedentActivitiesCache ?? (precedentActivitiesCache = new Dictionary<ObjectKey, IProcessActivity>());
                }
            }

            protected abstract bool GetPrecedentActivity(ObjectKey targetSSKey, out IProcessActivity instance);

            protected abstract bool GetDummyProcessActivity(ObjectKey activityKey, out IProcessActivity instance);

            public T GetPrecedentActivity<T>(ObjectKey targetSSKey) {
                IProcessActivity instance;
                if (PrecedentActivitiesCache.TryGetValue(targetSSKey, out instance)) {
                    return (T)instance;
                } else if (GetPrecedentActivity(targetSSKey, out instance) || GetDummyProcessActivity(targetSSKey, out instance)) {
                    PrecedentActivitiesCache[targetSSKey] = instance;
                    return (T)instance;
                }

                throw new InvalidOperationException("No process precedent activity with key '" + ObjectKeyUtils.DatabaseValue(targetSSKey) + "' exists.");
            }

            private IEnumerable<Triplet<int, ActivityKind, ObjectKey>> ExecuteNextActivities(HeContext heContext, IEnumerable<Triplet<int, ActivityKind, ObjectKey>> nextActIds, bool isUnattended) {
                if (isUnattended && nextActIds.IsSingle()) {
                    var nextAct = nextActIds.First();
                    //This if is to disable optimization for executing sequential automatic activities on an unattended execution
                    //It is disable because we would need to limit this optimization based on the time it already consumed Vs Timeout
                    if (nextAct.Second.CanExecuteAsNextActivity()) {
                        nextActIds = ExecuteNextActivity(heContext, nextAct, isUnattended);
                    }
                } else {
                    var newNextActIds = Enumerable.Empty<Triplet<int, ActivityKind, ObjectKey>>();
                    //if there are any human activities lets execute to at least put them at ready state
                    var activitiesToExecute = nextActIds.Where(pair => pair.Second.CanExecuteAsNextActivity());
                    foreach (var nextAct in activitiesToExecute.OrderBy(triplet => triplet.Second.KindOrderNum())) {
                        newNextActIds = newNextActIds.Concat(ExecuteNextActivity(heContext, nextAct, isUnattended));
                    }
                    nextActIds = nextActIds.Except(activitiesToExecute)
                                           .Concat(newNextActIds);
                }
                return nextActIds.Distinct();
            }

            private IEnumerable<Triplet<int, ActivityKind, ObjectKey>> ExecuteNextActivity(HeContext heContext, Triplet<int, ActivityKind, ObjectKey> nextAct, bool isUnattended) {
                IProcessActivity execObj;

                if (GetProcessActivityInstance(ProcessId, nextAct.First, nextAct.Third, true, out execObj)) {
                    return execObj.StartWork(heContext, isUnattended, ActivityStatus.Created);
                }
                return Enumerable.Empty<Triplet<int, ActivityKind, ObjectKey>>();
            }

            /// <summary>
            /// Action executed before an activity can be open
            /// </summary>
            public bool StartOnOpen(HeContext heContext, string sessionId, bool requestIsSecure, string hostname, bool onlyGetUrl, out string failureMessage, out string handlingUrl) {
                bool success = false;
                failureMessage = string.Empty;
                handlingUrl = string.Empty;

                bool runnable = false;
                bool isRunning = false;
                ActivityStatus currentStatus;

                SetRequestName("Open");

                if (Kind.CanBeOpened()) {
                    failureMessage = "Activity '" + Name + "' (#" + ActivityId + ") cannot be opened.";
                }

                
                try {
                    if (onlyGetUrl) {
                        success = true;
                    } else {
                        StartActivityExecution(heContext, ActivityId, ProcessId, out runnable, out currentStatus);

                        if (runnable) {
                            isRunning = true;
                            PushDebuggerStack();
                            AddHandleBreakPoint(currentStatus);
                            List<ActivityStatus> allowedNextStatus = GetNextStatus(currentStatus);
                            if (currentStatus != ActivityStatus.Open && allowedNextStatus.Contains(ActivityStatus.Open)) {
                                OnOpen(heContext, heContext.Session.UserId);
                                success = true;
                            } else {
                                if (currentStatus == ActivityStatus.Open) {
                                    success = true;
                                    SetActivityStatus(heContext, ActivityId, ActivityStatus.Open);
                                } else {
                                    failureMessage = "Activity '" + Name + "' (#" + ActivityId + ") is in the " + currentStatus.ToString(Kind).ToLower() + " state so it cannot be opened.";
                                }
                            }
                        } else {
                            failureMessage = "Activity '" + Name + "' (#" + ActivityId + ") is already being processed.";
                        }
                    }

                    if (success) {
                        handlingUrl = ActivityUrl(heContext, sessionId, requestIsSecure, hostname);
                    }
                } catch (Exception e) {
                    failureMessage = ProcessException(heContext, e, /*skipLog*/true);
                } finally {
                    if (isRunning) {
                    PopDebuggerStack();
                        EndActivityExecution(heContext, ActivityId);
                    }
                }

                return success;
            }

            /// <summary>
            /// Action executed to release a human activity before an activity can be closed
            /// </summary>
            public bool StartActivityReset(HeContext heContext, int activityId, bool resetActivityUser, out string failureMessage) {
                bool success = false;
                failureMessage = string.Empty;
                bool runnable = false;
                bool isRunning = false;
                ActivityStatus currentStatus;

                try {

                    SetRequestName("Reset");


                    StartActivityExecution(heContext, ActivityId, ProcessId, out runnable, out currentStatus);

                    if (runnable) {
                        isRunning = true;
                        PushDebuggerStack();
                        AddHandleBreakPoint(currentStatus);
                        List<ActivityStatus> allowedNextStatus = GetNextStatus(currentStatus);
                        if (resetActivityUser || (currentStatus != ActivityStatus.Ready && allowedNextStatus.Contains(ActivityStatus.Ready))) {
                            ReleaseActivity(heContext, activityId, resetActivityUser);
                            success = true;
                        } else {
                            if (currentStatus == ActivityStatus.Ready) {
                                success = true;
                            } else {
                                failureMessage = "Activity '" + Name + "' (#" + ActivityId + ") is in the " + currentStatus.ToString(Kind).ToLower() + " state so it cannot become ready.";
                            }
                        }
                    } else {
                        failureMessage = "Activity '" + Name + "' (#" + ActivityId + ") is already being processed.";
                    }
                } catch (Exception e) {
                    failureMessage = ProcessException(heContext, e, /*skipLog*/true);
                } finally {
                    if (isRunning) {
                    PopDebuggerStack();
                        EndActivityExecution(heContext, ActivityId);
                    }
                }
                return success;
            }


            /// <summary>
            /// Action executed to schedule an human activity to a later date
            /// </summary>
            public bool StartActivitySchedule(HeContext heContext, int activityId, DateTime startDate, out string failureMessage) {
                bool success = false;
                failureMessage = string.Empty;
                bool runnable = false;
                bool isRunning = false;
                ActivityStatus currentStatus;

                try {
                    SetRequestName("Schedule");
                    StartActivityExecution(heContext, ActivityId, ProcessId, out runnable, out currentStatus);

                    if (runnable) {
                        isRunning = true;
                        PushDebuggerStack();
                        AddHandleBreakPoint(currentStatus);
                        List<ActivityStatus> allowedNextStatus = GetNextStatus(currentStatus);
                        if (currentStatus == ActivityStatus.Scheduled || allowedNextStatus.Contains(ActivityStatus.Scheduled)) {
                            ScheduleActivity(heContext, activityId, startDate);
                            success = true;
                        } else {
                            failureMessage = "Activity '" + Name + "' (#" + ActivityId + ") is in the " + currentStatus.ToString(Kind).ToLower() + " state so it cannot become scheduled.";
                        }
                    } else {
                        failureMessage = "Activity '" + Name + "' (#" + ActivityId + ") is already being processed.";
                    }
                } catch (Exception e) {
                    failureMessage = ProcessException(heContext, e, /*skipLog*/true);
                } finally {
                    if (isRunning) {
                    PopDebuggerStack();
                        EndActivityExecution(heContext, ActivityId);
                    }
                }
                return success;
            }

            protected void SetCloseInputs(Dictionary<ObjectKey, object> inputValues) {
                var missingInputs = AllActivityOutputsDefinitions.Values.Where(input => input.IsMandatory)
                                                                       .Where(input => !inputValues.ContainsKey(input.Key));


                if (!missingInputs.IsEmpty()) {
                    string missingInputNames = missingInputs.Select(input => input.Name)
                                                            .StrCat(", ");

                    throw new InvalidOperationException("Activity '" + Name + "' (#" + ActivityId + ") cannot be " + ActivityStatus.Closed.ToString(Kind).ToLower() + " because the following inputs are missing: " + missingInputNames + ".");
                    }

                foreach (var kvp in inputValues) {
                    IActivityVariable output;
                    if (ActivityOutputs.TryGetValue(kvp.Key, out output)) {
                        output.ValueObj = kvp.Value;
                    } else {
                        output = AllActivityOutputsDefinitions[kvp.Key].NewInstance();
                        output.ValueObj = kvp.Value;
                        ActivityOutputs[kvp.Key] = output;
                    }
                }
            }

            /// <summary>
            /// Action executed before an activity can be closed
            /// </summary>
            public bool StartOnClose(HeContext heContext, bool advanceProcess, bool skip, bool skipAll, List<Pair<string, object>> inputs, out string failureMessage, out List<Pair<int, ActivityKind>> nextActivityIds) {
                bool success = false;
                failureMessage = string.Empty;
                bool runnable = false;
                bool isRunning = false;
                ActivityStatus currentStatus;
                var tempNextActIds = Enumerable.Empty<Triplet<int, ActivityKind, ObjectKey>>();

                if (!skipAll && (Kind.CanBeClosed() || Kind.CanBeStarted())) {
                    failureMessage = "Activity '" + Name + "' (#" + ActivityId + ") cannot be closed or started.";
                }

                try {

                    SetRequestName("Close");


                    StartActivityExecution(heContext, ActivityId, ProcessId, out runnable, out currentStatus);

                    if (runnable) {
                        isRunning = true;
                        PushDebuggerStack();
                        AddHandleBreakPoint(currentStatus);
                        List<ActivityStatus> allowedNextStatus = GetNextStatus(currentStatus);
                        if (skipAll || currentStatus != ActivityStatus.Closed && allowedNextStatus.Contains(ActivityStatus.Closed)) {
                            if (!(skip || skipAll)) {
                                SetCloseInputs(inputs.ToDictionary(pair => ObjectKey.Parse(pair.First), pair => pair.Second));
                            }
                            tempNextActIds = OnClose(heContext, skip, skipAll, false);
                            success = true;
                        } else {
                            if (currentStatus == ActivityStatus.Closed) {
                                failureMessage = "Activity '" + Name + "' (#" + ActivityId + ") is already " + ActivityStatus.Closed.ToString(Kind).ToLower() + ".";
                            } else {
                                failureMessage = "Activity '" + Name + "' (#" + ActivityId + ") is in the " + currentStatus.ToString(Kind).ToLower() + " state so it cannot be " + ActivityStatus.Closed.ToString(Kind).ToLower() + ".";
                            }
                        }
                    } else {
                        failureMessage = "Activity '" + Name + "' (#" + ActivityId + ") is already being processed.";
                    }
                } catch (Exception e) {
                    failureMessage = ProcessException(heContext, e, /*skipLog*/true);
                } finally {
                    if (isRunning) {
                    PopDebuggerStack();
                        EndActivityExecution(heContext, ActivityId);
                    }
                }

                if (advanceProcess) {
                    tempNextActIds = ExecuteNextActivities(heContext, tempNextActIds, /*isUnattended*/false);
                }
                nextActivityIds = tempNextActIds.Select(nextAct => Pair.Create(nextAct.First, nextAct.Second))
                                                .ToList();
                return success;
            }

            public void StartOnEvent(HeContext heContext, string dataId, bool advanceProcess) {
                bool runnable = false;
                bool isRunning = false;
                ActivityStatus currentStatus;
                var tempNextActIds = Enumerable.Empty<Triplet<int, ActivityKind, ObjectKey>>();

                try {
                    SetRequestName("CreateOrUpdate Event for");
                    StartActivityExecution(heContext, ActivityId, ProcessId, out runnable, out currentStatus);

                    if (runnable) {
                        isRunning = true;
                        PushDebuggerStack();
                        AddHandleBreakPoint(currentStatus);
                        if (currentStatus == ActivityStatus.Waiting || currentStatus == ActivityStatus.Listening
                            || currentStatus == ActivityStatus.Ready || currentStatus == ActivityStatus.Open) {

                            tempNextActIds = OnEvent(heContext, dataId);
                        }
                    } else {
                        throw new InvalidOperationException("Activity '" + Name + "' (#" + ActivityId + ") is already being processed.");
                    }
                } catch (Exception e) {
                    ProcessException(heContext, e, /*skipLog*/true);
                    throw;
                } finally {
                    if (isRunning) {
                    PopDebuggerStack();
                        EndActivityExecution(heContext, ActivityId);
                    }
                }

                ExecuteNextActivities(heContext, tempNextActIds, /*isUnattended*/false);
            }

            public void StartSetEventFilters(HeContext heContext) {
                bool runnable = false;
                bool isRunning = false;
                ActivityStatus currentStatus;

                try {
                    SetRequestName("Update Event Filters for");
                    StartActivityExecution(heContext, ActivityId, ProcessId, out runnable, out currentStatus);

                    if (runnable) {
                        isRunning = true;
                        PushDebuggerStack();
                        AddHandleBreakPoint(currentStatus);
                        if (currentStatus == ActivityStatus.Waiting || currentStatus == ActivityStatus.Listening
                            || currentStatus == ActivityStatus.Ready || currentStatus == ActivityStatus.Open) {

                            SetEventFilters(heContext);
                        }
                    }
                } catch (Exception e) {
                    ProcessException(heContext, e, /*skipLog*/false);
                } finally {
                    if (isRunning) {
                    PopDebuggerStack();
                        EndActivityExecution(heContext, ActivityId);
                    }
                }
            }

            public void StartRemoveEventFilters(HeContext heContext) {
                bool runnable = false;
                bool isRunning = false;
                ActivityStatus currentStatus;

                try {
                    StartActivityExecution(heContext, ActivityId, ProcessId, out runnable, out currentStatus);

                    if (runnable) {
                        isRunning = true;
                        PushDebuggerStack();
                        AddHandleBreakPoint(currentStatus);
                        if (!(currentStatus == ActivityStatus.Waiting || currentStatus == ActivityStatus.Listening
                            || currentStatus == ActivityStatus.Ready || currentStatus == ActivityStatus.Open)) {

                            RemoveEventFilters(heContext);
                        }
                    }
                } catch (Exception e) {
                    ProcessException(heContext, e, /*skipLog*/false);
                } finally {
                    if (isRunning) {
                    PopDebuggerStack();
                        EndActivityExecution(heContext, ActivityId);
                    }
                }
            }

            public virtual bool TerminateActivity(HeContext heContext, bool recursive) {
                return true;
            }


            /// <summary>
            /// Method to set the event filters from a listening activity
            /// </summary>
            protected virtual void SetEventFilters(HeContext heContext) { }

            /// <summary>
            /// Method to remove the event filters from a listening activity
            /// Can only be used internally or by the BPMRuntime
            /// </summary>
            public virtual void RemoveEventFilters(HeContext heContext) { }

            protected void OnOpen(HeContext heContext, int userId) {
                GetCurrentProcess().OnActivityOpenCallback(heContext);
                OnOpenCallback(heContext);
                SaveVariables(heContext);
                if (userId != BuiltInFunction.NullIdentifier()) {
                    using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                        DBRuntimePlatform.Instance.UpdateHumanActivityUser(trans, ActivityId, userId);
                    }
                }
                SetActivityStatus(heContext, ActivityId, ActivityStatus.Open);
            }

            protected virtual void OnOpenCallback(HeContext heContext) { }


            protected IEnumerable<Triplet<int, ActivityKind, ObjectKey>> ForceClose(HeContext heContext, Dictionary<ObjectKey, IActivityVariable> outputs, Dictionary<ObjectKey, IActivityVariable> processOutputs) {
                this.activityOutputs = outputs;
                GetCurrentProcess().ProcessOutputs = processOutputs;
                return CloseActivity(heContext);
            }

            private void SetRequestName( string verb) {
                Debugger.SetRequestName( verb + " '" + Name + "'");
            }

            /// <summary>
            /// Completes the close of an activity.
            /// It is also responsible for the activation of next activities
            /// </summary>
            protected IEnumerable<Triplet<int, ActivityKind, ObjectKey>> OnClose(HeContext heContext, bool skip, bool skipAll, bool timeout) {
                if (!timeout) {
                    if (skip || skipAll) {
                        if (!skipAll && !CanBeSkipped()) {
                            throw new InvalidOperationException("Activity '" + Name + "' (#" + activityId + ") cannot be skipped.");
                        }
                        SetRequestName("Skip");

                        using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                            DBRuntimePlatform.Instance.UpdateActivitySkipped(trans, ActivityId, true);
                        }

                        try {
                            GetCurrentProcess().OnActivitySkipCallback(heContext);                        
                            OnSkipCallback(heContext);
                        } catch {
                            //#613763 If the OnSkipCallback throws an exception we must set the ActivitySkipped back to false.
                            //This is relevant because the ActivitySkipped is set to true before the call callback and it can have a commit. 
                            DatabaseAccess.RollbackAllTransactions();

                            using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                                DBRuntimePlatform.Instance.UpdateActivitySkipped(trans, ActivityId, false);
                            }

                            DatabaseAccess.CommitAllTransactions();
                            throw;
                        }
                    } else if (Kind.CanBeStarted()) {
                        SetRequestName("Start" );

                        GetCurrentProcess().OnActivityStartCallback(heContext);
                        OnStartCallback(heContext);
                    } else if (Kind.CanBeClosed()) {
                        GetCurrentProcess().OnActivityCloseCallback(heContext);
                        OnCloseCallback(heContext);
                    }
                }
                if (!OnCloseCreatesDuplicate) {
                    return CloseActivity(heContext);
                } else {
                    return CloseDuplicate(heContext);
                }
            }

            protected IEnumerable<Triplet<int, ActivityKind, ObjectKey>> CloseActivity(HeContext heContext) {
                var nextActIds = Enumerable.Empty<Triplet<int, ActivityKind, ObjectKey>>();
                bool processEnded = false;

                SaveVariables(heContext);
                RemoveEventFilters(heContext);
                UpdateProcessInboxDetail(heContext);
                if (CloseActivityInstance(heContext, ActivityId, OnCloseTerminatesProcess, out processEnded)) {
                    // Invoke process next activities
                    nextActIds = ActivateNextActivities(heContext);
                }

                if (processEnded) {
                    AfterProcessEnded(heContext);
                }

                return nextActIds;
            }

            protected virtual void OnWaiting(HeContext heContext, List<Pair<int, ActivityKind>> nextActIds) { }

            protected void OnReady(HeContext heContext) {
                GetCurrentProcess().OnActivityReadyCallback(heContext);
                OnReadyCallback(heContext);
                SaveVariables(heContext);
            }

            protected virtual IEnumerable<Triplet<int, ActivityKind, ObjectKey>> OnEvent(HeContext heContext, string dataId) {
                return Enumerable.Empty<Triplet<int, ActivityKind, ObjectKey>>();
            }


            protected virtual void UpdateProcessInboxDetail(HeContext heContext) {
                try {
                    SetRequestName("Update Detail for");

                    using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                        DBRuntimePlatform.Instance.UpdateProcessInboxDetail(trans, ProcessId, ProcessInboxDetail(heContext));
                    }
                } catch (Exception e) {
                    Log.ErrorLog.StaticWrite(DateTime.Now, "", heContext.AppInfo.eSpaceId, heContext.AppInfo.Tenant.Id, 0, e.Message, e.StackTrace, "BPM");
                }
            }

            protected virtual string InboxDetail(HeContext heContext) {
                return ProcessInboxDetail(heContext);
            }

            protected virtual string ProcessInboxDetail(HeContext heContext) {
                return string.Empty;
            }


            public IEnumerable<Triplet<int, ActivityKind, ObjectKey>> StartWork(HeContext heContext, bool isUnattended, ActivityStatus forInitialStatus) {
                return StartWork(heContext, isUnattended, forInitialStatus, BuiltInFunction.NullDate());
            }

            /// <summary>
            /// Start executing this activity
            /// </summary>
            /// <param name="heContext"></param>
            /// <param name="isUnattended"></param>
            /// <param name="forInitialStatus"></param>
            /// <param name="previousNextRun"></param>
            /// <returns>The next activity ids </returns>
            public IEnumerable<Triplet<int, ActivityKind, ObjectKey>> StartWork(HeContext heContext, bool isUnattended, ActivityStatus forInitialStatus, DateTime previousNextRun) {
                bool initialStatusMissmatch = false;
                bool runnable = false;
                bool isRunning = false;
                ActivityStatus initialStatus = ActivityStatus.Unknown;
                ActivityStatus currentStatus = ActivityStatus.Unknown;
                var nextActIds = Enumerable.Empty<Triplet<int, ActivityKind, ObjectKey>>();
                var subNextActIds = new List<Pair<int, ActivityKind>>();
                bool hasError = false;
                string errorId = null;

                

                //For consistency automatic actions always run with the default locale
                GenericExtendedActions.SetCurrentLocale(heContext, string.Empty);

                try {

                    StartActivityExecution(heContext, ActivityId, ProcessId, forInitialStatus, out runnable, out initialStatus, previousNextRun);

                    currentStatus = initialStatus;

                    if (runnable) {
                        isRunning = true;
                        PushDebuggerStack();
                        if (initialStatus != forInitialStatus) {
                            initialStatusMissmatch = true;
                            if (!initialStatus.IsTerminal()) {
                                return new Triplet<int, ActivityKind, ObjectKey>[] { Triplet.Create(ActivityId, Kind, GlobalKey.Key) };
                            } else {
                                return nextActIds;
                            }
                        }

                        if (currentStatus == ActivityStatus.Created || currentStatus == ActivityStatus.Scheduled || currentStatus == ActivityStatus.Waiting) {
                            List<ActivityStatus> nextStatuses = GetNextStatus(currentStatus);

                            ActivityStatus nextStatus = nextStatuses.First();

                            if (nextStatus != currentStatus) {
                                switch (nextStatus) {
                                    case ActivityStatus.Waiting:
                                    case ActivityStatus.Listening:
                                    case ActivityStatus.Ready:
                                        SetRequestName("Create");
                                        AddHandleBreakPoint(currentStatus);
                                        SetActivityPreparationParameters(heContext);
                                        OnReady(heContext);
                                        SetActivityParameters(heContext, currentStatus, ref nextStatus);
                                        OnWaiting(heContext, subNextActIds);
                                        break;
                                    case ActivityStatus.Open:
                                        throw new InvalidOperationException("Activity '" + Name + "' (#" + ActivityId + ") has an unexpected open state.");
                                    default:
                                        SetActivityParameters(heContext, currentStatus, ref nextStatus);
                                        break;
                                }

                                using (Transaction trans = DatabaseAccess.ForRuntimeDatabase.GetRequestTransaction()) {
                                    currentStatus = DBRuntimePlatform.Instance.GetActivityStatus(trans, ActivityId);
                                }

                                if (currentStatus != ActivityStatus.Discarded && currentStatus != ActivityStatus.Closing) {
                                    SetActivityStatus(heContext, ActivityId, nextStatus);
                                    currentStatus = nextStatus;
                                }

                                // Commit is needed here so exceptions thrown in Execute Method do not rollback on Readys and SetActivityParameters
                                DatabaseAccess.CommitAllTransactions();
                            }
                        }

                        if (currentStatus == ActivityStatus.Executing) {
                            SetRequestName("Execute");
                            AddHandleBreakPoint(currentStatus);
                            ExecuteMethod(heContext);
                        }

                        if (currentStatus == ActivityStatus.Executing || currentStatus == ActivityStatus.Closing) {
                            // TODO: # if(currentStatus == ActivityStatus.Executing AND ownerESpace.IsLocked) THEN Only SetActivityStatus(heContext, ActivityId, ActivityStatus.Closing);
                            SetRequestName("Close");
                            if (GetNextStatus(currentStatus).Contains(ActivityStatus.Closed)) {
                                if (initialStatus == ActivityStatus.Waiting)
                                    nextActIds = OnClose(heContext, false, false, true);
                                else
                                    nextActIds = OnClose(heContext, false, false, false);
                                currentStatus = ActivityStatus.Closed;
                            }
                        }
                    } 
                } catch (Exception e) {
                    ProcessException(heContext, e, /*skipLog*/false, out errorId);
                    hasError = true;
                } finally {
                    if (isRunning) {
                    PopDebuggerStack();
                        DateTime? explicitReschedule = null;
                        bool automaticReschedule = !initialStatusMissmatch && ShouldDoAutomaticReschedule(initialStatus, currentStatus, ref explicitReschedule);
                        EndActivityExecution(heContext, ActivityId, automaticReschedule, explicitReschedule, hasError, errorId);
                    }
                }

                if (nextActIds.IsEmpty() && subNextActIds.IsEmpty()) {
                    nextActIds = new Triplet<int, ActivityKind, ObjectKey>[] { Triplet.Create(ActivityId, Kind, GlobalKey.Key) };
                } else {
                    //Note that any transaction at this point will already have been commited at "EndActivityExecution"
                    nextActIds = ExecuteNextActivities(heContext, nextActIds, isUnattended);
                }

                return nextActIds.Concat(subNextActIds.Select(pair => new Triplet<int, ActivityKind, ObjectKey>(pair.First, pair.Second, null)));

            }

            private bool ShouldDoAutomaticReschedule(ActivityStatus initialStatus, ActivityStatus currentStatus, ref DateTime? explicitReschedule) {
                switch (currentStatus) {
                    case ActivityStatus.Created:
                    case ActivityStatus.Executing:
                    case ActivityStatus.Closing:
                        return true;
                    case ActivityStatus.Open:
                    case ActivityStatus.Listening:
                    case ActivityStatus.Closed:
                    case ActivityStatus.Blocked:
                    case ActivityStatus.Ready:
                        explicitReschedule = BuiltInFunction.NullDate();
                        return true;
                    case ActivityStatus.Waiting:
                        return false;
                    case ActivityStatus.Scheduled:
                        return initialStatus == ActivityStatus.Scheduled;
                    default:
                        return false;
                }
            }

            protected override void SetCurrentProcessInfo(int processId, int activityId, int precedentActivityId, int precedentActivitySuccessorsCount, int rootProcessId) {
                // for conditional start, the process start node is actually the predecessor node. However, we don't want
                // to stop in a ConditionalStart whenever we do a StepOver on the start node!
                if (this.Kind == ActivityKind.ConditionalStart) {
                    precedentActivityId = DummyId;
                    precedentActivitySuccessorsCount = 0;
                }

                base.SetCurrentProcessInfo(processId, activityId, precedentActivityId, precedentActivitySuccessorsCount, rootProcessId);
            }
        }
    }
}
