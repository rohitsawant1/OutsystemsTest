/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.IdentityModel.Tokens.Jwt;
using System.Linq;
using System.Text;
using Microsoft.IdentityModel.Tokens;
using Newtonsoft.Json;
using OutSystems.RuntimeCommon;
using OutSystems.RuntimeCommon.Cryptography;
using OutSystems.RuntimeCommon.Settings;

namespace OutSystems.HubEdition.RuntimePlatform.Internal {

    public class SecurityTokenAPI {
        private const int DefaultRequestLifetime = 300; // in seconds
        private const int DefaultClockSkew = 0; // in seconds

        public static string GenerateJWTTokenString(ISettingsProvider settingsProvider, string consumerModuleKey, string producerModuleKey, int userId, int tenantId, byte[] requestHash, int requestLifetime = DefaultRequestLifetime) {
            return GenerateJWTTokenString(GetTokenKey(settingsProvider), consumerModuleKey, producerModuleKey, userId, tenantId, requestHash, requestLifetime);
        }

        private static string GenerateJWTTokenString(string tokenKey, string consumerModuleKey, string producerModuleKey, int userId, int tenantId, byte[] requestHash, int requestLifetime = DefaultRequestLifetime) {

            var payload = new JwtPayload {
                { "iss", consumerModuleKey },
                { "aud", producerModuleKey },
                { "exp", GetUnixEpoch(DateTime.UtcNow.AddSeconds(requestLifetime)) },
                { "userId", userId },
                { "tenantId", tenantId },
                { "requestHash", requestHash }
            };

            return GenerateJWTTokenString(tokenKey, payload);
        }

        public static string GenerateJWTTokenString(ISettingsProvider settingsProvider, string consumerModuleKey, string producerModuleKey, byte[] responseHash, int requestLifetime = DefaultRequestLifetime) {
            return GenerateJWTTokenString(GetTokenKey(settingsProvider), consumerModuleKey, producerModuleKey, responseHash, requestLifetime);
        }

        private static string GenerateJWTTokenString(string tokenKey, string consumerModuleKey, string producerModuleKey, byte[] responseHash, int requestLifetime = DefaultRequestLifetime) {

            var payload = new JwtPayload {
                { "iss", producerModuleKey },
                { "aud", consumerModuleKey },
                { "exp", GetUnixEpoch(DateTime.UtcNow.AddSeconds(requestLifetime)) },
                { "responseHash", responseHash }
            };

            return GenerateJWTTokenString(tokenKey, payload);
        }

        public static bool IsTokenValid(ISettingsProvider settingsProvider, string authToken) {
            return GetValidatedToken<RequestSecurityTokenPayload>(settingsProvider, authToken) != null;
        }

        /// <summary>
        /// Validates autorization token string
        /// </summary>
        /// <param name="settingsProvider">settings provider to be used in the validation</param>
        /// <param name="authToken">token string to be validated</param>
        /// <returns>validated token object</returns>
        public static SecurityTokenPayloadType GetValidatedToken<SecurityTokenPayloadType>(ISettingsProvider settingsProvider, string authToken) {
            var tokenHandler = new JwtSecurityTokenHandler();
            var validationParameters = GetValidationParameters(settingsProvider);

            SecurityToken token;
            SecurityTokenPayloadType tokenPayload = default(SecurityTokenPayloadType);
            try {
                tokenHandler.ValidateToken(authToken, validationParameters, out token);
                string tokenString = token.ToString();
                string payload = tokenString.Substring(tokenString.IndexOf('.') + 1);
                tokenPayload = JsonConvert.DeserializeObject<SecurityTokenPayloadType>(payload);
            } catch (Exception e) {
                OSTrace.Error("Token validation failed.", e);
            }
            return tokenPayload;
        }

        public static byte[] GeneratePayloadHash(ISettingsProvider settingsProvider, string payloadString) {
            return SignatureHelper.ByteSignHMACSHA256(Encoding.UTF8.GetBytes(payloadString), Encoding.UTF8.GetBytes(GetPayloadHashKey(settingsProvider)));
        }

        public static bool ValidatePayloadHash(ISettingsProvider settingsProvider, string payloadString, byte[] payloadHash) {
            return Enumerable.SequenceEqual<byte>(GeneratePayloadHash(settingsProvider, payloadString), payloadHash);
        }

        private static string GenerateJWTTokenString(string tokenKey, JwtPayload payload) {
            var securityKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(tokenKey));
            var credentials = new SigningCredentials(securityKey, SecurityAlgorithms.HmacSha256);
            var header = new JwtHeader(credentials);

            var secToken = new JwtSecurityToken(header, payload);
            var handler = new JwtSecurityTokenHandler();

            return handler.WriteToken(secToken);
        }

        private static TokenValidationParameters GetValidationParameters(ISettingsProvider settingsProvider) {
            return new TokenValidationParameters() {
                //Used to automatically validate the lifetime of the request
                //based on the epoch time in the Expiration parameter
                ValidateLifetime = true,
                ClockSkew = TimeSpan.FromSeconds(DefaultClockSkew),
                //ServiceAPIMethods manually validate the Audience and 
                //the Issuer based onthe Producer and Consumer Guids
                ValidateAudience = false,
                ValidateIssuer = false,
                IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(GetTokenKey(settingsProvider)))
            };
        }

        private static double GetUnixEpoch(DateTime dateTime) {
            var unixTime = dateTime.ToUniversalTime() -
                new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);
            return unixTime.TotalSeconds;
        }

        private static string GetTokenKey(ISettingsProvider settingsProvider) {
            return settingsProvider.Get(RuntimePlatformSettings.Authentication.ReferencesAuthenticationKey);
        }

        private static string GetPayloadHashKey(ISettingsProvider settingsProvider) {
            return settingsProvider.Get(RuntimePlatformSettings.Authentication.ReferencesHashKey);
        }

        public class RequestSecurityTokenPayload {
            [JsonProperty("iss")]
            public string ConsumerKey { get; set; }
            [JsonProperty("aud")]
            public string ProducerKey { get; set; }
            [JsonProperty("userId")]
            public int UserId { get; set; }
            public int TenantId { get; set; }
            public byte[] RequestHash { get; set; }
        }

        public class ResponseSecurityTokenPayload {
            [JsonProperty("iss")]
            public string ProducerKey { get; set; }
            [JsonProperty("aud")]
            public string ConsumerKey { get; set; }
            public byte[] ResponseHash { get; set; }
        }
    }
}
