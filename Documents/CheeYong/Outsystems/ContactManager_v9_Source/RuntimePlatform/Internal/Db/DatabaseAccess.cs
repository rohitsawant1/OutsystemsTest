/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Data;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Web;
using OutSystems.HubEdition.Extensibility.Data;
using OutSystems.HubEdition.Extensibility.Data.ConfigurationService;
using OutSystems.HubEdition.Extensibility.Data.Platform;
using OutSystems.HubEdition.Extensibility.Data.TransactionService;
using OutSystems.HubEdition.RuntimePlatform;
using OutSystems.HubEdition.RuntimePlatform.Internal.Db;
using OutSystems.HubEdition.RuntimePlatform.Log;
using OutSystems.ObjectKeys;
using OutSystems.RuntimeCommon;
using OutSystems.RuntimeCommon.Log;
using OutSystems.RuntimeCommon.ObfuscationProperties;
using OutSystems.RuntimeCommon.Settings;

namespace OutSystems.Internal.Db {

    /// <summary>
    /// Class intended for OutSystems use only! Provides easy access to the database for different runtime configurations (CurrentEspace, DBConnection, System Database and Particular Database)
    /// </summary>
    public class DatabaseAccess {

        private const string SINGLETON_CONTEXT = "DatabaseAccess";

        #region Singleton override delegates
        public delegate DatabaseAccess SingletonGetterDelegate();
        public delegate void SingletonSetterDelegate(DatabaseAccess databaseAccess);
        #endregion

        #region Static fields

        protected static volatile DatabaseAccess singleton;

        private static readonly object locker = new object();
        
        private static readonly ConcurrentDictionary<string, IRuntimeDatabaseConfiguration> catalogConfigurationsCacheByEspaceKey
            = new ConcurrentDictionary<string, IRuntimeDatabaseConfiguration>();
        private static readonly ConcurrentDictionary<string, IRuntimeDatabaseConfiguration> catalogConfigurationsCacheByCatalogName
            = new ConcurrentDictionary<string, IRuntimeDatabaseConfiguration>();

        private const int UninitializedQueryTimeout = -1;
        private static volatile int queryTimeout = UninitializedQueryTimeout;

        private static int queryThreshold;
        private static volatile bool isQueryThresholdLoaded;
        private static bool isQueryThresholdLoading;
        private static readonly object queryThresholdLockObject = new object();

        private static volatile DatabasePluginProvider<IDatabaseProvider> integrationDatabasesPluginProvider;
        private static volatile DatabasePluginProvider<IPlatformDatabaseProvider> platformDatabasePluginProvider;

        private static DatabasePluginProvider<IDatabaseProvider> IntegrationDatabasesPluginProvider {
            get {
                if (integrationDatabasesPluginProvider == null) {
                    var pluginPath = GetPluginPaths().ToArray();
                    lock (typeof(DatabaseAccess)) {
                        if (integrationDatabasesPluginProvider == null) {
                            integrationDatabasesPluginProvider = new DatabasePluginProvider<IDatabaseProvider>(pluginPath);
                        }
                    }
                }
                return integrationDatabasesPluginProvider;
            }
        }

        private static DatabasePluginProvider<IPlatformDatabaseProvider> PlatformDatabasePluginProvider {
            get {
                if (platformDatabasePluginProvider == null) {
                    var pluginPath = GetPluginPaths().ToArray();
                    lock (typeof(DatabaseAccess)) {
                        if (platformDatabasePluginProvider == null) {
                            platformDatabasePluginProvider = new DatabasePluginProvider<IPlatformDatabaseProvider>(pluginPath);
                        }
                    }
                }
                return platformDatabasePluginProvider;
            }
        }

        #endregion

        #region Instance fields

        private readonly IDictionary<string, ITransactionManager> sharedTransactionManagers = new Dictionary<string, ITransactionManager>();

        /// <summary>
        /// The systemProvider is the one used by the application to access the OutSystems database
        /// </summary>
        private DatabaseAccessProvider<IPlatformDatabaseServices> systemProvider;

#if SPLIT_DEVELOPMENT
        private DatabaseAccessProvider<IPlatformDatabaseServices> runtimeProvider;
#endif

        /// <summary>
        /// The DatabaseProviders dictionary stores all connections that are used to access different databases
        /// </summary>
        private readonly IDictionary<string, DatabaseAccessProvider<IPlatformDatabaseServices>> databaseProviders
            = new Dictionary<string, DatabaseAccessProvider<IPlatformDatabaseServices>>();

        /// <summary>
        /// The dbConnectionProviders dictionary stores all external database connections
        /// </summary>
        private volatile IDictionary<string, DatabaseAccessProvider<IDatabaseServices>> dbConnectionProviders
            = new Dictionary<string, DatabaseAccessProvider<IDatabaseServices>>();
        
        private readonly ISettingsProvider settingsProvider;

        private readonly object _sessionProviderLockObject = new object();
        private volatile DatabaseAccessProvider<IPlatformDatabaseServices> sessionProvider;

        private readonly object _loggingProviderLockObject = new object();
        private volatile DatabaseAccessProvider<IPlatformDatabaseServices> loggingProvider;

        #endregion

        private DatabaseAccessProvider<IPlatformDatabaseServices> GetRuntimeProviderForDatabase(
                IRuntimeDatabaseConfiguration runtimeDatabaseConfiguration) {

            return GetProviderForDatabase(
                runtimeDatabaseConfiguration,
                DatabaseSettingsSerialization.User.Runtime,
                RuntimeProvider,
                databaseProviders,
                sharedTransactionManagers);
        }

        internal readonly static IExecutionBehaviours DatabaseBehaviours = new ExecutionBehaviour();

        #region Constructors

        /// <summary>
        /// Create a new instance of the <see cref="DatabaseAccess"/> class using the given <c>IDatabaseServices</c>.
        /// </summary>
        /// <param name="initialize">True to initialize the providers, false otherwise</param>
        /// <param name="settingsProvider">True to initialize the providers, false otherwise</param>
        private DatabaseAccess(bool initialize, ISettingsProvider settingsProvider) {
            if (initialize) {
                this.settingsProvider = settingsProvider;
                var source = settingsProvider.Get<bool>(RuntimePlatformSettings.Application.IsApplication) ? DatabaseSettingsSerialization.Source.Application : DatabaseSettingsSerialization.Source.Services;

                systemProvider = CreatePlatformDatabaseAccessProvider(source, DatabaseSettingsSerialization.User.Runtime, DatabaseSettingsSerialization.DataSpace.Platform, settingsProvider);
#if SPLIT_DEVELOPMENT
                runtimeProvider = CreatePlatformDatabaseAccessProvider(source, DatabaseSettingsSerialization.User.Runtime, DatabaseSettingsSerialization.DataSpace.Business, settingsProvider);
#endif
            }
        }

        #endregion

        #region Singleton
        /// <summary>
        /// Gets the current DatabaseAccess. 
        /// If inside a web application, fetchs it from the request. Otherwise, it returns a static one.
        /// </summary>
        internal static DatabaseAccess Current {
            [DoNotObfuscate]
            get {
                CheckAccess("Current");
                HttpContext context = HttpContext.Current;

                if (context == null) {  // will happen in tests or outside a http request
                    if (singleton == null) {
                        var access = new DatabaseAccess(/*initialize*/true, RuntimeSettingsProvider.Instance);
                        lock (locker) {
                            if (singleton == null) {
                                singleton = access;
                            }
                        }
                    }
                    return singleton;
                } else {
                    if (context.Items[SINGLETON_CONTEXT] == null) {
                        var access = new DatabaseAccess(/*initialize*/true, RuntimeSettingsProvider.Instance);
                        lock (context) {
                            if (context.Items[SINGLETON_CONTEXT] == null) {
                                context.Items[SINGLETON_CONTEXT] = access;
                            }
                        }
                    }
                    return (DatabaseAccess)context.Items[SINGLETON_CONTEXT];
                }
            }
        }

        [DoNotObfuscate]
        internal static void Clear() {
            FreeupResources(false);
            singleton = null;
        }

        public static DatabasePluginProvider<IPlatformDatabaseProvider> CurrentPlatformDatabasesPluginProvider {
            get {
                return PlatformDatabasePluginProvider;
            }
        }

        /// <summary>
        /// Indicates if the underlying database access objects are initialized and this class is ready to be used
        /// </summary>
        /// <returns><c>true</c> if it is initialized, otherwise <c>false</c>.</returns>
        internal static bool IsInitialized() {
            HttpContext context = HttpContext.Current;
            return context.Items[SINGLETON_CONTEXT] != null;
        }

        #endregion

        #region Public API

        /// <summary>
        /// Gets a provider for the main database associated with the currently running application.
        /// This should be used to access data that is managed by this or other applications that share the same database.
        /// </summary>
        /// <value>The <c>IDatabaseAccessProvider</c> used to acces the main database.</value>
        public static DatabaseAccessProvider<IPlatformDatabaseServices> ForCurrentDatabase {
            get { return Current.CurrentProvider; }
        }

        /// <summary>
        /// Gets a provider for the system database.
        /// This should be used to access data that is managed by the platform.
        /// </summary>
        /// <value>The <c>IDatabaseAccessProvider</c> used to acces the system database.</value>
        public static DatabaseAccessProvider<IPlatformDatabaseServices> ForSystemDatabase {
            get { return Current.SystemProvider; }
        }

        public static DatabaseAccessProvider<IPlatformDatabaseServices> ForRuntimeDatabase {
            get {
#if SPLIT_DEVELOPMENT
                return Current.RuntimeProvider;
#else
                return ForSystemDatabase;
#endif
            }
        }

        /// <summary>
        /// Gets a provider for a specific eSpace database.
        /// This should be used to access data that is managed by that specific eSpace.
        /// </summary>
        /// <param name="eSpaceKey">eSpace key.</param>
        /// <returns>The <c>IDatabaseAccessProvider</c> to access the given database.</returns>
        public static IDatabaseAccessProvider<IPlatformDatabaseServices> ForEspaceDatabase(string eSpaceKey) {
            return Current.GetDatabaseProviderForEspace(eSpaceKey);
        }

        /// <summary>
        /// Gets a provider for a specific database.
        /// This should be used to access data that is managed by applications that are configured to use this database.
        /// </summary>
        /// <param name="databaseName">Name of the database.</param>
        /// <returns>The <c>IDatabaseAccessProvider</c> to access the given database.</returns>
        public static DatabaseAccessProvider<IPlatformDatabaseServices> ForDatabase(string databaseName) {
            return Current.GetDatabaseProvider(databaseName);
        }

        /// <summary>
        /// Gets a provider for a specific external database connection.
        /// This should be used to access data that is managed by external systems that use this connection.
        /// </summary>
        /// <param name="connectionName">Name of the external database connection.</param>
        /// <returns>The <c>IDatabaseAccessProvider</c> based on the given connection.</returns>
        public static DatabaseAccessProvider<IDatabaseServices> ForDBConnection(string connectionName) {
            return Current.GetDBConnectionProvider(connectionName);
        }

        public static IDatabaseAccessProvider<IPlatformDatabaseServices> ForSession {
            get { return Current.SessionProvider; }
        }

        public static IDatabaseAccessProvider<IPlatformDatabaseServices> ForLogging {
            get { return Current.LoggingProvider; }
        }

        /// <summary>
        /// Creates a new unmanaged connection using a custom configuration.
        /// </summary>
        /// <param name="config">Database configuration.</param>
        /// <returns>An instance of a <c>DatabaseConnection</c> using the given configuration.</returns>
        public static DatabaseConnection CreateConnection(IRuntimeDatabaseConfiguration config) {
            IDatabaseServices databaseServices = config.DatabaseProvider.GetIntegrationDatabaseServices(config);
            return new DatabaseConnection(databaseServices, databaseServices.TransactionService.CreateConnection(), DatabaseBehaviours);
        }

        /// <summary>
        /// Commits all transactions (main transactions only).
        /// </summary>
        public static void CommitAllTransactions() {
            Current.InnerCommitAllTransactions();
        }

        /// <summary>
        /// Rolls back all transactions (main transactions only).
        /// </summary>
        public static void RollbackAllTransactions() {
            Current.InnerRollbackAllTransactions();
        }

        /// <summary>
        /// Releases all transactions (pooled and main), commiting or rollingback depending on the
        /// the value of "commit".
        /// </summary>
        /// <param name="commit">True to commit the transactions, false to rollback.</param>
        public static void FreeupResources(bool commit) {
            if (IsInitialized()) {
                Current.InnerFreeupResources(commit);
            }
        }

        /// <summary>
        /// Finds the correct DatabaseAccessProvider for an unmanaged transaction object.
        /// </summary>
        /// <param name="trans">Unmanaged transaction.</param>
        /// <returns>The <c>IDatabaseAccessProvider</c> based on the given trasaction.</returns>
        [Obsolete("Method used only for compatibility. There should not be any direct use")]
        public static IDatabaseAccessProvider GetProviderForTransaction(IDbTransaction trans) {
            IDatabaseAccessProvider provider;
            TryGetProviderForTransaction(trans, out provider);
            return provider;
        }

        /// <summary>
        /// Finds the correct DatabaseAccessProvider for an unmanaged transaction object, belonging to a particular database.
        /// </summary>
        /// <param name="trans">The unmanaged transaction.</param>
        /// <param name="database"></param>
        /// <returns>The <c>IDatabaseAccessProvider</c> based on the given trasaction to access the given database.</returns>
        [Obsolete("Method used only for compatibility. There should not be any direct use")]
        public static IDatabaseAccessProvider GetProviderForTransaction(IDbTransaction trans, string database) {
            IDatabaseAccessProvider provider;
            TryGetProviderForTransaction(trans, database, out provider);
            return provider;
        }

        /// <summary>
        /// Disable transaction commits for the remaining duration of the current request
        /// NOTE: Leaving this setting set to true will affect all future commit. It should only be changed
        /// inside a 'try .. finally' block, making sure it is set to false in the end.
        /// </summary>
        /// <value><c>true</c> if commits are disabled otherwise, <c>false</c>.</value>
        public static bool DisableCommits { get; set; }

        /// <summary>
        /// Blocks all access to the database while the value is true
        /// NOTE: Leaving this setting set to true will affect all future commit. It should only be changed
        /// inside a 'try .. finally' block, making sure it is set to false in the end
        /// </summary>
        /// <value><c>true</c> if the access to the batabase is blocked otherwise, <c>false</c>.</value>
        public static bool BlockAccess { get; set; }
        #endregion

        #region API implementation

        /// <summary>
        /// The DatabaseAccessProvider responsible for connecting to the OutSystems system database.
        /// </summary>
        /// <value>The <c>IDatabaseAccessProvider</c> to the system database.</value>
        protected internal virtual DatabaseAccessProvider<IPlatformDatabaseServices> SystemProvider {
            get {
                return systemProvider;
            }
            [DoNotObfuscate] // This is called using reflection in tests
            private set {
                systemProvider = value;
            }
        }

        /// <summary>
        /// The DatabaseAccessProvider responsible for connecting to the current main database (that can be the system database) in the the OutSystems database server
        /// </summary>
        /// <value>The <c>IDatabaseAccessProvider</c> to the main database.</value>
        protected internal virtual DatabaseAccessProvider<IPlatformDatabaseServices> CurrentProvider {
            get {
                return GetRuntimeProviderForDatabase(ConfigurationForCurrent());
            }
        }

        protected internal virtual DatabaseAccessProvider<IPlatformDatabaseServices> RuntimeProvider {
            get {
#if SPLIT_DEVELOPMENT
                return runtimeProvider;
#else
                return SystemProvider;
#endif
            }
            private set {
#if SPLIT_DEVELOPMENT
                runtimeProvider = value;
#else
                SystemProvider = value;
#endif
            }
        }

        protected internal virtual IDatabaseAccessProvider<IPlatformDatabaseServices> GetDatabaseProviderForEspace(string eSpaceKey) {
            return GetRuntimeProviderForDatabase(CatalogConfigurationForESpace(eSpaceKey));
        }

        /// <summary>
        /// The DatabaseAccessProvider responsible for connecting to a specific database in the the OutSystems database server
        /// </summary>
        /// <param name="databaseName">Name of the database.</param>
        /// <returns>An object to access the database</returns>
        protected internal virtual DatabaseAccessProvider<IPlatformDatabaseServices> GetDatabaseProvider(string databaseName) {
            return GetRuntimeProviderForDatabase(CatalogConfigurationForCatalogName(databaseName));
        }

        /// <summary>
        /// The DatabaseAccessProvider responsible for connecting to a specific external database connection
        /// </summary>
        /// <param name="connectionName">Name of the connection.</param>
        /// <returns>An object to access the database</returns>
        protected internal virtual DatabaseAccessProvider<IDatabaseServices> GetDBConnectionProvider(string connectionName) {
            connectionName = connectionName.ToUpperInvariant();
            DatabaseAccessProvider<IDatabaseServices> provider;
            if (!dbConnectionProviders.TryGetValue(connectionName, out provider)) {
                lock (dbConnectionProviders) {
                    if (!dbConnectionProviders.TryGetValue(connectionName, out provider)) {
                        ITransactionManager transactionManager = GetTransactionManager(connectionName);
                        provider = new DatabaseAccessProvider<IDatabaseServices>(transactionManager.TransactionService.DatabaseServices, transactionManager);
                        dbConnectionProviders.Add(connectionName, provider);
                    }
                }
            }
            return provider;
        }

        /// <summary>
        /// Gets the transaction manager.
        /// </summary>
        /// <param name="dbConnectionName">Name of the connection.</param>
        /// <returns>An instance of a <c>ITransactionManager</c> for the given connection.</returns>
        internal static ITransactionManager GetTransactionManager(string dbConnectionName) {

            IRuntimeDatabaseConfiguration configuration = null;
            if (HttpContext.Current != null) { //because this can be needed outside webapplications (ex: unit tests)
                AppInfo info = AppInfo.GetAppInfo();
                int eSpaceId = info.eSpaceId;

                var integrationConfiguration =
                    AppCache.GetESpaceCachedValue<string, IIntegrationDatabaseConfiguration>(dbConnectionName,
                        "DatabaseServicesCache" + eSpaceId,
                        eSpaceId,
                        InnerGetDatabaseConfigurationByConnectionName);

                if (info.PlatformExtensibilityAPIsEnabled) {
                    Pair<String, String> connectionStringOverride = info.OsContext.Session.GetDatabaseConnectionOverride(dbConnectionName);
                    if (connectionStringOverride != null && !connectionStringOverride.First.IsEmpty()) {

                        var helper =
                            integrationConfiguration.DatabaseProvider.GetProviderSpecificOrBaseType<DatabaseConfigurationHelper>(
                                DatabaseConfigurationHelper.ProviderSpecificTypes);
                        configuration = helper.ChangeConnectionString(integrationConfiguration, connectionStringOverride.First,
                            connectionStringOverride.Second);
                    }
                }
                if (configuration == null) {
                    configuration = integrationConfiguration.RuntimeDatabaseConfiguration;
                }
            } else {
                configuration = InnerGetDatabaseConfigurationByConnectionName(dbConnectionName).RuntimeDatabaseConfiguration;
            }
            var services = configuration.DatabaseProvider.GetIntegrationDatabaseServices(configuration);
            return services.TransactionService.CreateTransactionManager();
        }

        /// <summary>
        /// Gets database services for the given connection
        /// </summary>
        /// <param name="connectionName">Name of the connection.</param>
        /// <returns>An instance of a <c>IDatabaseServices</c> to the given connection.</returns>
        /// <exception cref="ConnectionNotFoundException"></exception>
        private static IIntegrationDatabaseConfiguration InnerGetDatabaseConfigurationByConnectionName(string connectionName) {
            string config = new RuntimePlatformSettings.ExternalConnections.DBConnectionSetting(connectionName).DBConnection.GetValue();

            if (config.IsNullOrEmpty()) {
                throw new ConnectionNotFoundException(String.Format("Failed to retrieve {0} connection details.", connectionName));
            }

            return Deserializers.ForIntegration(
                        key =>
                            IntegrationDatabasesPluginProvider
                                .GetImplementation(key)
                                .CreateEmptyIntegrationDatabaseConfiguration())
                    .Deserialize(config);
        }

        /// <summary>
        /// Commit all transactions.
        /// </summary>
        protected internal void InnerCommitAllTransactions() {
            if (DisableCommits) {
                return;
            }

            foreach (var dbConnectionProvider in dbConnectionProviders.Values) {
                dbConnectionProvider.CommitAllTransactions();
            }

            foreach (var dbProvider in databaseProviders.Values) {
                dbProvider.CommitAllTransactions();
            }

#if SPLIT_DEVELOPMENT
            RuntimeProvider.CommitAllTransactions();
#endif

            SystemProvider.CommitAllTransactions();
        }

        /// <summary>
        /// Roll back all transactions.
        /// </summary>
        protected internal void InnerRollbackAllTransactions() {
            foreach (var dbConnectionProvider in dbConnectionProviders.Values) {
                dbConnectionProvider.RollbackAllTransactions();
            }

            foreach (var dbProvider in databaseProviders.Values) {
                dbProvider.RollbackAllTransactions();
            }

#if SPLIT_DEVELOPMENT
            RuntimeProvider.RollbackAllTransactions();
#endif

            SystemProvider.RollbackAllTransactions();
        }

        /// <summary>
        /// Freeup resources.
        /// </summary>
        /// <param name="commit">If set to <c>true</c> the transactions will be committed.</param>
        /// <exception cref="TransactionException">Exception launched to when an error occurs trying to close the transaction.</exception>
        [DoNotObfuscate]
        protected internal void InnerFreeupResources(bool commit) {
            string errorMessage = "";
            Exception lastException = null;

            foreach (IDatabaseAccessProvider provider in
                dbConnectionProviders.Values.Cast<IDatabaseAccessProvider>().Concat(databaseProviders.Values.Cast<IDatabaseAccessProvider>())) {
                try {
                    provider.FreeupResources(commit);
                } catch (Exception e) {
                    commit = false;
                    lastException = e;
                    string error = String.Format("Error closing the transaction to the database: {0}\n{1}\n{2}", e.Message, e.StackTrace, new StackTrace(true));
                    EventLogger.WriteError(error);
                    errorMessage = String.Format("{0}\n{1}", errorMessage, error);
                }
            }

#if SPLIT_DEVELOPMENT
            try {
                RuntimeProvider.FreeupResources(commit);
            } catch (Exception e) {
                lastException = e;
                string error = String.Format("Error closing the transaction to the database: {0}\n{1}\n{2}", e.Message, e.StackTrace, new StackTrace(true));
                EventLogger.WriteError(error);
                errorMessage = String.Format("{0}\n{1}", errorMessage, error);
            }
#endif

            try {
                SystemProvider.FreeupResources(commit);
            } catch (Exception e) {
                lastException = e;
                string error = String.Format("Error closing the transaction to the database: {0}\n{1}\n{2}", e.Message, e.StackTrace, new StackTrace(true));
                EventLogger.WriteError(error);
                errorMessage = String.Format("{0}\n{1}", errorMessage, error);
            }

            if (errorMessage != "") {
                throw new TransactionException(errorMessage, lastException);
            }
        }
        #endregion

        #region Compatibility stuff

        /// <summary>
        /// Tries to get a database access based on the given transaction.
        /// </summary>
        /// <param name="trans">The transaction.</param>
        /// <param name="provider">The object to access the database.</param>
        /// <returns><c>true</c> if the <c>IDatabaseAccessProvider</c> could be created, <c>false</c> otherwise.</returns>
        [Obsolete("Method used only for compatibility. There should not be any direct use")]
        internal static bool TryGetProviderForTransaction(IDbTransaction trans, out IDatabaseAccessProvider provider) {
            string databaseName;
            databaseName = trans.Connection.Database.ToUpperInvariant();
            return TryGetProviderForTransaction(trans, databaseName, out provider);
        }

        /// <summary>
        /// Tries to get a database access based on the given transaction.
        /// </summary>
        /// <param name="trans">The transaction.</param>
        /// <param name="databaseName">Name of database to connect to.</param>
        /// <param name="provider">The object to access the database.</param>
        /// <returns><c>true</c> if the <c>IDatabaseAccessProvider</c> could be created, <c>false</c> otherwise.</returns>
        [Obsolete("Method used only for compatibility. There should not be any direct use")]
        internal static bool TryGetProviderForTransaction(IDbTransaction trans, string databaseName, out IDatabaseAccessProvider provider) {
            provider = Current.InnerGetProviderForTransaction(trans, databaseName);
            if (provider != null) {
                return true;
            }
            provider = ForRuntimeDatabase;
            return false;
        }

        /// <summary>
        /// Tries to get a database access based on the given transaction for the database identifier.
        /// </summary>
        /// <param name="trans">The transaction.</param>
        /// <param name="databaseName">Name of database to connect to.</param>
        /// <returns>A database access to the given database identifier.</returns>
        protected internal IDatabaseAccessProvider InnerGetProviderForTransaction(IDbTransaction trans, string databaseName) {
            if (trans != null && trans.Connection != null) {
                DatabaseAccessProvider<IPlatformDatabaseServices> provider;
                if (databaseProviders.TryGetValue(databaseName, out provider)) {
                    return provider;
                }
                if (RuntimeProvider.DatabaseServices.DatabaseConfiguration.DatabaseIdentifier.EqualsIgnoreCase(databaseName)
                        && RuntimeProvider.TransactionManager.IsManaging(trans)) {

                    return RuntimeProvider;
                }
                foreach (var dbConnectionProvider in dbConnectionProviders.Values) {
                    if (dbConnectionProvider.TransactionManager.IsManaging(trans)) {
                        return dbConnectionProvider;
                    }
                }
            }

            return null;
        }

        protected internal static IRuntimeDatabaseConfiguration CatalogConfigurationForESpace(string eSpaceKey) {
            return catalogConfigurationsCacheByEspaceKey.GetOrAdd(eSpaceKey, LoadCatalogConfigurationForESpace);
        }

        private static IRuntimeDatabaseConfiguration LoadCatalogConfigurationForESpace(string eSpaceKey) {
            var catalogName = RuntimePlatformSettings.Catalog.ForModule(eSpaceKey).Catalog.GetValue();
            if (catalogName.IsNullOrEmpty() || catalogName == Constants.MainDatabaseLogicalName) {
                return null;
            }
            return CatalogConfigurationForCatalogName(catalogName);
        }

        protected internal static IRuntimeDatabaseConfiguration CatalogConfigurationForCatalogName(string catalogName) {
            return catalogConfigurationsCacheByCatalogName.GetOrAdd(catalogName, LoadCatalogConfigurationForCatalogName);
        }

        private static IRuntimeDatabaseConfiguration LoadCatalogConfigurationForCatalogName(string catalogName) {
            var details = RuntimePlatformSettings.Catalog.Configuration(catalogName).All;
            if (details == null) {
                return null;
            }

            var conf = RuntimeDatabaseConfigurations.For(
                PlatformDatabasePluginProvider,
                DatabaseSettingsSerialization.Source.Application,
                DatabaseSettingsSerialization.User.Runtime,
                DatabaseSettingsSerialization.DataSpace.Business,
                RuntimeSettingsProvider.Instance);

            conf.SetParameters(details);
            return conf;
        }

        private static IRuntimeDatabaseConfiguration ConfigurationForCurrent() {
            HttpContext context = HttpContext.Current;
            if (context != null) {
                AppInfo app;
                try {
                    app = AppInfo.GetAppInfo(context);
                } catch (LicensingException) {
                    return null; // Fallback to the Runtime Catalog
                }
                if (app != null) {
                    return CatalogConfigurationForESpace(ObjectKeyUtils.DatabaseValue(app.OsContext.CurrentESpaceKey));
                }
            }
            return null;
        }
        #endregion

        #region Utilities

        protected static DatabaseAccessProvider<IPlatformDatabaseServices> GetProviderForDatabase(IRuntimeDatabaseConfiguration configurationForDatabase,
                DatabaseSettingsSerialization.User user, DatabaseAccessProvider<IPlatformDatabaseServices> baseProvider,
                IDictionary<string, DatabaseAccessProvider<IPlatformDatabaseServices>> providersByIdentifier,
                IDictionary<string, ITransactionManager> transactionManagersByIdentifier) {

            if (configurationForDatabase == null) {
                return baseProvider;
            }

            // ***************** MDC STUFF ***************************
            var databaseConfig = baseProvider.DatabaseServices.DatabaseConfiguration;

            string managerIdentifier = configurationForDatabase.Username;
            string databaseManagerIdentifier = databaseConfig.Username;

            bool sameIdentifier = managerIdentifier.EqualsIgnoreCase(databaseManagerIdentifier);
            // If using the system manager to access the system database, we can use the SystemProvider
            bool sameDatabase = configurationForDatabase.DatabaseIdentifier.EqualsIgnoreCase(databaseConfig.DatabaseIdentifier);

            if (sameIdentifier && sameDatabase) {
                return baseProvider;
            }

            // In unified MDC scenarios, we want to use a provider with a shared transaction manager 
            // while keeping the original configuration that uses the correct database identifier
            string providerIdentifier = managerIdentifier + "-" + configurationForDatabase.DatabaseIdentifier;
            DatabaseAccessProvider<IPlatformDatabaseServices> provider;
            if (!providersByIdentifier.TryGetValue(providerIdentifier, out provider)) {
                lock (providersByIdentifier) {
                    if (!providersByIdentifier.TryGetValue(providerIdentifier, out provider)) {
                        ITransactionManager manager = sameIdentifier ? baseProvider.TransactionManager : null;
                        if (manager == null && !transactionManagersByIdentifier.TryGetValue(managerIdentifier, out manager)) {
                            var services = PlatformDatabasePluginProvider
                                            .GetImplementation(configurationForDatabase.DatabaseProvider.Key)
                                            .GetPlatformDatabaseServices(configurationForDatabase);
                            manager = services.TransactionService.CreateTransactionManager();
                            transactionManagersByIdentifier.Add(managerIdentifier, manager);
                        }

                        // TODO: Check with the Stack Team if we can optimized this
                        var dapServices = PlatformDatabasePluginProvider
                                            .GetImplementation(configurationForDatabase.DatabaseProvider.Key)
                                            .GetPlatformDatabaseServices(configurationForDatabase);

                        provider = new DatabaseAccessProvider<IPlatformDatabaseServices>(
                                        dapServices,
                                        manager);

                        providersByIdentifier.Add(providerIdentifier, provider);
                    }
                }
            }
            // ***************** MDC STUFF ***************************
            return provider;
        }

        protected static DatabaseAccessProvider<IPlatformDatabaseServices> CreatePlatformDatabaseAccessProvider(
                DatabaseSettingsSerialization.Source source,
                DatabaseSettingsSerialization.User user,
                DatabaseSettingsSerialization.DataSpace dataSpace,
                ISettingsProvider settingsProvider) {

            var pluginProvider = PlatformDatabasePluginProvider;

            IRuntimeDatabaseConfiguration conf = RuntimeDatabaseConfigurations.For(pluginProvider, source, user, dataSpace, settingsProvider);

            if (conf == null || conf.ConnectionString.IsEmpty()) {
                throw new InvalidOperationException("Unable to obtain the connection string. Please run Configuration Tool.");
            }

            var services = pluginProvider.GetImplementation(conf.DatabaseProvider.Key).GetPlatformDatabaseServices(conf);
            return new DatabaseAccessProvider<IPlatformDatabaseServices>(
                services,
                services.TransactionService.CreateTransactionManager());
        }

        private static IEnumerable<DirectoryInfo> GetPluginPaths() {
            var currentDir = new DirectoryInfo(Path.GetDirectoryName(new Uri(typeof(DatabaseAccess).Assembly.CodeBase).LocalPath));

            var pluginsDir = new DirectoryInfo(Path.Combine(currentDir.FullName, "plugins", "database"));
            if (pluginsDir.Exists) { // if the plugins path exists, only use that
                yield return pluginsDir;
            } else {
                if (HttpContext.Current != null) {
                    yield return currentDir;
                }
            }
        }

        /// <summary>
        /// Checks the access to the <c>DatabaseAccess</c>.
        /// </summary>
        /// <param name="name">The element name.</param>
        /// <exception cref="InvalidDatabaseAccessException">Blocked access when trying to to access 'DatabaseAccess. + name + '.</exception>
        private static void CheckAccess(string name) {
            if (BlockAccess) {
                throw new InvalidDatabaseAccessException("Blocked access when trying to to access 'DatabaseAccess." + name + "'.");
            }
        }

        public static T ExecuteWithoutRequestTimeout<T>(Func<T> action)
        {
            if (HttpContext.Current == null)
            {
                return action();
            }
            else
            {
                int oldScriptTimeout = RuntimePlatformUtils.GetScriptTimeout();
                try
                {
                    // ScriptTimeout requires a positive number so we need to set to int.MaxValue to "disable" request timeouts
                    // https://forums.asp.net/t/1925766.aspx?Httpruntime+ExecutionTimeOut+
                    // https://referencesource.microsoft.com/#system.web/httpserverutility.cs,f8f47afb04ad1133,references
                    RuntimePlatformUtils.SetScriptTimeout(int.MaxValue);
                    return action();
                }
                finally
                {
                    RuntimePlatformUtils.SetScriptTimeout(oldScriptTimeout);
                }
            }
        }
        #endregion

        #region Query Timeout
        /// <summary>
        /// Gets or sets the query timeout, in seconds.
        /// </summary>
        /// <value>The query timeout, in seconds.</value>
        public static int QueryTimeout {
            get {
                if (queryTimeout == UninitializedQueryTimeout) {
                    queryTimeout = RuntimePlatformSettings.Queries.QueryTimeout.GetValue();
                }
                return queryTimeout;
            }
            set {
                queryTimeout = value;
            }
        }

        #endregion

        #region Slow Queries Logging
        // We shouldn't log slow queries in configuration tool:
        public static bool SkipSlowQueries { get; set; }

        // Queries that take more than "SlowQueryThreshold" miliseconds are logged in oslog_general as slow queries.
        internal static int SlowQueryThreshold {
            get {
                // must avoid loophole of Settings Getter wanting to know if it was a slow query
                // and calling this method again that will call the Settings Getter again and so on...
                if (!isQueryThresholdLoaded) {
                    lock (queryThresholdLockObject) {
                        if (!isQueryThresholdLoaded) {
                            if (isQueryThresholdLoading) {
                                return Int32.MaxValue;
                            }
                            isQueryThresholdLoading = true;
                            queryThreshold = RuntimeSettingsProvider.Instance.Get(RuntimePlatformSettings.Queries.SlowQueryInMs);
                            isQueryThresholdLoaded = true;
                        }
                    }
                }

                return queryThreshold;
            }
            set {
                queryThreshold = value;
            }
        }

        internal static void LogSlowQuery(DateTime logTime, string log) {
            if (SkipSlowQueries) {
                return;
            }

            string sessionid = "";
            int espaceid = 0, tenantid = 0, userid = 0;

            if (HttpContext.Current != null) { // if inside a web application
                AppInfo.GetAppInfoInformation(out espaceid, out tenantid, out sessionid, out userid);
                // if this is a query to get AppInfo information -> do not log
                if (espaceid == 0) { return; }
            }

            GeneralLog.StaticWrite(logTime, sessionid, espaceid, tenantid, userid, log, GeneralLogType.WARNING.ToString(),
                "SLOWSQL", "");
        }
        #endregion


        protected internal IDatabaseAccessProvider<IPlatformDatabaseServices> SessionProvider {
            get {
                var source = settingsProvider.Get<bool>(RuntimePlatformSettings.Application.IsApplication) ? DatabaseSettingsSerialization.Source.Application : DatabaseSettingsSerialization.Source.Services;

                if (sessionProvider == null) {
                    lock (_sessionProviderLockObject) {
                        if (sessionProvider == null) {
                            sessionProvider = CreatePlatformDatabaseAccessProvider(source, DatabaseSettingsSerialization.User.Session, DatabaseSettingsSerialization.DataSpace.Platform, settingsProvider);
                        }
                    }

                }
                return sessionProvider;
            }
        }

        protected internal IDatabaseAccessProvider<IPlatformDatabaseServices> LoggingProvider {
            get {
                var source = settingsProvider.Get<bool>(RuntimePlatformSettings.Application.IsApplication) ? DatabaseSettingsSerialization.Source.Application : DatabaseSettingsSerialization.Source.Services;

                if (loggingProvider == null) {
                    lock (_loggingProviderLockObject) {
                        if (loggingProvider == null) {
                            loggingProvider = CreatePlatformDatabaseAccessProvider(source, DatabaseSettingsSerialization.User.Runtime, DatabaseSettingsSerialization.DataSpace.Logging, settingsProvider);
                        }
                    }

                }
                return loggingProvider;
            }
        }
    }

    /// <summary>
    /// Class that represents an exception that occurs due to an invalid access to a database.
    /// </summary>
    public class InvalidDatabaseAccessException : Exception {
        public InvalidDatabaseAccessException(string message) : base(message) { }
    }

    /// <summary>
    /// Exception that represents an error that occurs due to an external database connection configuration not found in the database.
    /// </summary>
    public class ConnectionNotFoundException : Exception {
        public ConnectionNotFoundException(string message) : base(message) { }
    }
}
