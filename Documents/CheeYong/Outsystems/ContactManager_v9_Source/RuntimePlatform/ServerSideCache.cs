/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using OutSystems.HubEdition.RuntimePlatform.Internal.Cache;
using OutSystems.RuntimeCommon;
using OutSystems.RuntimeCommon.Caching;
using OutSystems.RuntimeCommon.Settings;

namespace OutSystems.HubEdition.RuntimePlatform {
    public class ServerSideCache : ICache {
        private readonly ICache cacheImplementation;
        private ISettingsProvider settingsProvider;
        private CachePluginProvider pluginProvider;

        public ServerSideCache(ISettingsProvider settingsProvider, CachePluginProvider pluginProvider, string cacheInstanceKey = null) {

            this.settingsProvider = settingsProvider;
            this.pluginProvider = pluginProvider;


            if (this.settingsProvider.Get(RuntimePlatformSettings.Plugin.CacheInvalidation.EnableRabbitMQCacheInvalidation)) {
                var providerKey = settingsProvider.Get(RuntimePlatformSettings.Plugin.CacheInvalidation.CacheProviderKey);
                var provider = pluginProvider.GetImplementation(providerKey, (_) => null);
                if (provider != null) {
                    this.cacheImplementation = provider.GetImplementation(settingsProvider, cacheInstanceKey);
                }
            }

            if(this.cacheImplementation == null) {
                this.cacheImplementation = new FileBasedPubSubCache(settingsProvider, executor: null, cacheInstanceKey: cacheInstanceKey);
            }
        }

        public void Clear() {
            this.cacheImplementation.Clear();
        }

        public void Listen(ICacheKey key, ICacheDependency dependency, CacheItemInvalidationCallback invalidationCallback) {
            this.cacheImplementation.Listen(key, dependency, invalidationCallback);
        }

        public object StopListen(ICacheKey key) {
            return this.cacheImplementation.StopListen(key);
        }

        public void Invalidate(ICacheInvalidationKey invalidationKey) {
            this.cacheImplementation.Invalidate(invalidationKey);
        }

        public void Add(ICacheKey key, object value, ICacheDependency dependency, DateTime expirationDate, TimeSpan slidingSpan, CacheItemPriority priority) {
            this.cacheImplementation.Add(key, value, dependency, expirationDate, slidingSpan, priority);
        }

        public object Get(ICacheKey key) {
            return this.cacheImplementation.Get(key);
        }

        public object GetOrAdd(ICacheKey key, CacheItemValueGetter getter, ICacheDependency dependency, DateTime expirationDate, TimeSpan slidingSpan, CacheItemPriority priority) {
            return this.cacheImplementation.GetOrAdd(key, getter, dependency, expirationDate, slidingSpan, priority);
        }

        public bool IsAvailable() {
            return this.cacheImplementation.IsAvailable();
        }

        public bool IsAvailable(out Exception ex) {
            return this.cacheImplementation.IsAvailable(out ex);
        }

        public void Dispose() {
            cacheImplementation?.Dispose();
        }
    }
}
