/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.IO;
using System.IO.Compression;
using System.Reflection;
using System.Web;
using OutSystems.RuntimeCommon;

namespace OutSystems.HubEdition.RuntimePlatform {
    public class HttpCompressionModule {

        private const string GZIP_ENCODING = "gzip";
        private const string DEFLATE_ENCODING = "deflate";

        public static void OnBeginRequest(object sender, EventArgs e) {
            if (!CompressHttpAjaxResponses)
                return;

            HttpApplication app = sender as HttpApplication;

            if (HeContext.IsAjaxRequestFromContext(app.Context)) {
                FixDeflateStreamImplementation(); // Fix DeflateStream implemenation to allow partial flush operations. Note: GZipStream also uses Deflate internally.

                if (IsEncodingAccepted(GZIP_ENCODING)) {
                    app.Response.Filter = new SafeGZipStream(app.Response.Filter, CompressionMode.Compress);
                    SetEncoding(GZIP_ENCODING);
                } else if (IsEncodingAccepted(DEFLATE_ENCODING)) {
                    app.Response.Filter = new SafeDeflateStream(app.Response.Filter, CompressionMode.Compress);
                    SetEncoding(DEFLATE_ENCODING);
                }
            }
        }

        // This is needed, because when we have compression the compression filter stream
        // may not be closed by the framework when the request ends.
        // So we need to explicitly close the stream when this happens.
        public static void OnEndRequest(object sender, EventArgs e) {
            if (!CompressHttpAjaxResponses)
                return;

            HttpApplication app = sender as HttpApplication;
            ISafeCompressionStream compressionStream = app.Response.Filter as ISafeCompressionStream;

            if (compressionStream != null && compressionStream.CanWrite)
                compressionStream.Close();
        }

        private static bool CompressHttpAjaxResponses {
            get {
                return RuntimePlatformSettings.Misc.CompressHttpAjaxResponse.GetValue();
            }
        }

        private static bool IsEncodingAccepted(string encoding) {
            // Firefox uses Accept-encoding and IE uses Accept-Encoding
            string acceptEncoding = HttpContext.Current.Request.Headers["accept-encoding"];
            if (acceptEncoding == null)
                acceptEncoding = HttpContext.Current.Request.Headers["Accept-encoding"];
            if (acceptEncoding == null)
                acceptEncoding = HttpContext.Current.Request.Headers["Accept-Encoding"];

            return acceptEncoding != null && acceptEncoding.Contains(encoding);
        }
        private static void SetEncoding(string encoding) {
            HttpContext.Current.Response.AppendHeader("Content-encoding", encoding);
        }

        #region Safe compression streams and sink manipulation

        internal static void AllowFilteringInSinkAfterEndRequest(Stream sinkStream) {
            // Allows the filter to work in the HTTP response sink, even though
            // the EndRequest event was already raised, and filtering should have
            // been already completed
            PropertyInfo filtering = sinkStream.GetType().GetProperty("Filtering", BindingFlags.Instance | BindingFlags.NonPublic);
            if (filtering.CanWrite) {
                filtering.SetValue(sinkStream, true, null);
            }
        }

        internal interface ISafeCompressionStream {
            bool CanWrite { get; }
            void Close();
        }
        
        internal class SafeDeflateStream : DeflateStream, ISafeCompressionStream {
            public SafeDeflateStream(Stream stream, CompressionMode mode)
                : base(stream, mode) {
            }
            
            public override void Close() {
                try {
                    HttpCompressionModule.AllowFilteringInSinkAfterEndRequest(this.BaseStream);
                } catch {
                } finally {
                    base.Close();
                }
            }
        }
        
        internal class SafeGZipStream : GZipStream, ISafeCompressionStream {
            public SafeGZipStream(Stream stream, CompressionMode mode)
                : base(stream, mode) {
            }

            public override void Close() {
                try {
                    HttpCompressionModule.AllowFilteringInSinkAfterEndRequest(this.BaseStream);
                } catch {
                    // Ignore the exception, we have done our best
                } finally {
                    base.Close();
                }
            }
        }

        private static volatile bool deflateStreamImplementationFixed = false;

        /// <summary>
        /// This is necessary to because the ZLibNative implementation does not allow partial flush operations
        /// </summary>
        private static void FixDeflateStreamImplementation() {
            if(!deflateStreamImplementationFixed) {
                lock(typeof(HttpCompressionModule)) {
                    if(!deflateStreamImplementationFixed) {
                        Type deflateStreamClass = typeof(System.IO.Compression.DeflateStream);
                        var deflaterTypeField = deflateStreamClass.GetField("deflaterType", BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Public);
                        Type WorkerTypeEnum = deflateStreamClass.GetNestedType("WorkerType", BindingFlags.NonPublic | BindingFlags.Public);
                        if (deflaterTypeField != null && WorkerTypeEnum != null) {
                            deflaterTypeField.SetValue(null, Enum.Parse(WorkerTypeEnum, "Managed"));
                        }
                        deflateStreamImplementationFixed = true;
                    }
                }
            }
        }

        #endregion
    }
}