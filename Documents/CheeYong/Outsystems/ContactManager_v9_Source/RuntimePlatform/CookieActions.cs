/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Data;
using System.Linq;
using System.Web;
using OutSystems.HubEdition.RuntimePlatform.Log;
using OutSystems.Internal.Db;
using OutSystems.RuntimeCommon;
using OutSystems.RuntimeCommon.ObfuscationProperties;
using System.Web.Configuration;
using System.Configuration;

namespace OutSystems.HubEdition.RuntimePlatform {
    public class CookieActions {
        public static string GetSessionCookieName() {
            SessionStateSection sessionStateSection = (System.Web.Configuration.SessionStateSection)ConfigurationManager.GetSection("system.web/sessionState");
            return sessionStateSection.CookieName;
        }

        public static readonly string SESSION_COOKIE_PATH = "/";
        public static readonly string SESSION_FIXATION_PROTECTION_COOKIE_PATH = "/";

        //#1117818 The cookie applies to all espaces that share the same user provider
        public static readonly string PERSISTENT_LOGIN_COOKIE_PATH = "/";

        private static readonly Lazy<Random> random = new Lazy<Random>(
            () => RandomGenerator.GetSecureRandomGenerator()
        );

        private static Random GetSecureRandom() {
            return random.Value;
        }

        private static ulong GetRandomLongNumber() {
            byte[] rnd_bytes = new byte[8];
            GetSecureRandom().NextBytes(rnd_bytes);
            return BitConverter.ToUInt64(rnd_bytes, 0);
        }

        private static bool UseSessionFixationProtection() {
            return RuntimePlatformSettings.Security.EnableSessionFixationProtection.GetValue();
        }

        // We could just call Cookies.Get, but that stuff has different behaviour in .Net 
        // (returns the cookie, or creates a new one if it does not exist and returns it)
        // and Java (returns the cookie, null if it does not exist), so we call a different operation depending on the language
        public static HttpCookie GetCookieByName(HttpCookieCollection cookies, String cookieName) {
            if (cookies == null) {
                return null;
            }

            if (cookies.AllKeys.Contains(cookieName)) {
                return cookies[cookieName];
            }

            return null;
        }

        internal static void GetPersistentLoginInfo(HeContext heContext, Transaction trans, String currentPersistentLoginValue, out int userId, out int tenantId, out int existingPersistentLoginId, out DateTime expires, string operationName) {
            // This method is not protected by UseSessionFixationProtection() on purpose
            // What happens here is supposed to happen, regardless of the value of that setting

            userId = 0;
            tenantId = 0;
            existingPersistentLoginId = 0;
            expires = default(DateTime);

            if (String.IsNullOrEmpty(currentPersistentLoginValue)) {
                return;
            }

            AppInfo info = heContext.AppInfo;
            DBRuntimePlatform.Instance.GetPersistentLoginInfo(trans, info.eSpaceId, currentPersistentLoginValue, heContext.Session.TerminalType, out userId, out tenantId, out existingPersistentLoginId, out expires, operationName);
        }

        /// <summary>
        /// Adds a new persistent login entry.
        /// If there is already a valid persistent login entry being used, refresh it with a new value to prevent fixation issues.
        /// </summary>
        internal static void AddOrRefreshPersistentLoginCookie(HeContext heContext, int userId, string operationName) {
            if (!heContext.IsReadOnlySessionRequest) {

                // This needs to be one in a separate transaction, or presistent login cookie would become invalid if the main transaction is rollbacked
                using (Transaction committableTrans = DatabaseAccess.ForRuntimeDatabase.GetCommitableTransaction()) {
                    int existingUserId = 0;
                    int existingTenantId = 0;
                    int existingPersistentLoginId = 0;
                    DateTime existingExpirationDateTime;
                    string persistentLoginValue = GetPersistentLoginValue(heContext);
                    GetPersistentLoginInfo(heContext, committableTrans, persistentLoginValue, out existingUserId, out existingTenantId, out existingPersistentLoginId, out existingExpirationDateTime, operationName);
                    AddOrUpdatePersistentLoginEntryAndCookie(heContext, committableTrans, heContext.Session.TenantId, userId, existingPersistentLoginId, existingExpirationDateTime, operationName);
                    committableTrans.Commit();
                }

            }
        }

        /// <summary>
        /// Refresh persistent cookie value with a new value to prevent fixation issues. This method won't create new persistent login entries.
        /// </summary>
        internal static void RefreshPersistentLoginCookie(HeContext heContext, int persistentLoginId, DateTime expirationDateTime, string operationName) {
            if (!heContext.IsReadOnlySessionRequest && persistentLoginId != 0) {

                // This needs to be one in a separate transaction, or presistent login cookie would become invalid if the main transaction is rollbacked
                using (Transaction committableTrans = DatabaseAccess.ForRuntimeDatabase.GetCommitableTransaction()) {
                    AddOrUpdatePersistentLoginEntryAndCookie(heContext, committableTrans, heContext.Session.TenantId, heContext.Session.UserId, persistentLoginId, expirationDateTime, operationName);
                    committableTrans.Commit();
                }
            }
        }

        public static void ValidateSessionFixationCookieAgainstSession(HeContext heContext) {
            // Process SessionFixationProtection cookie
            if (!heContext.IsReadOnlySessionRequest) {
                if (RuntimePlatformSettings.Security.EnableSessionFixationProtection.GetValue() && heContext.Session.TerminalType == "WEB") {
                    string protectionValueInSession = heContext.Session.SessionFixationProtection;
                    if (protectionValueInSession != null && heContext.PendingSessionProtectionValidation) {
                        HttpCookie protectionValueCookie = GetCookieByName(heContext.Context.Request.Cookies, heContext.AppInfo.SessionFixationProtectionCookieName);
                        heContext.PendingSessionProtectionValidation = false;
              
                        if (protectionValueCookie == null || (protectionValueCookie != null && !protectionValueInSession.Equals(protectionValueCookie.Value))) {
                            if (RuntimePlatformSettings.Security.DebugSessionFixationProtection.GetValue()) {
                                GeneralLog.StaticWrite(DateTime.Now, heContext.Session.SessionID, heContext.AppInfo.eSpaceId, 0, heContext.Session.UserId, 
                                    "Session fixation mismatch with current cookie (session:" + protectionValueInSession + " cookie:" + (protectionValueCookie == null ? "null" : protectionValueCookie.Value) + ")", "INFO", "SESSION", null);
                            }
                            var protectionValueCookieValue = protectionValueCookie == null || protectionValueCookie.Value == null ? "" : protectionValueCookie.Value;
                            if (DateTime.Now < heContext.Session.SessionFixationProtectionExpirationInstant && heContext.Session.SessionFixationProtectionOld.Equals(protectionValueCookieValue)) {
                                //previous session fixation cookie still accepted within the timeframe
                                //send current cookie again
                                HttpCookie cookie = new HttpCookie(heContext.AppInfo.SessionFixationProtectionCookieName, heContext.Session.SessionFixationProtection);
                                cookie.Path = SESSION_FIXATION_PROTECTION_COOKIE_PATH;
                                SecureCookieUtils.setSecureCookie(cookie, heContext.Context.Response);
                                if (RuntimePlatformSettings.Security.DebugSessionFixationProtection.GetValue()) {
                                    GeneralLog.StaticWrite(DateTime.Now, heContext.Session.SessionID, heContext.AppInfo.eSpaceId, 0, heContext.Session.UserId, 
                                        "(repeat) CurrentSessionFixationProtectionCookie (" + heContext.Session.SessionFixationProtection + ")", "INFO", "SESSION", null);
                                }
                                return;
                            }
                            if (RuntimePlatformSettings.Security.DebugSessionFixationProtection.GetValue()) {
                                GeneralLog.StaticWrite(DateTime.Now, heContext.Session.SessionID, heContext.AppInfo.eSpaceId, 0, heContext.Session.UserId, "Session fixation mismatch with old cookie (old:" + heContext.Session.SessionFixationProtectionOld + " cookie:" + (protectionValueCookie == null ? "null" : protectionValueCookie.Value) + ")", "INFO", "SESSION", null);
                            }
                            // Clear the session cookie to avoid locking the user to an invalid session in the next request. This might not work when we have session cookies bound to the domain,
                            // but it would help the rare case when people get locked with no reason to simply retry the request and continue.
                            DeleteSessionCookie(heContext);
							throw new Exception("Session fixation mismatch");
                        }
                    }
                }
            }
        }

        public static void AddSessionFixationProtectionCookie(HeContext heContext) {
            if (UseSessionFixationProtection()) {
                if (!heContext.IsReadOnlySessionRequest) {
                    if (StringUtils.EqualsIgnoreCase(heContext.Session.TerminalType, "WEB")) {
                        string randomPart = String.Empty + GetRandomLongNumber() + GetRandomLongNumber();
                        HttpCookie protectionValueCookie = GetCookieByName(heContext.Context.Request.Cookies, heContext.AppInfo.SessionFixationProtectionCookieName);
                        heContext.Session.SessionFixationProtectionOld = protectionValueCookie == null ? "" : protectionValueCookie.Value;
                        heContext.Session.SessionFixationProtection = randomPart;
                        heContext.PendingSessionProtectionValidation = false;
                        HttpCookie cookie = new HttpCookie(heContext.AppInfo.SessionFixationProtectionCookieName, randomPart);
                        cookie.Path = SESSION_FIXATION_PROTECTION_COOKIE_PATH;
                        SecureCookieUtils.setSecureCookie(cookie, heContext.Context.Response);
                        if (RuntimePlatformSettings.Security.DebugSessionFixationProtection.GetValue()) {
							GeneralLog.StaticWrite(DateTime.Now, heContext.Session.SessionID, heContext.AppInfo.eSpaceId, 0, heContext.Session.UserId, "OldSessionFixationProtectionCookie (" + heContext.Session.SessionFixationProtectionOld + "); NewSessionFixationProtectionCookie(" + heContext.Session.SessionFixationProtection + ")", "INFO", "SESSION", null);

						}
                        heContext.Session.SessionFixationProtectionExpirationInstant = DateTime.Now.AddSeconds(RuntimePlatformSettings.Security.SessionFixationAllowedOverlapWindowInSecs.GetValue());
                    }
                }
            }
        }

        internal static void DeleteCookie(HeContext heContext, string cookieName, string cookiePath) {
            var cookie = GetCookieByName(heContext.Context.Request.Cookies, cookieName);
            if (cookie != null) {
                cookie.Value = String.Empty;
                cookie.Path = cookiePath;
                cookie.Expires = DateTime.Now;

                SecureCookieUtils.setSecureCookie(cookie, heContext.Context.Response);
            }
        }

        [DoNotObfuscate]
        internal static void DeleteSessionCookie(HeContext heContext) {
            var cookie = new HttpCookie(GetSessionCookieName(), "");
            cookie.Path = SESSION_COOKIE_PATH;
            HttpContext.Current.Response.Cookies.Add(cookie);
        }


        [DoNotObfuscate]
        internal static void DeletePersistentLoginCookie(HeContext heContext) {
            if (!heContext.IsReadOnlySessionRequest) {
                DeleteCookie(heContext, heContext.AppInfo.PersitentLoginCookieName, PERSISTENT_LOGIN_COOKIE_PATH);
            }
        }

        internal static String GetPersistentLoginValue(HeContext heContext) {
            HttpCookie cookie = GetCookieByName(HttpContext.Current.Request.Cookies, heContext.AppInfo.PersitentLoginCookieName);
            string cookieValue = ((cookie != null) ? cookie.Value : string.Empty);

            if (!String.IsNullOrEmpty(cookieValue) && cookieValue.Length > 5) { // Keeping the old logic from AutoLogin
                return cookieValue;
            } else {
                return null;
            }
        }

        public static void DeleteAllPersistentLoginEntries(int userId, string operationName) {
            using (Transaction committableTrans = DatabaseAccess.ForRuntimeDatabase.GetCommitableTransaction()) {
                // Delete from web runtime
                DBRuntimePlatform.Instance.DeletePersistentLoginForUser(committableTrans, userId, operationName);
                // Delete from mobile runtime 
                DBRuntimePlatform.Instance.MobileLoginDeleteByUser(committableTrans, userId);

                // No need to delete the cookie as it will be invalid anyway and removed on the next request or set if there is a subsequent login
                committableTrans.Commit();
            }
        }

        public static void DeletePersistentLoginEntryAndCookie(HeContext heContext, string operationName) {
            String persistentLoginValue = GetPersistentLoginValue(heContext);

            if (String.IsNullOrEmpty(persistentLoginValue)) { // Optimize here to avoid going into the database

                using (Transaction committableTrans = DatabaseAccess.ForRuntimeDatabase.GetCommitableTransaction()) {
                    DeletePersistentLoginEntry(heContext, committableTrans, persistentLoginValue, operationName);
                    DeletePersistentLoginCookie(heContext);
                    committableTrans.Commit();
                }

            }
        }

        private static void DeletePersistentLoginEntry(HeContext heContext, Transaction trans, string currentPersistentLoginValue, string operationName) {
            int userId = 0;
            int tenantId = 0;
            int existingPersistentLoginId = 0;
            DateTime expires;

            GetPersistentLoginInfo(heContext, trans, currentPersistentLoginValue, out userId, out tenantId, out existingPersistentLoginId, out expires, operationName);
            if (existingPersistentLoginId > 0) {
                DBRuntimePlatform.Instance.DeletePersistentLoginEntry(trans, existingPersistentLoginId, operationName);
            }
        }

        private static void AddOrUpdatePersistentLoginEntryAndCookie(HeContext heContext, Transaction trans, int tenantId, int userId, int persistentLoginId, DateTime expirationDateTime, string operationName) {
            if (persistentLoginId == 0 || expirationDateTime == DateTime.MinValue) {
                int daysToRememberLogin = RuntimePlatformSettings.Authentication.RememberLoginTimeoutInDays.GetValue();
                TimeSpan timeSpan = new TimeSpan(daysToRememberLogin, 0, 0, 0);
                expirationDateTime = DateTime.Now.Add(timeSpan);
            }

            // This method is not protected by UseSessionFixationProtection() on purpose
            // What happens here is supposed to happen, regardless of the value of that setting
            
            string cookieValue = Guid.NewGuid().ToString();
            DBRuntimePlatform.Instance.AddOrUpdatePersistentLoginEntry(trans, persistentLoginId, tenantId, userId, cookieValue, expirationDateTime, /*terminalType*/"WEB", operationName);

            HttpCookie cookie = new HttpCookie(heContext.AppInfo.PersitentLoginCookieName, cookieValue) {
                Path = PERSISTENT_LOGIN_COOKIE_PATH,
                Expires = expirationDateTime
            };
            SecureCookieUtils.setSecureCookie(cookie, heContext.Context.Response);
        }
    }
}
