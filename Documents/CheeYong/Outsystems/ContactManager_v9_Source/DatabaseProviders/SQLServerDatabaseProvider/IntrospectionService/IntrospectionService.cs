/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using OutSystems.HubEdition.DatabaseProvider.SqlServer.DatabaseObjects;
using OutSystems.HubEdition.DatabaseProvider.SqlServer.DMLService;
using OutSystems.HubEdition.Extensibility.Data;
using OutSystems.HubEdition.Extensibility.Data.DatabaseObjects;
using OutSystems.HubEdition.Extensibility.Data.DMLService;
using OutSystems.HubEdition.Extensibility.Data.IntrospectionService;
using OutSystems.RuntimeCommon;

namespace OutSystems.HubEdition.DatabaseProvider.SqlServer.IntrospectionService {

    public class IntrospectionService : BaseIntrospectionService {

        public IntrospectionService(IDatabaseServices databaseServices) : base(databaseServices) { }

        public override IEnumerable<IDatabaseInfo> ListDatabases() {
            return ListDatabases(false);
        }

        protected IEnumerable<IDatabaseInfo> ListDatabases(bool includeLinkedServers) {
            IList<IDatabaseInfo> databases = GetLocalDatabases().ToList();
            if (includeLinkedServers) {
                foreach (var linkedServer in GetLinkedServers()) {
                    try {
                        foreach (var dbInfo in GetLinkedDatabases(linkedServer)) {
                            databases.Add(dbInfo);
                        }
                    } catch (Exception e) {
                        LogException(e, "Error accessing linked server: " + linkedServer);
                    }
                }
            }
            return databases;
        }

        public override IEnumerable<ITableSourceInfo> ListTableSources(IDatabaseInfo database, IsTableSourceToIgnore isTableSourceToIgnore) {
            DatabaseInfo dbInfo = database as DatabaseInfo;
            if (dbInfo == null) {
                throw new IntrospectionServiceException("Expected " + typeof(DatabaseInfo).FullName + " type but found " +
                                                        (database == null ? "NULL" : database.GetType().FullName));
            }
            if (!CheckDatabaseExists(dbInfo)) {
                throw new IntrospectionServiceException("Database not found: " + dbInfo.Identifier);
            }

            using (IDbConnection conn = DatabaseServices.TransactionService.CreateConnection()) {
                using (IDbCommand cmd = CreateListTableSourcesCommand(dbInfo, conn)) {
                    cmd.CommandTimeout = QueryTimeout;
                    using (IDataReader reader = cmd.ExecuteReader()) {
                        while (reader.Read()) {
                            string tableName = Convert.ToString(reader["TABLE_NAME"]);
                            if (!dbInfo.IsLinkedServer && isTableSourceToIgnore(tableName)) {
                                continue;
                            }
                            string tableSchema = Convert.ToString(reader["TABLE_SCHEM"]);

                            yield return new TableSourceInfo(DatabaseServices, dbInfo, tableName, tableSchema,
                                GetQualifiedTableName(dbInfo, tableName, tableSchema));
                        }
                    }
                }
            }
        }

        private IDbCommand CreateListTableSourcesCommand(DatabaseInfo dbInfo, IDbConnection conn) {
            if (dbInfo.IsLinkedServer) {
                string dbNameParam = DatabaseServices.ExecutionService.ParameterPrefix + "dbName";
                string serverNameParam = DatabaseServices.ExecutionService.ParameterPrefix + "serverName";
                var cmd = DatabaseServices.ExecutionService.CreateCommand(conn,
                    "exec sp_tables_ex " + serverNameParam + ", NULL, NULL, " + dbNameParam + ", \"'TABLE'|'VIEW'\"");
                DatabaseServices.ExecutionService.CreateParameter(cmd, serverNameParam, DbType.String, dbInfo.LinkedServer);
                DatabaseServices.ExecutionService.CreateParameter(cmd, dbNameParam, DbType.String, dbInfo.Catalog);
                return cmd;
            }
            return DatabaseServices.ExecutionService.CreateCommand(conn,
                string.Format("select T.name as TABLE_NAME, U.name as TABLE_SCHEM from {0}.sys.objects as T join " +
                              "{0}.sys.schemas as U on T.schema_id = U.schema_id where (T.type='U' or T.type='V') order by T.name",
                              DMLIdentifiers.EscapeIdentifierInner(dbInfo.Catalog)));
        }

        public override IEnumerable<ITableSourceForeignKeyInfo> GetTableSourceForeignKeys(ITableSourceInfo tableSource) {
            TableSourceInfo ts = tableSource as TableSourceInfo;
            return (ts == null) ? null : GetForeignKeys(ts);
        }

        public override IEnumerable<ITableSourceColumnInfo> GetTableSourceColumns(ITableSourceInfo tableSource) {
            TableSourceInfo ts = tableSource as TableSourceInfo;
            return (ts == null) ? null : GetColumns(ts);
        }

        private IEnumerable<IDatabaseInfo> GetLocalDatabases() {
            using (IDbConnection conn = DatabaseServices.TransactionService.CreateConnection()) {
                using (
                    IDbCommand cmd = DatabaseServices.ExecutionService.CreateCommand(conn,
                        "select * from sys.databases order by name")) {
                    cmd.CommandTimeout = QueryTimeout;
                    using (IDataReader reader = cmd.ExecuteReader()) {
                        while (reader.Read()) {
                            yield return new DatabaseInfo(DatabaseServices, reader.GetString(0), null);
                        }
                    }
                }
            }
        }

        private IEnumerable<string> GetLinkedServers() {
            using (IDbConnection conn = DatabaseServices.TransactionService.CreateConnection()) {
                string serverName;
                using (IDbCommand cmd = DatabaseServices.ExecutionService.CreateCommand(conn, "select @@servername")) {
                    cmd.CommandTimeout = QueryTimeout;
                    serverName = Convert.ToString(DatabaseServices.ExecutionService.ExecuteScalar(cmd));
                }
                using (IDbCommand cmd = DatabaseServices.ExecutionService.CreateCommand(conn, "select name from sys.servers")) {
                    cmd.CommandTimeout = QueryTimeout;
                    using (IDataReader reader = cmd.ExecuteReader()) {
                        while (reader.Read()) {
                            string linkedServer = reader.GetString(0);
                            if (!serverName.EqualsIgnoreCase(linkedServer)) {
                                yield return linkedServer;
                            }
                        }
                    }
                }
            }
        }

        private IEnumerable<IDatabaseInfo> GetLinkedDatabases(string server) {
            string paramName = DatabaseServices.ExecutionService.ParameterPrefix + "linkedServer";
            using (IDbConnection conn = DatabaseServices.TransactionService.CreateConnection()) {
                using (IDbCommand cmd = DatabaseServices.ExecutionService.CreateCommand(conn, "exec sp_catalogs " + paramName)) {
                    DatabaseServices.ExecutionService.CreateParameter(cmd, paramName, DbType.String, server);
                    cmd.CommandTimeout = QueryTimeout;
                    using (IDataReader reader = cmd.ExecuteReader()) {
                        while (reader.Read()) {
                            yield return new DatabaseInfo(DatabaseServices, reader.GetString(0), server);
                        }
                    }
                }
            }
        }

        private bool CheckDatabaseExists(DatabaseInfo databaseInfo) {
            return (databaseInfo.IsLinkedServer ? GetLinkedDatabases(databaseInfo.LinkedServer) : GetLocalDatabases())
                .Cast<DatabaseInfo>()
                .Any(dbInfo => dbInfo.Catalog.EqualsIgnoreCase(databaseInfo.Catalog));
        }

        private string GetQualifiedTableName(DatabaseInfo databaseInfo, string tableName, string tableSchema) {
            return string.Format("{0}{1}.{2}.{3}",
                databaseInfo.IsLinkedServer && !string.IsNullOrEmpty(databaseInfo.LinkedServer) ?
                    DMLIdentifiers.EscapeIdentifierInner(databaseInfo.LinkedServer) + "." :
                    "",
                DMLIdentifiers.EscapeIdentifierInner(databaseInfo.Catalog),
                DMLIdentifiers.EscapeIdentifierInner(tableSchema),
                DMLIdentifiers.EscapeIdentifierInner(tableName));
        }

        #region ColumnInfo
        private IEnumerable<ITableSourceColumnInfo> GetColumns(TableSourceInfo tableSource) {
            HashSet<string> primaryKeyColumns = GetPrimaryKeyColumns(tableSource);
            HashSet<string> autoGeneratedColumns = GetAutoGeneratedColumns(tableSource);

            using (IDbConnection conn = DatabaseServices.TransactionService.CreateConnection()) {
                using (IDbCommand cmd = DatabaseServices.ExecutionService.CreateCommand(conn,
                       tableSource.Database.IsLinkedServer ? "sp_columns_ex" : string.Format("{0}.dbo.sp_columns", DMLIdentifiers.EscapeIdentifierInner(tableSource.Database.Catalog)))) {
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandTimeout = QueryTimeout;
                    foreach (var param in tableSource.Database.IsLinkedServer ? spLinkedServerParams : spParams) {
                        DatabaseServices.ExecutionService.CreateParameter(cmd,
                            DatabaseServices.ExecutionService.ParameterPrefix + param.Key, DbType.String, param.Value(tableSource));
                    }
                    using (IDataReader reader = DatabaseServices.ExecutionService.ExecuteReader(cmd)) {
                        string colDecimals = tableSource.Database.IsLinkedServer ? "DECIMAL_DIGITS" : "SCALE";
                        string colBufferLength = tableSource.Database.IsLinkedServer ? "BUFFER_LENGTH" : "LENGTH";
                        string colSize = tableSource.Database.IsLinkedServer ? "COLUMN_SIZE" : "PRECISION";
                        while (reader.Read()) {
                            string columnName = Convert.ToString(reader["COLUMN_NAME"]);
                            int dataTypeCode = Convert.ToInt32(reader["DATA_TYPE"]);
                            string dataTypeName = Convert.ToString(reader["TYPE_NAME"]);
                            int sqlDataTypeCode = Convert.ToInt32(reader["SQL_DATA_TYPE"]);
                            int decimalDigits = reader[colDecimals] == DBNull.Value ? 255 : Convert.ToInt32(reader[colDecimals]);
                            int bufferLength = reader[colBufferLength] == DBNull.Value ? -1 : Convert.ToInt32(reader[colBufferLength]);
                            int size = Convert.ToInt32(reader[colSize]);

                            IDataTypeInfo type = CreateDataTypeInfo(tableSource.Database.IsLinkedServer, dataTypeName, dataTypeCode, 
                                sqlDataTypeCode, decimalDigits, bufferLength, size);

                            bool isMandatory = !Convert.ToString(reader["IS_NULLABLE"]).EqualsIgnoreCase("YES");
                            bool isPrimaryKey = primaryKeyColumns.Contains(columnName);
                            bool isAutoGenerated = autoGeneratedColumns.Contains(columnName);

                            yield return new TableSourceColumnInfo(tableSource, columnName, type, isMandatory, isPrimaryKey, isAutoGenerated);
                        }
                    }
                }
            }
        }

        private static readonly IDictionary<string, Func<TableSourceInfo, string>> spParams =
            new Dictionary<string, Func<TableSourceInfo, string>> {
                {"table_name", ts => ts.Name},
                {"table_owner", ts => ts.Schema},
            };

        private static readonly IDictionary<string, Func<TableSourceInfo, string>> spLinkedServerParams =
            new Dictionary<string, Func<TableSourceInfo, string>> {
                {"table_server", ts => ts.Database.LinkedServer},
                {"table_name", ts => ts.Name},
                {"table_schema", ts => ts.Schema},
                {"table_catalog", ts => ts.Database.Catalog},
            };


        protected HashSet<string> GetPrimaryKeyColumns(TableSourceInfo tableSource) {
            HashSet<string> columns = new HashSet<string>();
            using (IDbConnection conn = DatabaseServices.TransactionService.CreateConnection()) {
                using (IDbCommand cmd = DatabaseServices.ExecutionService.CreateCommand(conn,
                    tableSource.Database.IsLinkedServer ? "sp_primarykeys" : string.Format("{0}.dbo.sp_pkeys", DMLIdentifiers.EscapeIdentifierInner(tableSource.Database.Catalog)))) {
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.CommandTimeout = QueryTimeout;
                    foreach (var param in tableSource.Database.IsLinkedServer ? spLinkedServerParams : spParams) {
                        DatabaseServices.ExecutionService.CreateParameter(cmd,
                            DatabaseServices.ExecutionService.ParameterPrefix + param.Key, DbType.String, param.Value(tableSource));
                    }
                    using (IDataReader reader = DatabaseServices.ExecutionService.ExecuteReader(cmd)) {
                        while (reader.Read()) {
                            columns.Add(Convert.ToString(reader["COLUMN_NAME"]));
                        }
                        return columns;
                    }
                }
            }
        }

        private const string sqlFormatAutoGeneratedColumns = @"
SELECT 
    sc.name as COLUMN_NAME
FROM 
    {0}.sys.columns as sc INNER JOIN
    {0}.sys.objects so ON sc.object_id = so.object_id INNER JOIN
    {0}.sys.schemas as su ON so.schema_id = su.schema_id
WHERE 
    ((so.type = 'U') OR (so.type = 'V')) 
    AND (su.name = {1}) 
    AND (so.name = {2}) 
    AND (sc.is_identity = 1)";

        protected HashSet<string> GetAutoGeneratedColumns(TableSourceInfo tableSource) {
            HashSet<string> columns = new HashSet<string>();

            IDMLIdentifiers identifiers = DatabaseServices.DMLService.Identifiers;
            string paramPrefix = DatabaseServices.ExecutionService.ParameterPrefix;
            string tableOwnerParam = paramPrefix + "table_owner";
            string tableNameParam = paramPrefix + "table_name";

            string sql = string.Format(sqlFormatAutoGeneratedColumns,
                (tableSource.Database.IsLinkedServer ? DMLIdentifiers.EscapeIdentifierInner(tableSource.Database.LinkedServer) + "." : "")
                + DMLIdentifiers.EscapeIdentifierInner(tableSource.Database.Catalog), tableOwnerParam, tableNameParam);

            using (IDbConnection conn = DatabaseServices.TransactionService.CreateConnection()) {
                using (IDbCommand cmd = DatabaseServices.ExecutionService.CreateCommand(conn, sql)) {
                    DatabaseServices.ExecutionService.CreateParameter(cmd, tableOwnerParam, DbType.String, tableSource.Schema);
                    DatabaseServices.ExecutionService.CreateParameter(cmd, tableNameParam, DbType.String, tableSource.Name);
                    cmd.CommandTimeout = QueryTimeout;
                    using (IDataReader reader = cmd.ExecuteReader()) {
                        while (reader.Read()) {
                            columns.Add(Convert.ToString(reader["COLUMN_NAME"]));
                        }
                        return columns;
                    }
                }
            }
        }

        private class SqlDataType {

            public SqlDataType(string typeName, DBDataType dataType, int odbcTypeCode, int sqlTypeCode) {
                Name = typeName;
                DataType = dataType;
                OdbcTypeCode = odbcTypeCode;
                SqlTypeCode = sqlTypeCode;
            }

            public string Name { get; private set; }
            public DBDataType DataType { get; private set; }
            public int OdbcTypeCode { get; private set; }
            public int SqlTypeCode { get; private set; }
        }

        private static readonly SqlDataType[] supportedTypes = {
            new SqlDataType("Char",             DBDataType.TEXT,        1,      1),
            new SqlDataType("Numeric",          DBDataType.DECIMAL,     2,      2),
            new SqlDataType("Decimal",          DBDataType.DECIMAL,     3,      3),
            new SqlDataType("Money",            DBDataType.DECIMAL,     3,      3),
            new SqlDataType("SmallMoney",       DBDataType.DECIMAL,     3,      3),
            new SqlDataType("Int",              DBDataType.INTEGER,     4,      4),
            new SqlDataType("SmallInt",         DBDataType.INTEGER,     5,      5),
            new SqlDataType("Float",            DBDataType.TEXT,        6,      6),
            new SqlDataType("Real",             DBDataType.TEXT,        7,      7),
            new SqlDataType("SmallDateTime",    DBDataType.DATE_TIME,   11,     9),
            new SqlDataType("DateTime",         DBDataType.DATE_TIME,   11,     9),
            new SqlDataType("VarChar",          DBDataType.TEXT,        12,     12),
            new SqlDataType("Text",             DBDataType.TEXT,        -1,     -1),
            new SqlDataType("Binary",           DBDataType.BINARY_DATA, -2,     -2),
            new SqlDataType("Timestamp",        DBDataType.UNKNOWN,     -2,     -2),
            new SqlDataType("VarBinary",        DBDataType.BINARY_DATA, -3,     -3),
            new SqlDataType("Image",            DBDataType.BINARY_DATA, -4,     -4),
            new SqlDataType("Geography",        DBDataType.UNKNOWN,     -4,     -4),
            new SqlDataType("Geometry",         DBDataType.UNKNOWN,     -4,     -4),
            new SqlDataType("Hierarchyid",      DBDataType.UNKNOWN,     -4,     -4),
            new SqlDataType("BigInt",           DBDataType.LONGINTEGER, -5,     -5), 
            new SqlDataType("TinyInt",          DBDataType.INTEGER,     -6,     -6),
            new SqlDataType("Bit",              DBDataType.BOOLEAN,     -7,     -7),
            new SqlDataType("NChar",            DBDataType.TEXT,        -8,     -8),
            new SqlDataType("NVarChar",         DBDataType.TEXT,        -9,     -9),
            new SqlDataType("Time",             DBDataType.TEXT,        -9,     -9),
            new SqlDataType("DateTimeOffset",   DBDataType.TEXT,        -9,     -9), 
            new SqlDataType("Date",             DBDataType.DATE,        -9,     -9),
            new SqlDataType("DateTime2",        DBDataType.DATE_TIME,   -9,     -9),
            new SqlDataType("NText",            DBDataType.TEXT,        -10,    -10), // #906491 - 'NTEXT' is not supported in Surrogate Character collations.
            new SqlDataType("Xml",              DBDataType.TEXT,        -10,    -10),
            new SqlDataType("UniqueIdentifier", DBDataType.TEXT,        -11,    -11),
            new SqlDataType("Sql_Variant",      DBDataType.UNKNOWN,     -150,   -150)
        };


        private IDataTypeInfo CreateDataTypeInfo(bool isLinkedServer, string typeName, int odbcTypeCode, int sqlTypeCode, int decimalDigits,
                                                 int bufferLength, int precision) {

            int length = 0, decimals = 0;
            DBDataType? typeOverride = null;
            SqlDataType type = null;
            string extraInfo = "";

            //at least when using numeric/decimal types in combination with 'identity' (values
            //auto-generation) the reported type includes parentheses, for example, 'Decimal()'
            string pureTypeName = typeName.Split(' ')[0].Replace("()", null);

            foreach (var sqlDataType in supportedTypes) {
                if ((pureTypeName.EqualsIgnoreCase(sqlDataType.Name) || isLinkedServer) && // for linked servers we should only consider the type codes as the names are unreliable
                    sqlDataType.OdbcTypeCode == odbcTypeCode && 
                    sqlDataType.SqlTypeCode == sqlTypeCode) {
                    type = sqlDataType;
                    break;
                }
            }

            if (type == null) {
                return new DataTypeInfo(DBDataType.UNKNOWN, typeName, length, decimals);
            }

            if ((type.Name == "Numeric" || type.Name == "Decimal") && (decimalDigits > 8 || precision > 28)) { // special cases "decimal" && "numeric"
                typeOverride = DBDataType.TEXT;
            } else if ((type.Name == "Numeric" || type.Name == "Decimal") && precision >= 1 && precision <= 9 && decimalDigits == 0) {
                typeOverride = DBDataType.INTEGER;
            } else if ((type.Name == "Numeric" || type.Name == "Decimal") && precision >= 10 && precision <= 18 && decimalDigits == 0) {
                typeOverride = DBDataType.LONGINTEGER;
            }

            if (type.DataType == DBDataType.TEXT) {
                switch (type.Name) {
                    case "Float": length = 311; break; // float has max 308 exponent, need extra space for sign and .
                    case "Real": length = 41; break; // real has max 41 exponent
                    case "Time":
                    case "DateTimeOffset": length = precision + 1; break; // extra character for possible string ending
                    default: length = precision; break;
                }
            }

            if (type.DataType == DBDataType.DECIMAL) {
                if (typeOverride == DBDataType.TEXT) {
                    length = precision + 3; // +3 ( extra space for sign, 0 and . )
                }
                else {
                    length = precision;
                }
                
            }

            if (type.DataType == DBDataType.DATE_TIME) {
                length = precision; //In case it is used as primary key, we need the length information
            }

            if (isLinkedServer) {
                // linked server
                // special case "Money" and "SmallMoney"
                if (odbcTypeCode == 3 && sqlTypeCode == 3) {
                    decimals = 4;
                } else {
                    if (decimalDigits != 255) {
                        decimals = decimalDigits;
                    }
                }

                // special cases "sql_variant"
                if (type.OdbcTypeCode == -9 && type.SqlTypeCode == -9 && bufferLength < 0) { 
                    typeOverride = DBDataType.UNKNOWN;
                }
            } else {
                // local server
                if (decimalDigits != 255) {
                    decimals = decimalDigits;
                }

                extraInfo = ExtraTypeNameInfo(type.Name, precision, decimalDigits);
            }
            return new DataTypeInfo(typeOverride ?? type.DataType, type.Name + extraInfo, length, decimals);
        }

        private string ExtraTypeNameInfo (string dataType, int precision, int decimals) {
            switch (dataType) {
                case "Decimal":
                case "Numeric": return "(" + precision + "," + decimals + ")";
                case "Binary":
                case "Char":
                case "NChar":
                case "NVarChar":
                case "VarBinary":
                case "VarChar": return "(" + precision + ")";
                case "DateTime2": return "(" + (precision == 19 ? 0 : precision - 20) + ")"; //datetime2(n) has minimum 19 precision and if n>0 there's extra precision for the '.'
                case "DateTimeOffset": return "(" + (precision == 26 ? 0 : precision - 27) + ")"; //same as before but minimum 26 precision
                case "Time": return "(" + (precision == 8 ? 0 : precision - 9) + ")"; //same as before but minimum 8 precision
                default: return "";
            }
        }

        #endregion

        #region ForeignKeysInfo

        private const string sqlFormatForeignKeys = @"
SELECT DISTINCT KEYS.*, {0}.sys.schemas.name as PKTABLE_SCHEM 
FROM (
    SELECT ForeignTable.name AS PKTABLE_NAME, ForeignTable.schema_id as foreignTableOwnerUID, ForeignKeyField.name AS PKCOLUMN_NAME, PrimaryTable.name AS primaryTableName, PrimaryKeyField.name AS FKCOLUMN_NAME, Constr.name as FK_NAME, vRefConst.DELETE_RULE as DELETE_RULE 
    FROM {0}.sys.foreign_key_columns SingleFKReferences
    INNER JOIN {0}.sys.objects Constr ON SingleFKReferences.constraint_object_id = Constr.object_id
    INNER JOIN {0}.sys.objects PrimaryTable ON SingleFKReferences.parent_object_id = PrimaryTable.object_id
    INNER JOIN {0}.sys.objects ForeignTable ON SingleFKReferences.referenced_object_id = ForeignTable.object_id
    INNER JOIN {0}.sys.columns ForeignKeyField ON SingleFKReferences.referenced_object_id = ForeignKeyField.object_id AND SingleFKReferences.referenced_column_id = ForeignKeyField.column_id
    INNER JOIN {0}.sys.columns PrimaryKeyField ON SingleFKReferences.parent_object_id = PrimaryKeyField.object_id AND SingleFKReferences.parent_column_id = PrimaryKeyField.column_id
    INNER JOIN {0}.INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS vRefConst ON vRefConst.CONSTRAINT_NAME = Constr.name
    WHERE PrimaryTable.name = {1}
) as KEYS
INNER JOIN {0}.sys.schemas ON KEYS.foreignTableOwnerUID = {0}.sys.schemas.schema_id";

        protected IEnumerable<ITableSourceForeignKeyInfo> GetForeignKeys(TableSourceInfo tableSource) {
            using (IDbConnection conn = DatabaseServices.TransactionService.CreateConnection()) {
                IDbCommand cmd = null;
                try {
                    string paramPrefix = DatabaseServices.ExecutionService.ParameterPrefix;
                    if (!tableSource.Database.IsLinkedServer) {
                        string tableNameParam = paramPrefix + "tableName";
                        string sql = string.Format(sqlFormatForeignKeys,
                           DMLIdentifiers.EscapeIdentifierInner(tableSource.Database.Catalog), tableNameParam);
                        cmd = DatabaseServices.ExecutionService.CreateCommand(conn, sql);
                        DatabaseServices.ExecutionService.CreateParameter(cmd, tableNameParam, DbType.String, tableSource.Name);
                    } else {
                        cmd = DatabaseServices.ExecutionService.CreateCommand(conn, "sp_foreignkeys");
                        cmd.CommandType = CommandType.StoredProcedure;
                        DatabaseServices.ExecutionService.CreateParameter(cmd, paramPrefix + "table_server", DbType.String, tableSource.Database.LinkedServer);
                        DatabaseServices.ExecutionService.CreateParameter(cmd, paramPrefix + "fktab_name", DbType.String, tableSource.Name);
                        DatabaseServices.ExecutionService.CreateParameter(cmd, paramPrefix + "fktab_schema", DbType.String, tableSource.Schema);
                        DatabaseServices.ExecutionService.CreateParameter(cmd, paramPrefix + "fktab_catalog", DbType.String, tableSource.Database.Catalog);
                    }
                    cmd.CommandTimeout = QueryTimeout;
                    using (IDataReader reader = DatabaseServices.ExecutionService.ExecuteReader(cmd)) {
                        while (reader.Read()) {
                            string referencedTableName = Convert.ToString(reader["PKTABLE_NAME"]);
                            string referencedTableSchema = Convert.ToString(reader["PKTABLE_SCHEM"]);
                            string referencedColumnName = Convert.ToString(reader["PKCOLUMN_NAME"]);
                            string columnName = Convert.ToString(reader["FKCOLUMN_NAME"]);
                            string constraintName = Convert.ToString(reader["FK_NAME"]);
                            object deleteRule = reader["DELETE_RULE"];
                            bool isCascadeDelete;

                            if (tableSource.Database.IsLinkedServer) {
                                isCascadeDelete = Convert.ToInt32(deleteRule) == 0; // CASCADE
                            } else {
                                isCascadeDelete = Convert.ToString(deleteRule).EqualsIgnoreCase("CASCADE");
                            }

                            string qualifiedName = GetQualifiedTableName(tableSource.Database, referencedTableName, referencedTableSchema);
                            ITableSourceInfo referencedTableSource = new TableSourceInfo(DatabaseServices, tableSource.Database, referencedTableName, referencedTableSchema, qualifiedName);
                            yield return new TableSourceForeignKeyInfo(tableSource, constraintName, columnName, referencedTableSource, referencedColumnName, isCascadeDelete);
                        }
                    }
                } finally {
                    if (cmd != null) {
                        cmd.Dispose();
                    }
                }
            }
        }

        #endregion

    }
}
