/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections;
using System.Data;
using System.Data.Common;
using System.Data.SqlClient;
using System.Xml;
using OutSystems.HubEdition.DatabaseProvider.SqlServer.ConfigurationService;
using OutSystems.HubEdition.DatabaseProvider.SqlServer.TransactionService;
using OutSystems.HubEdition.Extensibility.Data;
using OutSystems.HubEdition.Extensibility.Data.ExecutionService;
using OutSystems.HubEdition.Extensibility.Data.TransactionService;
using OutSystems.RuntimeCommon;
using OutSystems.RuntimeCommon.Log;
using OutSystems.RuntimeCommon.ObfuscationProperties;

namespace OutSystems.HubEdition.DatabaseProvider.SqlServer.ExecutionService {

    public enum SqlServerVersion {
        Sql2000,
        Sql2005,
        Sql2008,
        Sql2012,
        Sql2014,
        Sql2016,
        Unknown,
    }

    public enum SqlEngineEdition {
        Personal,
        Standard,
        Enterprise,
        Express,
        Azure,
        Unknown,
    }

    [DoNotObfuscate]
    public class ExecutionService : BaseExecutionService {
        private const int ConnectionResetByPeerError = 10054;

        private SqlServerVersion? sqlServerVersion;
        private SqlEngineEdition? sqlServerEngineEdition;
        private bool? isIntegratedSecurityOnly;

        public override string ParameterPrefix { get { return "@"; } }

        public bool IsIntegratedSecurityOnly {
            get {
                if (!isIntegratedSecurityOnly.HasValue) {
                    isIntegratedSecurityOnly = GetIsIntegratedSecurityOnlyProperty();
                }
                return isIntegratedSecurityOnly.Value;
            }
        }

        public SqlServerVersion ServerVersion {
            get {
                if (!sqlServerVersion.HasValue) {
                    sqlServerVersion = GetServerVersionProperty();
                }
                return sqlServerVersion.Value;
            }
        }

        public SqlEngineEdition ServerEngineEdition {
            get {
                if (!sqlServerEngineEdition.HasValue) {
                    sqlServerEngineEdition = GetServerEngineEditionProperty();
                }
                return sqlServerEngineEdition.Value;
            }
        }

        private SqlServerVersion GetServerVersionProperty() {
            // available both on sql 2000 and 2005
            // eg: "8.00.760" (sql 2000); "9.00.1399.06" (sql 2005), "10.0.1600.22" (sql 2008)
            string prop = GetServerProperty("productversion");
            string majorVersion = prop.Split('.')[0];
            switch (majorVersion) {
                case "8":
                    return SqlServerVersion.Sql2000;
                case "9":
                    return SqlServerVersion.Sql2005;
                case "10":
                    return SqlServerVersion.Sql2008;
                case "11":
                    return SqlServerVersion.Sql2012;
                case "12":
                    return SqlServerVersion.Sql2014;
                case "13":
                    return SqlServerVersion.Sql2016;
                default:
                    return SqlServerVersion.Unknown;
            }
        }

        private SqlEngineEdition GetServerEngineEditionProperty() {
            string prop = GetServerProperty("EngineEdition");
            
            switch (prop) {
                case "1":
                    return SqlEngineEdition.Personal;
                case "2":
                    return SqlEngineEdition.Standard;
                case "3":
                    return SqlEngineEdition.Enterprise;
                case "4":
                    return SqlEngineEdition.Express;
                case "5":
                    return SqlEngineEdition.Azure;
                default:
                    return SqlEngineEdition.Unknown;
            }
        }

        private bool GetIsIntegratedSecurityOnlyProperty() {
            return bool.Parse(GetServerProperty("IsIntegratedSecurityOnly"));
        }

        private string GetServerProperty(string propertyname) {
            using (IDbConnection conn = DatabaseServices.TransactionService.CreateConnection()) {
                string sql = @"SELECT SERVERPROPERTY('" + propertyname + "')";
                using (IDbCommand cmd = CreateCommand(conn, sql)) {
                    return Convert.ToString(ExecuteScalar(cmd));
                }
            }
        }

        public override void OnExecuteException(DbException e, IDbCommand cmd, IDataReader reader, IDbConnection conn, IDbTransaction trans, ITransactionManager manager) {
            base.OnExecuteException(e, cmd, reader, conn, trans, manager);

            // Close reader if open
            if (reader != null && !reader.IsClosed) {
                reader.Close();
            }

            // If the command was executed in the context of a managed transaction, abort the transaction so that it doesn't get reused
            if (manager != null && trans != null && !((TransactionService.TransactionService)manager.TransactionService).TransactionExists(trans)) {
                // Some SQL statements (like convert) abort the transaction if they cause a error, so we need to check 
                // if the transaction is still open and if it is, remove it from the transaction manager
                // see http://stackoverflow.com/questions/5877162/why-does-microsoft-sql-server-implicitly-rollback-when-a-create-statement-fails
                ((TransactionManager)manager).AbortTransaction(trans);
            }
        }

        protected override void SetCorrectDBType(DbType dbType, IDbDataParameter param) {
            // In SQL SERver - fix unicode param
            if (this.IsUnicodeStringType(dbType) && !((RuntimeDatabaseConfiguration)DatabaseConfiguration).DatabaseUnicodeSupport) {
                param.DbType = DbType.AnsiString;
                return;
            }

            base.SetCorrectDBType(dbType, param);
        }

        public override void SetParameterValue(IDbDataParameter param, DbType dbType, object paramValue) {
            base.SetParameterValue(param, dbType, paramValue);

            // #130625 SQL Server execution plan cache doesn't like one plan per diff param size...
            if (IsStringOrAnsiStringDbType(dbType)) {
                var paramValueString = paramValue as string;

                // Make size "snap" to the next power of 10
                if (paramValueString != null) {
                    if (paramValueString.Length <= 10)
                        param.Size = 10;
                    else if (paramValueString.Length <= 50)
                        param.Size = 50;
                    else if (paramValueString.Length <= 4000)
                        param.Size = 4000;
                    else if (paramValueString.Length <= 8000)
                        param.Size = 8000;
                }
            } else if (dbType == DbType.Binary) {
                byte[] paramValueBin = paramValue as byte[];

                if (paramValueBin != null) {
                    if (paramValueBin.Length <= 1024)
                        param.Size = 1024;
                    else if (paramValueBin.Length <= 4000)
                        param.Size = 4000;
                    else if (paramValueBin.Length <= 8000)
                        param.Size = 8000;
                }
            }
        }

        public ExecutionService(IDatabaseServices databaseServices) : base(databaseServices) { }

        public override bool IsConnectionException(DbException e) {
            var sqlE = e as SqlException;
            return (sqlE != null) && (sqlE.Class == 20 && sqlE.Number == ConnectionResetByPeerError);
        }

        /// <summary>
        /// Creates and executes an Xml Reader with the query defined in cmd.
        /// If the query takes too long so fill, a slow sql warning is logged. 
        /// </summary>
        /// <param name="cmd">The IDbCommand that will be used to do the query</param>
        /// <param name="description">The description to use when a slow sql is logged</param>
        /// <param name="isApplication">Defines if this was called from a generated application</param>
        /// <returns>An object with the resulting first row and first column of the query defined in "cmd"</returns>
        /// <remarks>If isApplication is set to false, "OS: " is prepended to the description when
        /// a slow sql is logged</remarks>        
        [DoNotObfuscate]
        public XmlReader ExecuteXmlReader(SqlCommand cmd, string description, bool isApplication) {
            // Save the values before execution because sometimes the drivers clears them from the IDbCommand when an exception occurs
            IDbConnection conn = cmd.Connection;
            IDbTransaction trans = cmd.Transaction;
            try {
                return cmd.ExecuteXmlReader();
            } catch (DbException e) {
                OnExecuteException(e, cmd, null, conn, trans, null);
                throw;
            }
        }

        [DoNotObfuscate]
        public XmlReader ExecuteXmlReader(SqlCommand cmd) {
            return ExecuteXmlReader(cmd, null, false);
        }

        public override IDataReader ExecuteReader(IDbCommand cmd) {
            try {
                return new SQLServerDataReaderWrapper((SqlDataReader)cmd.ExecuteReader(), this);
            } catch (DbException e) {
                OSTrace.Error("Error executing ExecuteReader (" + e.Message + ") with statement:" + Environment.NewLine + cmd.CommandText);
                throw;
            }
        }

        // Cast command to SQL to be able to use our SQLServerDataReaderWrapper
        public override object ExecuteScalar(IDbCommand cmd) {
            SqlCommand sqlCommand = (SqlCommand)cmd;
            using (var reader = ExecuteReader(sqlCommand)) {
                if (reader.Read()) {
                    return reader.GetValue(0);
                }
            }
            return null;
        }

        public override DbType ConvertToDbType(Type type) {
            if (type == typeof(string)) {
                if (((RuntimeDatabaseConfiguration)DatabaseConfiguration).DatabaseUnicodeSupport) {
                    return DbType.String;
                } else {
                    return DbType.AnsiString;
                }
            } else {
                return base.ConvertToDbType(type);
            }
        }

        public override DbType ConvertToDbType(DBDataType type, string providerType) {
            if (DBDataType.TEXT == type) {
                
                providerType = (!providerType.IsNullOrEmpty()) ? providerType.Split('(')[0] : "";
                switch (providerType) {
                    case "Decimal":
                    case "Numeric":
                        return DbType.Decimal;
                    case "Real":
                        return DbType.Single;
                    case "Float":
                        return DbType.Double;
                    default:
                        return ((RuntimeDatabaseConfiguration)DatabaseConfiguration).DatabaseUnicodeSupport
                            ? DbType.String : DbType.AnsiString;
                }                
            } 
            if (DBDataType.INTEGER == type)
                return DbType.Int32;
            if (DBDataType.LONGINTEGER == type)
                return DbType.Int64;
            if (DBDataType.DECIMAL == type)
                return DbType.Decimal;
            if (DBDataType.DATE_TIME == type)
                return DbType.DateTime;
            if (DBDataType.BOOLEAN == type)
                return DbType.Boolean;
            if (DBDataType.BINARY_DATA == type)
                return DbType.Binary;

            throw new NotSupportedException("Unable to convert " + type.ToString() + " to DbType");
        }

        private bool ConnectionBrokenOrClosed(IDbConnection dbconn) {
            if (DatabaseServices.TransactionService.IsClosed(dbconn)) {
                return true;
            }

            // do a dummy query to test the connection (the connection could be in 'Open' state but broken 
            IDbCommand command = null;
            try {
                command = dbconn.CreateCommand();
                command.CommandText = "Select 1";
                command.ExecuteScalar();
            } catch {
                return true;
            } finally {
                if (command != null) {
                    command.Dispose();
                }
            }
            return false;
        }

        public override void BulkInsert(DataTable tab) {
            bool errorOnBulk = false;
            using (var connection = DatabaseServices.TransactionService.CreateConnection()) {
                try {
                    BulkCopy(connection, tab);
                    if (ConnectionBrokenOrClosed(connection)) {
                        errorOnBulk = true;
                    }
                } catch (Exception e) {
                    EventLogger.WriteError(e.ToString());
                    errorOnBulk = true;
                }

            }

            if (errorOnBulk) {
                base.BulkInsert(tab);
            }
        }

        public void BulkCopy(IDbConnection connection, DataTable tab) {
            using (SqlBulkCopy bc = new SqlBulkCopy(
                (SqlConnection)connection,
                SqlBulkCopyOptions.FireTriggers |
                SqlBulkCopyOptions.UseInternalTransaction |
                SqlBulkCopyOptions.CheckConstraints, null)) {

                bc.BatchSize = tab.Rows.Count;
                bc.DestinationTableName = tab.TableName;

                foreach (DataColumn col in tab.Columns) {
                    bc.ColumnMappings.Add(col.ColumnName,
                        GetCorrectColumnNameCase(connection, tab.TableName, col.ColumnName));
                }

                bc.WriteToServer(tab);
            }
        }

        private static Hashtable columnNames = new Hashtable();

        private static string GetCorrectColumnNameCase(IDbConnection con, string tableName, string attributeName) {
				tableName = tableName.ToUpper();
				attributeName = attributeName.ToUpper();
				string key = con.Database + "." + tableName + "." + attributeName;
				if (!columnNames.ContainsKey(key)) {
					DataTable tab = new DataTable(tableName);
					IDbCommand select = con.CreateCommand();
					select.CommandType = CommandType.Text;
					select.CommandText = "SELECT TOP(1) * FROM " + tableName;
					SqlDataAdapter adap = new SqlDataAdapter();
					adap.SelectCommand = (SqlCommand)select;
					adap.Fill(0, 0, tab);
					foreach (DataColumn col in tab.Columns) {
						if (col.ColumnName.ToUpper() == attributeName) {
							columnNames[key] = col.ColumnName;
							return col.ColumnName;
						}
					}
					throw new InvalidColumnName("Invalid column: " + key);
				} else {
					return (string)columnNames[key];
				}
        }

        private class InvalidColumnName : Exception {
            public InvalidColumnName(string message)
                : base(message) {
            }
        }
    }
}
