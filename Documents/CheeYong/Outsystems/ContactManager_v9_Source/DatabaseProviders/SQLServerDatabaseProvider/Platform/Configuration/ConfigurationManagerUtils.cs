/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using OutSystems.HubEdition.DatabaseProvider.SqlServer.ConfigurationService;
using OutSystems.HubEdition.DatabaseProvider.SqlServer.ExecutionService;
using OutSystems.HubEdition.Extensibility.Data.ConfigurationService;
using OutSystems.HubEdition.Extensibility.Data.ExecutionService;
using OutSystems.HubEdition.Extensibility.Data.Platform.Configuration;
using OutSystems.HubEdition.Extensibility.Data.TransactionService;
using OutSystems.RuntimeCommon;
using PlatformUser = OutSystems.HubEdition.Extensibility.Data.Platform.Configuration.UserType;
using System.Text.RegularExpressions;

namespace OutSystems.HubEdition.DatabaseProvider.SqlServer.Platform.Configuration {

    public static class ConfigurationManagerUtils {

        internal static int QueryTimeout = 30;
        private const string dbOwnerRole = "db_owner";

        public static void CreateSqlServerCatalogIfDoesntExist(IRuntimeDatabaseConfiguration config, string catalog) {
            if (DatabaseExists(config, catalog)) {
                return;
            }
            ClearDatabaseFile(config, catalog);
            CreateDatabase(config, catalog);
        }

        public static bool DatabaseExists(IRuntimeDatabaseConfiguration config, string dbName) {
            try {
                string sql = "select count(name) from master.sys.databases where name='" + dbName + "'";
                return Convert.ToInt32(ExecuteScalar(config, sql)) > 0;
            } catch (Exception e) {
                throw new ConfigurationOperationException("Couldn't check if database exists: " + e.Message, e);
            }
        }

        private static SqlEngineEdition GetSqlEngineEdition(IRuntimeDatabaseConfiguration config) {
            try {
                var service = config.DatabaseProvider.GetIntegrationDatabaseServices(config).ExecutionService as SqlServer.ExecutionService.ExecutionService;

                return service.ServerEngineEdition;
            } catch {
                return SqlEngineEdition.Unknown;
            }
        }

        public static SqlEngineEdition GetSqlEngineEdition(ISettableTwoUserDatabaseConfiguration config) {
            return GetSqlEngineEdition(config.RuntimeDatabaseConfiguration(UserType.Admin));
        }
        
        public static SqlEngineEdition GetSqlEngineEdition(IPlatformDatabaseConfiguration config) {
            return GetSqlEngineEdition(config.RuntimeDatabaseConfiguration(Source.Application, PlatformUser.Admin));
        }

        public static SqlEngineEdition GetSqlEngineEdition(ISessionDatabaseConfiguration config) {
            return GetSqlEngineEdition(config.RuntimeDatabaseConfiguration());
        }

        public static bool IsDatabaseAzure(IRuntimeDatabaseConfiguration config) {
            try {
                return (GetSqlEngineEdition(config) == SqlServer.ExecutionService.SqlEngineEdition.Azure);
            } catch {
                // Feature is not released yet. Don't break if check fails.
                return false;
            }
        }

        public static void CheckIfAzureDatabaseExists(IRuntimeDatabaseConfiguration config, string catalog) {
            if (!IsDatabaseAzure(config) || DatabaseExists(config, catalog)) {
                return;
            } else {
                throw new ConfigurationOperationException(string.Format("Database '{0}' does not exist and automatic database creation is not supported for Azure SQL.\n\nPlease manually create the required database on Azure SQL and click the 'Grant Permissions' button to proceed.", catalog));
            }
        }

        public static void SetRecoveryModel(IRuntimeDatabaseConfiguration config, string database, string model) {
            string sql = "IF NOT EXISTS " +
                         "(SELECT * FROM sys.databases where name = '" + database + "' and recovery_model_desc ='SIMPLE' ) " +
                         "ALTER DATABASE \"" + database + "\" SET RECOVERY " + model;
            ExecuteNonQuery(config, sql);
        }

        private static bool CheckElevatedPermissionsForAzure(IRuntimeDatabaseConfiguration configMaster, IRuntimeDatabaseConfiguration configRuntime) {
            StringBuilder query = new StringBuilder();

            // Roles and permissions are somewhat different from SQL Server to Azure.
            //
            // An elevated user requires the loginmanager role (to create new users)
            // and whatever combination of roles that allow a user to create tables 
            // and manipulate data on a given database (such as db_owner or 
            // db_ddladmin + db_datawriter + db_datareader).
            //
            // However, the admin user for a server created via Azure Portal has a 
            // somewhat different behaviour, in terms of roles, than that of users 
            // created by said admin account. This means we need to make different
            // types of checks for different types of users.

            // This is the base SQL to query roles and permissions
            string sqlBase =
                @"SELECT 
                    COUNT(*) 
                FROM sys.database_principals p 
                JOIN sys.database_permissions prm 
                    ON p.principal_id = prm.grantee_principal_id 
                LEFT JOIN sys.database_principals p2 
                    ON prm.major_id = p2.principal_id 
                LEFT JOIN sys.database_role_members r 
                    ON p.principal_id = r.member_principal_id 
                LEFT JOIN sys.database_principals p3 
                    ON r.role_principal_id = p3.principal_id 
                WHERE p.name = USER ";

            int sqlBaseLength = sqlBase.Length;

            query.Append(sqlBase);

            // The Portal created admin user always has the loginmanager, dbmanager 
            // roles in the master catalog and dbo for all databases automatically.
            // A user with sufficient privileges will need to have the loginmanager
            // role on the master catalog and the other roles on each database.
            // HOWEVER, this info is available in p2 for the first and p3 for the 
            // latter.
            string sqlCheckRolesForPortalAdmin =
                @" AND (p2.name = 'loginmanager' OR p2.name = 'dbmanager')";

            query.Append(sqlCheckRolesForPortalAdmin);

            if (Convert.ToInt32(ExecuteScalar(configMaster, query.ToString())) == 2) {
                // A Portal created admin, we're ok.
                return true;
            }

            string sqlCheckLoginmanagerRoleForAdminCreatedUser =
                @" AND p3.name = 'loginmanager'";
            
            query.Length = sqlBaseLength;
            query.Append(sqlCheckLoginmanagerRoleForAdminCreatedUser);

            if (Convert.ToInt32(ExecuteScalar(configMaster, query.ToString())) == 1) {
                // Correct loginmanager role for the user.

                string sqlCheckRolesForRuntimeCatalog =
                    @" AND (p3.name = 'db_ddladmin' OR
                            p3.name = 'db_datareader' OR
                            p3.name = 'db_datawriter')";

                query.Length = sqlBaseLength;
                query.Append(sqlCheckRolesForRuntimeCatalog);

                if (Convert.ToInt32(ExecuteScalar(configRuntime, query.ToString())) == 3) {
                    // Has sufficient roles for the runtime catalog.
                    return true;
                }

                string sqlCheckDBOwnerForRuntimeCatalog =
                    @" AND p3.name = '" + dbOwnerRole + "'";

                query.Length = sqlBaseLength;
                query.Append(sqlCheckDBOwnerForRuntimeCatalog);

                if (Convert.ToInt32(ExecuteScalar(configRuntime, query.ToString())) == 1) {
                    // Is db_owner for the catalog.
                    return true;
                }
            }

            return false;
        }

        private static bool CheckElevatedPermissionsForSQLServer(IRuntimeDatabaseConfiguration config) {
            string sql = @"SELECT count(*) FROM fn_my_permissions(NULL, 'SERVER') 
                WHERE permission_name like 'CREATE ANY DATABASE' 
                or permission_name like 'CONTROL SERVER' 
                or permission_name like 'CREATE SERVER ROLE'";

            return Convert.ToInt32(ExecuteScalar(config, sql)) >= 2;
        }

        public static void CheckIfUserHasNecessaryElevatedPermissions(IRuntimeDatabaseConfiguration configMaster, IRuntimeDatabaseConfiguration configRuntime) {
            try {
                bool hasAdminPermissions = false;

                if (IsDatabaseAzure(configMaster)) {
                    hasAdminPermissions = CheckElevatedPermissionsForAzure(configMaster, configRuntime);
                } else {
                    hasAdminPermissions = CheckElevatedPermissionsForSQLServer(configMaster);
                }

                if (!hasAdminPermissions) {
                    throw new ConfigurationOperationException(string.Format("User {0} doesn't have admin permissions", configMaster.Username));
                }
            } catch (Exception e) {
                throw new ConfigurationOperationException("Checking for admin permissions: " + e.Message, e);
            }
        }

        public static void ClearDatabaseFile(IRuntimeDatabaseConfiguration config, string dbName) {
            try {
                string masterPath;
                const string sql = "SELECT physical_name FROM master.sys.database_files WHERE name='master'";
                masterPath = Convert.ToString(ExecuteScalar(config, sql));

                string mdf = masterPath.Replace("master.mdf", dbName + ".mdf");
                string ldf = masterPath.Replace("master.mdf", dbName + "_log.ldf");
                string backup;
                if (File.Exists(mdf)) {
                    do {
                        backup = mdf + ".bak";
                    } while (File.Exists(backup));
                    File.Move(mdf, backup);
                }
                if (File.Exists(ldf)) {
                    do {
                        backup = ldf + ".bak";
                    } while (File.Exists(backup));
                    File.Move(ldf, backup);
                }
                // ReSharper disable once EmptyGeneralCatchClause
            } catch { }
        }

        public static void CreateDatabase(IRuntimeDatabaseConfiguration config, string dbName) {
            try {
                // #906491 - Change default collation to support Surrogate Pairs
                string sql = "CREATE DATABASE \"" + dbName + "\" COLLATE Latin1_General_100_CI_AI_SC";
                var service = GetExecutionService(config) as SqlServer.ExecutionService.ExecutionService;

                // SQL Server 2008 doesn't support surrogate characters and the collation Latin1_General_100_CI_AI_SC
                // fallback to the old collation (other supported versions are 2012 and 2014 which support the new collation)
                if (service.ServerVersion == SqlServerVersion.Sql2008) {
                    sql = "CREATE DATABASE \"" + dbName + "\" COLLATE Latin1_General_CI_AI";
                }

                ExecuteNonQuery(config, sql);
            } catch (Exception e) {
                throw new ConfigurationOperationException(string.Format("Error creating database {0}: {1}", dbName, e.Message), e);
            }
        }

        public static IExecutionService GetExecutionService(IRuntimeDatabaseConfiguration config) {
            return config.DatabaseProvider.GetIntegrationDatabaseServices(config).ExecutionService;
        }

        public static ITransactionService GetTransactionService(IRuntimeDatabaseConfiguration config) {
            return config.DatabaseProvider.GetIntegrationDatabaseServices(config).TransactionService;
        }

        public static int ExecuteNonQuery(IRuntimeDatabaseConfiguration config, string sql) {
            using (var connection = GetTransactionService(config).CreateConnection()) {
                using (var command = GetExecutionService(config).CreateCommand(connection, sql)) {
                    command.CommandTimeout = QueryTimeout;
                    return command.ExecuteNonQuery();
                }
            }
        }

        public static object ExecuteScalar(IRuntimeDatabaseConfiguration config, string sql) {
            using (var connection = GetTransactionService(config).CreateConnection()) {
                using (var command = GetExecutionService(config).CreateCommand(connection, sql)) {
                    command.CommandTimeout = QueryTimeout;
                    return command.ExecuteScalar();
                }
            }
        }

        public static List<string> GetUserRoles(IRuntimeDatabaseConfiguration config, string username) {
            string sql = "EXEC sp_helpuser '" + username + "'";

            bool isAzureDB = IsDatabaseAzure(config);

            if (isAzureDB) {
                sql =
                @"SELECT 
                    prm.permission_name, 
                    prm.class_desc, 
                    prm.state_desc, 
                    p2.name as 'Database role', 
                    p3.name as 'RoleName' 
                FROM sys.database_principals p 
                JOIN sys.database_permissions prm 
                    ON p.principal_id = prm.grantee_principal_id 
                LEFT JOIN sys.database_principals p2 
                    ON prm.major_id = p2.principal_id 
                LEFT JOIN sys.database_role_members r 
                    ON p.principal_id = r.member_principal_id 
                LEFT JOIN sys.database_principals p3 
                    ON r.role_principal_id = p3.principal_id 
                WHERE p.name = '" + username + "'";
            }

            var roles = new List<string>();
            using (var connection = GetTransactionService(config).CreateConnection()) {
                using (var command = GetExecutionService(config).CreateCommand(connection, sql)) {
                    command.CommandTimeout = QueryTimeout;
                    var reader = command.ExecuteReader();
                    while (reader.Read()) {
                        string groupName = (string)reader["RoleName"];
                        roles.Add(groupName);
                    }
                }
            }

            if (isAzureDB && roles.IsEmpty()) {
                // This exception is thrown to mirror the behaviour of calling 
                // sp_helpuser (in SQL Server) for an unexisting user.
                throw new Exception("Azure: user does not exist or does not have any roles.");
            }

            return roles;
        }

        public static RuntimeDatabaseConfiguration ConfigurationToMaster(IElevatedUserConfiguration conf) {
            var elevated = (RuntimeDatabaseConfiguration)conf.ElevatedRuntimeDatabaseConfiguration();
            elevated.Catalog = "master";
            return elevated;
        }

        public static bool LoginExists(IRuntimeDatabaseConfiguration config, string loginName) {
            try {
                string sql = "select count(*) from master.sys.server_principals where name = '" + loginName + "'";

                if (IsDatabaseAzure(config)) {
                    // We need to be using a connection string set specifically to the 'master' catalog.
                    sql = "select count(*) from sys.sql_logins where name = '" + loginName + "'";
                }

                return Convert.ToInt32(ExecuteScalar(config, sql)) > 0;
            } catch (Exception e) {
                throw new ConfigurationOperationException(string.Format("Error checking login {0}: {1}", loginName, e.Message), e);
            }
        }

        public static bool NeedsCreate(IRuntimeDatabaseConfiguration confToMasterCatalog, IRuntimeDatabaseConfiguration confToRuntimeCatalog, string user) {
            // The additional config parameter for master catalog is needed for Azure, 
            // due to limits in cross-catalog queries.
            return !IsDBAdmin(confToRuntimeCatalog, user) && !LoginExists(confToMasterCatalog, user);
        }

        public static string GrantSessionUserPermissions(SessionDatabaseConfiguration sessionConfiguration,
            PlatformDatabaseConfiguration platformConfiguration) {
            var config = sessionConfiguration.ElevatedRuntimeDatabaseConfiguration();

            // This is needed for Azure, due to limits in cross-catalog queries.
            // To keep everything consistent and maintain code readability, this
            // implied having an additional connection string for SQL Server
            var configMaster = ConfigurationToMaster(sessionConfiguration);

            var authType = sessionConfiguration.AuthenticationMode;

            // Create User
            if (NeedsCreate(configMaster, config, sessionConfiguration.SessionUser)) {
                if (authType == AuthenticationType.Windows_Authentication) {
                    AddIntegratedAuthLogin(config, sessionConfiguration.SessionUser);
                }
                AddDBAuthLogin(configMaster, sessionConfiguration.SessionUser, sessionConfiguration.SessionPassword);
            }

            string sqlStatement = SQLGetStatePermissionStatement(config, sessionConfiguration.SessionUser);

            // #1027143 - When using Windows Authentication, Admin user will need to access the Session Catalog
            // as the Controller needs to clean expired sessions
            // and we need to give it permissons here
            if (authType == AuthenticationType.Windows_Authentication) {
                if (platformConfiguration != null && platformConfiguration.AdminAuthenticationCredential != null) {
                    sqlStatement += SQLGetUserSessionPermissionStatement(config, platformConfiguration.AdminAuthenticationCredential.UserName);
                } else {
                    OSTrace.Error("Not possible to add permissions to Session Catalog to Admin User: Admin User Credentials were not found.");
                }
            }

            return sqlStatement;
        }

        /// <summary>
        /// This public string is apart from its method because it's used in the SandboxManager project.
        /// </summary>
        private static string SQLGetStatePermissionStatement(IRuntimeDatabaseConfiguration config, string username) {
            return SQLGetUserSessionPermissionStatement(config, username) + @"

                grant create table to HubSessionStateRole

                if exists (select name from sys.objects where name = N'ASPStateTempSessions')
                    grant select,update,insert,delete on ASPStateTempSessions to HubSessionStateRole
                if exists (select name from sys.objects where name = N'ASPStateTempApplications')
                    grant select,update,insert,delete on ASPStateTempApplications to HubSessionStateRole
                if exists (select name from sys.objects where object_id = object_id(N'[dbo].[ASPStateTempSessionsExtVars]'))
                    grant select,update,insert,delete on [dbo].[ASPStateTempSessionsExtVars] to HubSessionStateRole
                    
                if exists (select name from sys.objects where name = N'CreateTempTables')
                    grant execute on CreateTempTables to HubSessionStateRole
                if exists (select name from sys.objects where name = N'DeleteExpiredSessions')
                    grant execute on DeleteExpiredSessions to HubSessionStateRole
                if exists (select name from sys.objects where name = N'DeleteExpiredSessionsReturningDeletedRows')
                    grant execute on DeleteExpiredSessionsReturningDeletedRows to HubSessionStateRole
                if exists (select name from sys.objects where name = N'DeleteExpiredSessionVarsReturningDeletedRows')
                    grant execute on DeleteExpiredSessionVarsReturningDeletedRows to HubSessionStateRole
                if exists (select name from sys.objects where name = N'GetHashCode')
                    grant execute on GetHashCode to HubSessionStateRole
                if exists (select name from sys.objects where name = N'GetMajorVersion')
                    grant execute on GetMajorVersion to HubSessionStateRole
                if exists (select name from sys.objects where name = N'TempGetVersion')
                    grant execute on TempGetVersion to HubSessionStateRole
                if exists (select name from sys.objects where name = N'TempGetAppId')
                    grant execute on TempGetAppId to HubSessionStateRole
                if exists (select name from sys.objects where name = N'TempGetAppId2')
                    grant execute on TempGetAppId2 to HubSessionStateRole
                if exists (select name from sys.objects where name = N'TempGetStateItem')
                    grant execute on TempGetStateItem to HubSessionStateRole
                if exists (select name from sys.objects where name = N'TempGetStateItem2')
                    grant execute on TempGetStateItem2 to HubSessionStateRole
                if exists (select name from sys.objects where name = N'TempGetStateItem3')
                    grant execute on TempGetStateItem3 to HubSessionStateRole
                if exists (select name from sys.objects where name = N'TempGetStateItemExclusive')
                    grant execute on TempGetStateItemExclusive to HubSessionStateRole
                if exists (select name from sys.objects where name = N'TempGetStateItemExclusive2')
                    grant execute on TempGetStateItemExclusive2 to HubSessionStateRole
                if exists (select name from sys.objects where name = N'TempGetStateItemExclusive3')
                    grant execute on TempGetStateItemExclusive3 to HubSessionStateRole
                if exists (select name from sys.objects where name = N'TempInsertStateItemLong')
                    grant execute on TempInsertStateItemLong to HubSessionStateRole
                if exists (select name from sys.objects where name = N'TempInsertStateItemShort')
                    grant execute on TempInsertStateItemShort to HubSessionStateRole
                if exists (select name from sys.objects where name = N'TempInsertUninitializedItem')
                    grant execute on TempInsertUninitializedItem to HubSessionStateRole
                if exists (select name from sys.objects where name = N'TempReleaseStateItemExclusive')
                    grant execute on TempReleaseStateItemExclusive to HubSessionStateRole
                if exists (select name from sys.objects where name = N'TempRemoveStateItem')
                    grant execute on TempRemoveStateItem to HubSessionStateRole
                if exists (select name from sys.objects where name = N'TempResetTimeout')
                    grant execute on TempResetTimeout to HubSessionStateRole
                if exists (select name from sys.objects where name = N'TempUpdateStateItemLong')
                    grant execute on TempUpdateStateItemLong to HubSessionStateRole
                if exists (select name from sys.objects where name = N'TempUpdateStateItemLongNullShort')
                    grant execute on TempUpdateStateItemLongNullShort to HubSessionStateRole
                if exists (select name from sys.objects where name = N'TempUpdateStateItemShort')
                    grant execute on TempUpdateStateItemShort to HubSessionStateRole
                if exists (select name from sys.objects where name = N'TempUpdateStateItemShortNullLong')
                    grant execute on TempUpdateStateItemShortNullLong to HubSessionStateRole
                if exists (select name from sys.objects where name = N'SMSUnlockSessions')
                    grant execute on SMSUnlockSessions to HubSessionStateRole
                if exists (select name from sys.objects where name = N'SMSUnlockSessionsWithSubstring')
                    grant execute on SMSUnlockSessionsWithSubstring to HubSessionStateRole";
        }

        private static string SQLGetUserSessionPermissionStatement(IRuntimeDatabaseConfiguration config, string username) {
            return @"
                if not exists (select * from sys.database_principals where name = N'" + username + "' AND type = '" + SQLGetUserType(username) + @"')
                    " + SQLGetStatement_CreateUser(config, username, username) + @"
                if not exists (SELECT * FROM sys.database_principals WHERE name = N'HubSessionStateRole' AND type = 'R')
                begin
                    " + SQLGetStatement_CreateRole(config, "HubSessionStateRole") + @"
                end
                " + SQLGetStatement_AddRoleMember(config, "HubSessionStateRole", username);
        }

        private static bool NeedsPermissions(List<string> rolesAvailable, List<string> rolesNeed) {
            return !rolesAvailable.Contains(dbOwnerRole) && !rolesNeed.All(rolesAvailable.Contains);
        }

        private static List<string> GetUserRolesOrOwner(IRuntimeDatabaseConfiguration config, string userName) {
            if (IsDBAdmin(config, userName)) {
                return new List<string> { dbOwnerRole };
            }
            return GetUserRoles(config, userName);
        }

        internal static bool NeedsPermissionsForLog(IRuntimeDatabaseConfiguration conf, string username, AuthenticationType auth) {
            try {
                var logRoles = new List<string> { "HubLogRole" };
                return NeedsPermissions(GetUserRolesOrOwner(conf, username), logRoles);
            } catch {
                return true;
            }
        }
        
        private static readonly List<string> adminRoles = new List<string>() {
                                                                    "db_accessadmin",
                                                                    "db_securityadmin",
                                                                    "db_ddladmin",
                                                                    "db_datareader",
                                                                    "db_datawriter" };

        internal static bool NeedsPermissionsForAdmin(IRuntimeDatabaseConfiguration conf, string username) {
            try {
                return NeedsPermissions(GetUserRolesOrOwner(conf, username), adminRoles);
            } catch {
                return true;
            }
        }

        internal static bool NeedsPermissionsForReadWrite(IRuntimeDatabaseConfiguration conf, string username, AuthenticationType auth) {
            try {
                var runtimeRoles = new List<string> { "db_datareader", "db_datawriter" };
                return NeedsPermissions(GetUserRolesOrOwner(conf, username), runtimeRoles);
            } catch {
                return true;
            }
        }

        internal static void AddRuntimePermissionsAfterUpgradeScript(IRuntimeDatabaseConfiguration config, string username) {
            ExecuteStatements(config, GetGrantRuntimePermissionsStatements(username));
        }

        public static void ExecuteStatements(IRuntimeDatabaseConfiguration config, IEnumerable<string> statements) {
            foreach (string statement in statements) {
                ExecuteNonQuery(config, statement);
            }
        }

        private static readonly Regex _varcharRe = new Regex("([^A-Z0-9_\\[\"])varchar(2?)([^A-Z0-9_])", RegexOptions.IgnoreCase | RegexOptions.Compiled);
        private static readonly Regex _textRe = new Regex("([^A-Z0-9_\\[\"])text([^A-Z0-9_])", RegexOptions.IgnoreCase | RegexOptions.Compiled);
        private static readonly Regex _clobRe = new Regex("([^A-Z0-9_\"])clob([^A-Z0-9_])", RegexOptions.IgnoreCase | RegexOptions.Compiled);

        internal static string ProcessStatement<DatabaseConfiguration>(DatabaseConfiguration conf, string statement, Dictionary<string, string> extraTokenMappings)
            where DatabaseConfiguration : AbstractTwoUserDatabaseConfiguration, IDatabaseConfiguration {
            statement = statement.Trim();

            if (conf.Unicode) {
                statement = _varcharRe.Replace(statement, "$1nvarchar$2$3");
                statement = _clobRe.Replace(statement, "$1nclob$2");
                statement = _textRe.Replace(statement, "$1ntext$2");
            }

            return ReplaceTokens(conf, statement, extraTokenMappings);
        }

        /// <summary>
        /// Replaces known tokens in the given statement
        /// </summary>
        /// <param name="statement"></param>
        /// <returns></returns>

        internal static string ReplaceTokens<DatabaseConfiguration>(DatabaseConfiguration conf, string statement, Dictionary<string, string> extraTokenMappings)
            where DatabaseConfiguration : AbstractTwoUserDatabaseConfiguration, IDatabaseConfiguration {
            const string TAG_CATALOG = "[CATALOG]";
            const string TAG_ADMINUSERNAME = "[OSADMIN_USERNAME]";
            const string TAG_ADMINPASSWORD = "[OSADMIN_PASSWORD]";
            const string TAG_RUNTIMEUSERNAME = "[OSRUNTIME_USERNAME]";
            const string TAG_RUNTIMEPASSWORD = "[OSRUNTIME_PASSWORD]";
            const string TAG_AUTH = "[AUTH]";

            //PlatformDatabaseConfiguration conf = (PlatformDatabaseConfiguration)uiConfiguration;
            StringBuilder sb = new StringBuilder(statement);

            var tokenMap = new Dictionary<string, string>() {
                { TAG_CATALOG, conf.Catalog },
                { TAG_ADMINUSERNAME, conf.AdminUser },
                { TAG_ADMINPASSWORD, conf.AdminPassword },
                { TAG_RUNTIMEUSERNAME, conf.RuntimeUser },
                { TAG_RUNTIMEPASSWORD, conf.RuntimePassword },
                { TAG_AUTH, conf.AuthenticationMode == AuthenticationType.Windows_Authentication ? "windows" : "sql" },
            };

            var allTokens = extraTokenMappings != null ? tokenMap.Union(extraTokenMappings) : tokenMap;
            foreach (var tokenReplacement in allTokens) {
                sb.Replace(tokenReplacement.Key, tokenReplacement.Value);
            }

            return sb.ToString();
        }

        public static IEnumerable<string> GetGrantRuntimePermissionsStatements(string username) {
            yield return "grant execute on dbo.CheckRole to [" + username + "]";
        }

        private static string GetDBAuthLogin(string username, string password) {
            return "CREATE LOGIN " + username + " WITH PASSWORD = '" + password + "', CHECK_POLICY = OFF, DEFAULT_DATABASE = master, DEFAULT_LANGUAGE = us_english";
        }

        private static string GetDBAuthLoginForAzure(string username, string password) {
            // Azure does not support CHECK_POLICY = * | DEFAULT_DATABASE = * | DEFAULT_LANGUAGE = *
            return "CREATE LOGIN " + username + " WITH PASSWORD = '" + password + "'";
        }

        internal static int AddDBAuthLogin(IRuntimeDatabaseConfiguration config, string username, string password) {
            try {
                string sql = GetDBAuthLogin(username, password);

                if (IsDatabaseAzure(config)) {
                    sql = GetDBAuthLoginForAzure(username, password);
                }

                return ExecuteNonQuery(config, sql);
            } catch (Exception e) {
                throw new ConfigurationOperationException("Adding login to " + username + ": " + e.Message, e);
            }
        }

        private static string GetIntegratedAuthLogin(string username) {
            return "CREATE LOGIN [" + username + "] FROM WINDOWS WITH DEFAULT_DATABASE = master, DEFAULT_LANGUAGE = us_english";
        }

        internal static int AddIntegratedAuthLogin(IRuntimeDatabaseConfiguration config, string username) {
            try {
                string sql = GetIntegratedAuthLogin(username);

                if (IsDatabaseAzure(config)) {
                    // Integrated mode for Azure SQL isn't supported yet.
                    throw new NotImplementedException("");
                }

                return ExecuteNonQuery(config, sql);
            } catch (Exception e) {
                throw new ConfigurationOperationException("Adding login to " + username + ": " + e.Message, e);
            }
        }

        internal static int AddAdminPermissions(IRuntimeDatabaseConfiguration config, string username) {
            try {
                string sql = @"if not exists (select * from sys.database_principals where name = N'" + username + @"' AND type = '" + SQLGetUserType(username) + @"')
                        " + SQLGetStatement_CreateUser(config, username, username) + @"
                    " + SQLGetStatement_AddRoleMember(config, dbOwnerRole, username);

                return ExecuteNonQuery(config, sql);
            } catch (Exception e) {
                throw new ConfigurationOperationException("Adding permissions to " + username + ": " + e.Message, e);
            }
        }

        internal static int AddReadWritePermissions(IRuntimeDatabaseConfiguration config, string username) {
            try {
                string sql = @"if not exists (select * from sys.database_principals where name = N'" + username + @"' AND type = '" + SQLGetUserType(username) + @"')
                    " + SQLGetStatement_CreateUser(config, username, username) + @"
                    " + SQLGetStatement_AddRoleMember(config, "db_datareader", username) + @"
                    " + SQLGetStatement_AddRoleMember(config, "db_datawriter", username);

                return ExecuteNonQuery(config, sql);
            } catch (Exception e) {
                throw new ConfigurationOperationException("Adding permissions to " + username + ": " + e.Message, e);
            }
        }

        internal static int AddLogPermissions(IRuntimeDatabaseConfiguration config, string username) {
            try {
                // Note: This cannot be executed inside a transaction
                // [PJT] The role creation script is also present in the db\runtimemodel_sqlserver.sql
                string sql = @"if not exists (select * from sys.database_principals where name = N'" + username + @"' AND type = '" + SQLGetUserType(username) + @"')
                        " + SQLGetStatement_CreateUser(config, username, username) + @"
                        if not exists (" + SqlServerGetSelectForCheckRole("HubLogRole") + @")
                        begin
                            " + SQLGetStatement_CreateRole(config, "HubLogRole") + @"
                        end
                        " + SQLGetStatement_AddRoleMember(config, "HubLogRole", username);

                return ExecuteNonQuery(config, sql);
            } catch (Exception e) {
                throw new ConfigurationOperationException("Adding permissions to " + username + ": " + e.Message, e);
            }
        }

        private static string SQLGetUserType(string username) {
            return ("{0}".F(username).Contains(@"\") ? "U" : "S");
        }

        public static bool IsDBAdmin(IRuntimeDatabaseConfiguration config, string login) {
            try {
                bool isDBAdmin = false;

                if (IsDatabaseAzure(config)) {
                    isDBAdmin = CountOfCreateRoleInAzureDB(config, login) == 2;
                } else {
                    isDBAdmin = CountOfCreateRoleInDB(config, login) == 1;
                }

                return isDBAdmin;
            } catch (Exception e) {
                throw new ConfigurationOperationException(string.Format("Unable to check {0} is admin: {1}", login, e.Message), e);
            }
        }

        private static int CountOfCreateRoleInDB(IRuntimeDatabaseConfiguration config, string login) {
            string sql = "SELECT count(*) FROM sys.database_principals WHERE name = '" + login + "'";
            var result = Convert.ToInt32(ExecuteScalar(config, sql));
            if (result > 0) {
                sql = @"select count(*) from sys.database_permissions perm 
                    inner join sys.database_principals princ on perm.grantee_principal_id = princ.principal_id 
                    and princ.name = N'" + login + "' and perm.permission_name  = N'CREATE ROLE'";

                return Convert.ToInt32(ExecuteScalar(config, sql));
            }
            return 0;
        }

        private static int CountOfCreateRoleInAzureDB(IRuntimeDatabaseConfiguration configBase, string login) {
            string sql = "SELECT count(*) FROM sys.database_principals WHERE name = '" + login + "'";
            var result = Convert.ToInt32(ExecuteScalar(configBase, sql));
            // We can't check for the specific 'CREATE ROLE' permission in Azure, 
            // so we check the user for roles that allow role creation.
            // This means that the output of this function will necessarily be different
            // than that of CountOfCreateRoleInDB.
            if (result > 0) {
                sql =
                @"SELECT 
                    COUNT(*) 
                FROM sys.database_principals p 
                JOIN sys.database_permissions prm 
                    ON p.principal_id = prm.grantee_principal_id 
                LEFT JOIN sys.database_principals p2 
                    ON prm.major_id = p2.principal_id 
                LEFT JOIN sys.database_role_members r 
                    ON p.principal_id = r.member_principal_id 
                LEFT JOIN sys.database_principals p3 
                    ON r.role_principal_id = p3.principal_id 
                WHERE p.name = '" + login + "' AND (p2.name = 'dbmanager' OR p2.name = 'loginmanager')";
                return Convert.ToInt32(ExecuteScalar(configBase, sql));
            }
            return 0;
        }

        public static string GetHubServerVersion(ITwoUserDatabaseConfigurationManager manager, IRuntimeDatabaseConfiguration config) {
            string sql = null;

            if (manager is PlatformConfigurationManager) {
                sql = "SELECT Val FROM ossys_Parameter WHERE Name = 'version'";
            } else if (manager is LoggingDatabaseConfigurationManager) {
                sql = "SELECT Val FROM oslog_Parameter WHERE Name = 'version'";
            } else {
                sql = "SELECT version FROM OSSYS_SCHEMA_VERSION";
            }

            var obj = ExecuteScalar(config, sql);
            if (obj == null || obj == DBNull.Value) {
                return string.Empty;
            }

            try {
                return Convert.ToString(obj);
            } catch (Exception) {
                return null;
            }
        }

        public static bool CheckBuild(string version1) {
            var v1 = new Version(version1);
            var v2 = InnerGetExecutingAssemblyVersion();
            return v1.Major == v2.Major && v1.Minor == v2.Minor && v1.Build == v2.Build;
        }

        public static void CheckSessionRoles(ISessionDatabaseConfiguration platformConfig, out string friendlyMessage) {
            try {
                bool hasStateRole = false, owner = false;
                var config = platformConfig.RuntimeDatabaseConfiguration();
                if (IsDBAdmin(config, config.Username)) {
                    owner = true;
                } else {
                    var rolesNames = GetUserRoles(config, config.Username);
                    foreach (var roleName in rolesNames) {
                        switch (roleName) {
                            case "HubSessionStateRole":
                                hasStateRole = true;
                                break;
                            case dbOwnerRole:
                                owner = true;
                                break;
                        }
                    }
                }

                if (!owner) {
                    if (!hasStateRole) {
                        friendlyMessage = "Database connection was successful.\r\n\r\nHowever, the user does not have the following permission(s):\r\n\r\nUser " + config.Username + " is not part of HubSessionStateRole.";
                        return;
                    }
                }
            } catch (Exception exception) {
                friendlyMessage = "Database connection was successful.\r\n\r\nHowever, the following error ocurred while trying to read user permissions:\r\n\r\nFailed to retrieve user roles:\r\n\r\n" + exception.Message;
                return;
            }
            friendlyMessage = "Test completed successfully.";
        }
        
        public static bool CheckHubServerVersion(ITwoUserDatabaseConfigurationManager manager, IRuntimeDatabaseConfiguration config, out string friendlyMessage) {
            friendlyMessage = "";

            object obj = GetHubServerVersion(manager, config);
            if (obj != null) {
                string version = (string)obj;
                if (!CheckBuild(version)) {
                    Version vi = null;
                    try {
                        vi = new Version(version);
                    } catch {
                        // Invalid version found. Error message below.
                    }
                    if (vi == null) {
                        friendlyMessage = "Database connection was successful.\r\n\r\nHowever an invalid schema version (v" + version + ") was found. You may need to upgrade the schema.";
                    }
                    Version viProd = InnerGetExecutingAssemblyVersion();
                    if (viProd < vi) {
                        friendlyMessage = "Database connection was successful.\r\n\r\nHowever the schema version (v" + vi + ") is higher than the current Platform version (v" + viProd + ").";
                    }
                    if (viProd > vi) {
                        friendlyMessage = "Database connection was successful.\r\n\r\nHowever the schema (v" + vi + ") should be upgraded to the latest version (v" + viProd + ").";
                    }
                    friendlyMessage = "Database connection was successful.\r\n\r\nHowever an invalid schema version (v" + version + ") was found. You may need to upgrade to upgrade the schema.";
                }
            } else {
                friendlyMessage = "Database connection was successful.\r\n\r\nHowever, it was not possible to read the schema version. This may be because the schema has not been created yet.";
            }
            return friendlyMessage.IsEmpty();
        }


        public static bool CheckDBLogRoles(string username, bool canRead, bool canWrite, bool hasLogRole, AuthenticationType authMode, out string friendlyMessage) {
            friendlyMessage = "";

            if (!canRead) {
                friendlyMessage = "Database connection was successful.\r\n\r\nHowever the user does not have the following permission(s):\r\n\r\nUser " + username + " doesn't have read permissions.";
            }
            if (!canWrite && authMode == AuthenticationType.Windows_Authentication) {
                friendlyMessage = "Database connection was successful.\r\n\r\nHowever the user does not have the following permission(s):\r\n\r\nUser " + username + " doesn't have write permissions.";
            }
            if (!hasLogRole) {
                friendlyMessage = "Database connection was successful.\r\n\r\nHowever the user does not have the following permission(s):\r\n\r\nUser " + username + " is not part of HubLogRole.";
                // User is not part of HubLogRole for catalog
                // 2004-11-03 MRC We wont skip now so we can test if the schema has been created.
                //                Should the schema be missing then naturally the user does not have the role
                //                If the schema is present then this error will be returned.
            }
            return friendlyMessage.IsEmpty();
        }

        public static bool CheckDBBusinessRuntimeRoles(string username, bool canRead, bool canWrite, bool hasLogRole, AuthenticationType authMode, out string friendlyMessage) {
            friendlyMessage = "";

            if (!canRead) {
                friendlyMessage = "Database connection was successful.\r\n\r\nHowever the user does not have the following permission(s):\r\n\r\nUser " + username + " doesn't have read permissions.";
            }
            if (!canWrite) {
                friendlyMessage = "Database connection was successful.\r\n\r\nHowever the user does not have the following permission(s):\r\n\r\nUser " + username + " doesn't have write permissions.";
            }
            if (!hasLogRole && authMode == AuthenticationType.Windows_Authentication) {
                friendlyMessage = "Database connection was successful.\r\n\r\nHowever the user does not have the following permission(s):\r\n\r\nUser " + username + " is not part of HubLogRole.";
            }
            return friendlyMessage.IsEmpty();
        }

        public static bool CheckDBPlatformRuntimeRoles(string username, bool canRead, bool canWrite, out string friendlyMessage) {
            friendlyMessage = "";

            if (!canRead) {
                friendlyMessage = "Database connection was successful.\r\n\r\nHowever the user does not have the following permission(s):\r\n\r\nUser " + username + " doesn't have read permissions.";
            }
            if (!canWrite) {
                friendlyMessage = "Database connection was successful.\r\n\r\nHowever the user does not have the following permission(s):\r\n\r\nUser " + username + " doesn't have write permissions.";
            }
            return friendlyMessage.IsEmpty();
        }

        public static bool CheckDBAdminRoles(string username, bool hasAccessAdmin, bool hasSecurityAdmin, bool hasDDLAdmin, bool canRead, bool canWrite, out string friendlyMessage) {
            friendlyMessage = "";
            string missingRoles = "";

            if (!hasAccessAdmin) {
                missingRoles += " db_accessadmin,";
            }
            if (!hasSecurityAdmin) {
                missingRoles += " db_securityadmin,";
            }
            if (!hasDDLAdmin) {
                missingRoles += " db_ddladmin,";
            }
            if (!canRead) {
                missingRoles += " db_datareader,";
            }
            if (!canWrite) {
                missingRoles += " db_datawriter,";
            }
            if (!missingRoles.IsEmpty()) {
                friendlyMessage = "Database connection was successful.\r\n\r\nHowever the user does not have the following permission(s):\r\n\r\nUser " + username + " is missing " + missingRoles.TrimEnd(',') + " roles.";
            }
            return friendlyMessage.IsEmpty();
        }

        public static void GetDBUserRoles(string username, ref bool hasLogRole, ref bool owner, ref bool canRead, ref bool canWrite, ref bool hasAccessAdmin, ref bool hasDDLAdmin, ref bool hasSecurityAdmin, IRuntimeDatabaseConfiguration config) {
            if (IsDBAdmin(config, username)) {
                owner = true;
            } else {
                var rolesNames = GetUserRoles(config, config.Username);
                foreach (var roleName in rolesNames) {
                    switch (roleName) {
                        case "HubLogRole":
                            hasLogRole = true;
                            break;
                        case dbOwnerRole:
                            owner = true;
                            break;
                        case "db_datareader":
                            canRead = true;
                            break;
                        case "db_datawriter":
                            canWrite = true;
                            break;
                        case "db_accessadmin":
                            hasAccessAdmin = true;
                            break;
                        case "db_ddladmin":
                            hasDDLAdmin = true;
                            break;
                        case "db_securityadmin":
                            hasSecurityAdmin = true;
                            break;
                    }
                }
            }
        }

        public static Version InnerGetExecutingAssemblyVersion() {
            return typeof(ConfigurationManagerUtils).Assembly.GetName().Version;
        }

        public static void AddHubLogRole(IRuntimeDatabaseConfiguration config) {
            string sql = " if not exists (" + SqlServerGetSelectForCheckRole("HubLogRole") + ")";
            sql += @"
                            begin
                                " + SQLGetStatement_CreateRole(config, "HubLogRole") + @"
                            end";
            ExecuteNonQuery(config, sql);
        }

        private static string SqlServerGetSelectForCheckRole(string roleName) {
            return @" SELECT * FROM sys.database_principals WHERE name = N'" + roleName + "' AND type = 'R'";
        }

        private static string SQLGetStatement_CreateUser(IRuntimeDatabaseConfiguration config, string userName, string loginName) {
            if (IsSQLServerVersionOlderThan2k12(config)) {
                return @"exec sp_grantdbaccess N'{0}', N'{1}'".F(userName, loginName);
            }
            // from SQL2012 onward, the recommended syntax changed
            return @"CREATE USER [{0}] FOR LOGIN [{1}]".F(userName, loginName);
        }

        private static string SQLGetStatement_DropRoleMember(IRuntimeDatabaseConfiguration config, string roleName, string memberName) {
            if (IsSQLServerVersionOlderThan2k12(config)) {
                return @"exec sp_droprolemember N'{0}', N'{1}'".F(roleName, memberName);
            }
            // from SQL2012 onward, the recommended syntax changed
            return @"ALTER ROLE [{0}] DROP MEMBER [{1}]".F(roleName, memberName);
        }

        private static string SQLGetStatement_AddRoleMember(IRuntimeDatabaseConfiguration config, string roleName, string memberName) {
            if (IsSQLServerVersionOlderThan2k12(config)) {
                return @"exec sp_addrolemember N'{0}', N'{1}'".F(roleName, memberName);
            }
            // from SQL2012 onward, the recommended syntax changed
            return @"ALTER ROLE [{0}] ADD MEMBER [{1}]".F(roleName, memberName);
        }

        private static string SQLGetStatement_CreateRole(IRuntimeDatabaseConfiguration config, string roleName) {
            if (IsSQLServerVersionOlderThan2k12(config)) {
                return @"exec sp_addrole " + roleName;
            }
            // from SQL2012 onward, the recommended syntax changed
            return @"CREATE ROLE [" + roleName + "]";
        }

        private static bool IsSQLServerVersionOlderThan2k12(IRuntimeDatabaseConfiguration config) {
            return ((SqlServer.ExecutionService.ExecutionService)GetExecutionService(config)).
                ServerVersion.IsOneOf(SqlServerVersion.Sql2000, SqlServerVersion.Sql2005, SqlServerVersion.Sql2008);
        }
    }
}