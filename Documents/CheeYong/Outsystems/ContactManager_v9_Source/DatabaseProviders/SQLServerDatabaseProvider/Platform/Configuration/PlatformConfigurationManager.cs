/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using OutSystems.HubEdition.DatabaseProvider.SqlServer.ConfigurationService;
using OutSystems.HubEdition.Extensibility.Data.ConfigurationService;
using OutSystems.HubEdition.Extensibility.Data.Platform.Configuration;
using OutSystems.RuntimeCommon;

namespace OutSystems.HubEdition.DatabaseProvider.SqlServer.Platform.Configuration {

    public class PlatformConfigurationManager : BasePlatformConfigurationManager {

        public PlatformConfigurationManager(IPlatformDatabaseConfiguration uiConfiguration)
            : base(uiConfiguration) {

            var config = (PlatformDatabaseConfiguration)uiConfiguration;

            config.SqlEngineEdition = ConfigurationManagerUtils.GetSqlEngineEdition(uiConfiguration);
        }

        public override bool RecommendDatabaseBackup {
            get {
                return false;
            }
        }

        public override FileStream StreamForScriptFile {
            get {
                string path = Path.Combine(Script_Path, "platform_model_sqlserver.sql");
                return new FileStream(path, FileMode.Open, FileAccess.Read);
            }
        }

        private FileStream StreamForSetupScriptFile {
            get {
                string path = Path.Combine(Script_Path, "platform_creation_sqlserver.sql");
                return new FileStream(path, FileMode.Open, FileAccess.Read);
            }
        }

        private static readonly Regex _varcharRe = new Regex("n?varchar", RegexOptions.IgnoreCase | RegexOptions.Compiled);                                                   
        private static readonly Regex _textRe = new Regex("([^A-Z0-9_\\[\"])text([^A-Z0-9_])", RegexOptions.IgnoreCase | RegexOptions.Compiled);
        private static readonly Regex _clobRe = new Regex("([^A-Z0-9_\"])clob([^A-Z0-9_])", RegexOptions.IgnoreCase | RegexOptions.Compiled);

        public override string ProcessStatement(string statement) {
            PlatformDatabaseConfiguration config = (PlatformDatabaseConfiguration)uiConfiguration;
            statement = statement.Trim();

            if (config.Unicode) {
                statement = _varcharRe.Replace(statement, "nvarchar");
                statement = _clobRe.Replace(statement, "$1nclob$2");
                statement = _textRe.Replace(statement, "$1ntext$2");
            }

            return ReplaceTokens(statement);
        }

        /// <summary>
        /// Replaces known tokens in the given statement
        /// </summary>
        /// <param name="statement"></param>
        /// <returns></returns>
        private string ReplaceTokens(string statement) {
            PlatformDatabaseConfiguration conf = (PlatformDatabaseConfiguration)uiConfiguration;
            const string TAG_LOGUSERNAME = "[OSLOG_USERNAME]";
            const string TAG_LOGPASSWORD = "[OSLOG_PASSWORD]";

            var tokenMap = new Dictionary<string, string>() {
                { TAG_LOGUSERNAME, conf.LogUser },
                { TAG_LOGPASSWORD, conf.LogPassword },
            };

            return ConfigurationManagerUtils.ReplaceTokens(conf, statement, tokenMap);
        }

        private void NormalizeWindowsUser(Func<PlatformDatabaseConfiguration, string> get, Action<PlatformDatabaseConfiguration, string> set) {
            var uiConf = (PlatformDatabaseConfiguration)uiConfiguration;

            if (uiConf.AuthenticationMode != AuthenticationType.Windows_Authentication) {
                return;
            }

            set(uiConf, WindowsUser.Normalize(get(uiConf)));
        }

        private void NormalizeLogUser() {
            NormalizeWindowsUser(c => c.LogUser, (c, v) => c.LogUser = v);
        }

        private void NormalizeAdminUser() {
            NormalizeWindowsUser(c => c.AdminUser, (c, v) => c.AdminUser = v);
        }

        private void NormalizeRuntimeUser() {
            NormalizeWindowsUser(c => c.RuntimeUser, (c, v) => c.RuntimeUser = v);
        }

        private void NormalizeAllUsers() {
            NormalizeLogUser();
            NormalizeRuntimeUser();
            NormalizeAdminUser();
        }

        public override bool RequiresElevatedPrivilges() {
            try {
                RuntimeDatabaseConfiguration confAdmin = (RuntimeDatabaseConfiguration)((TwoUserDatabaseConfiguration)uiConfiguration).RuntimeDatabaseConfiguration(UserType.Admin);
                RuntimeDatabaseConfiguration confRuntime = (RuntimeDatabaseConfiguration)((TwoUserDatabaseConfiguration)uiConfiguration).RuntimeDatabaseConfiguration(UserType.Runtime);

                return ConfigurationManagerUtils.LoginExists(confAdmin, confAdmin.Username) == false ||
                    ConfigurationManagerUtils.LoginExists(confRuntime, confRuntime.Username) == false ||
                    ConfigurationManagerUtils.DatabaseExists(confAdmin, confAdmin.Catalog) == false;
            } catch {
                return base.RequiresElevatedPrivilges();
            }
        }

        public override string GenerateSetupScript() {

            NormalizeAllUsers();
            PlatformDatabaseConfiguration conf = (PlatformDatabaseConfiguration)uiConfiguration;

            //for P10 the setup script is going to be generated by the conf tool to avoid duplication
            string setupScript = ReplaceTokens(ReadScriptFile(StreamForSetupScriptFile));

            return setupScript;
        }

        public override void Pre_CreateOrUpgradePlatform() {

            NormalizeAllUsers();

            var elevated = (IElevatedUserConfiguration)uiConfiguration;

            var masterElevated = ConfigurationManagerUtils.ConfigurationToMaster(elevated);

            var runtimeElevated = (RuntimeDatabaseConfiguration)elevated.ElevatedRuntimeDatabaseConfiguration();

            bool isAzureDB = ConfigurationManagerUtils.IsDatabaseAzure(masterElevated);

            if (isAzureDB) {
                // On the unlikely scenario of an on-premise installation with Azure SQL,
                // we try to minimise the chance of timeouts.
                ConfigurationManagerUtils.QueryTimeout = 300;
            }

            ConfigurationManagerUtils.CheckIfUserHasNecessaryElevatedPermissions(masterElevated, runtimeElevated);

            if (!isAzureDB) {
                ConfigurationManagerUtils.CreateSqlServerCatalogIfDoesntExist(masterElevated, runtimeElevated.Catalog);
            } else {
                // We will not support automatically creating Azure databases.
                // An appropriate message is displayed.
                ConfigurationManagerUtils.CheckIfAzureDatabaseExists(masterElevated, runtimeElevated.Catalog);
            }

            GrantPlatformDatabaseUserPermissions((PlatformDatabaseConfiguration)uiConfiguration);
        }

        private void GrantPlatformDatabaseUserPermissions(PlatformDatabaseConfiguration dbConfig) {
            var configRuntime = dbConfig.ElevatedRuntimeDatabaseConfiguration();
            var configMaster = ConfigurationManagerUtils.ConfigurationToMaster(dbConfig);
            var authType = dbConfig.AuthenticationMode;

            // Create User

            if (ConfigurationManagerUtils.NeedsCreate(configMaster, configRuntime, dbConfig.AdminUser)) {
                if (authType == AuthenticationType.Windows_Authentication) {
                    ConfigurationManagerUtils.AddIntegratedAuthLogin(configRuntime, dbConfig.AdminUser);
                } else {
                    ConfigurationManagerUtils.AddDBAuthLogin(configMaster, dbConfig.AdminUser, dbConfig.AdminPassword);
                }
            }

            if (ConfigurationManagerUtils.NeedsPermissionsForAdmin(configRuntime, dbConfig.AdminUser)) {
                ConfigurationManagerUtils.AddAdminPermissions(configRuntime, dbConfig.AdminUser);
            }

            if (ConfigurationManagerUtils.NeedsCreate(configMaster, configRuntime, dbConfig.RuntimeUser)) {
                if (authType == AuthenticationType.Windows_Authentication) {
                    ConfigurationManagerUtils.AddIntegratedAuthLogin(configRuntime, dbConfig.RuntimeUser);
                } else {
                    ConfigurationManagerUtils.AddDBAuthLogin(configMaster, dbConfig.RuntimeUser, dbConfig.RuntimePassword);
                }
            }

            if (ConfigurationManagerUtils.NeedsPermissionsForReadWrite(configRuntime, dbConfig.RuntimeUser, dbConfig.AuthenticationMode)) {
                ConfigurationManagerUtils.AddReadWritePermissions(configRuntime, dbConfig.RuntimeUser);
            }

            try {
                ConfigurationManagerUtils.AddRuntimePermissionsAfterUpgradeScript(configRuntime, dbConfig.RuntimeUser);
            } catch { }

            GrantPlatformPermissions(dbConfig);
        }

        private static void GrantPlatformPermissions(PlatformDatabaseConfiguration platformConfiguration) {
            try {
                ConfigurationManagerUtils.ExecuteStatements(
                    platformConfiguration.ElevatedRuntimeDatabaseConfiguration(),
                    GetGrantPlatformPermissionsStatements(platformConfiguration.RuntimeUser));
            } catch { }
        }

        public static IEnumerable<string> GetGrantPlatformPermissionsStatements(string username) {
            yield return "grant execute on dbo.DEQUEUE_EMAILS_FOR_FRONTEND to [" + username + "]";
            yield return "grant execute on dbo.DEQUEUE_EMAILS_FOR_APP to [" + username + "]";
            yield return "grant execute on dbo.DEQUEUE_BPM_EVENT_FOR_FRONT to [" + username + "]";
            yield return "grant execute on dbo.DEQUEUE_BPM_EVENT_FOR_APP to [" + username + "]";
            yield return "grant execute on dbo.DEQUEUE_EVENT_FOR_FRONTEND to [" + username + "]";
            yield return "grant execute on dbo.DEQUEUE_EVENT_FOR_APP to [" + username + "]";
        }

        public override string StatementSeparator {
            get {
                return "GO";
            }
        }

        public override bool TestAdminConnection(out string friendlyMessage, Source source) {
            NormalizeAdminUser();
            bool result = base.TestAdminConnection(out friendlyMessage, source);
            if (result) {
                CheckRoles(out friendlyMessage, source, UserType.Admin, uiConfiguration.AdminAuthenticationCredential.UserName);
            }
            return result;
        }

        public override bool TestRuntimeConnection(out string friendlyMessage, Source source) {
            NormalizeRuntimeUser();
            bool result = base.TestRuntimeConnection(out friendlyMessage, source);
            if (result) {
                CheckRoles(out friendlyMessage, source, UserType.Runtime, uiConfiguration.RuntimeAuthenticationCredential.UserName);
            }
            return result;
        }

        public override IEnumerable<Block> ExtraDatabaseStatements(Version currentModelVersion) {
            // Create an extra Block for the current version to add extra permissions to runtime user.
            var newBlock = new Block();
            newBlock.SetTagValue(Tag.END_IGNORING_BLOCK.ToString(), "");
            string runtimeuser = ((PlatformDatabaseConfiguration)uiConfiguration).RuntimeUser;

            ConfigurationManagerUtils.GetGrantRuntimePermissionsStatements(runtimeuser).Apply(statement => newBlock.AddStatement(statement));
            GetGrantPlatformPermissionsStatements(runtimeuser).Apply(statement => newBlock.AddStatement(statement));

            yield return newBlock;
        }

        public void CheckRoles(out string friendlyMessage, Source source, UserType user, string username) {

            try {
                bool dummy = false, owner = false, canRead = false, canWrite = false;
                bool hasAccessAdmin = false, hasDDLAdmin = false, hasSecurityAdmin = false;
                var config = ((PlatformDatabaseConfiguration)uiConfiguration).RuntimeDatabaseConfiguration(source, user);
                try {
                    ConfigurationManagerUtils.GetDBUserRoles(username, ref dummy, ref owner, ref canRead, ref canWrite, ref hasAccessAdmin, ref hasDDLAdmin, ref hasSecurityAdmin, config);

                    switch (user) {
                        case UserType.Admin:
                            if (!owner) {
                                if (!ConfigurationManagerUtils.CheckDBAdminRoles(username, hasAccessAdmin, hasSecurityAdmin, hasDDLAdmin, canRead, canWrite, out friendlyMessage)) {
                                    return;
                                }
                            }
                            break;
                        case UserType.Runtime:
                            if (!owner) {
                                ConfigurationManagerUtils.CheckDBPlatformRuntimeRoles(username, canRead, canWrite, out friendlyMessage);
                                if (!friendlyMessage.IsNullOrEmpty()) {
                                    return;
                                }
                            }
                            break;
                    }

                    if (!ConfigurationManagerUtils.CheckHubServerVersion(this, config, out friendlyMessage)) {
                        return;
                    }
                } catch {
                    friendlyMessage = "Database connection was successful.\r\n\r\nHowever, it was not possible to read the schema version. This may be because the schema has not been created yet.";
                    return;
                }
            } catch (Exception exception) {
                friendlyMessage = "Database connection was successful.\r\n\r\nHowever the following error ocurred while trying to read user permissions:\r\n\r\nFailed to retrieve user roles:\r\n\r\n" + exception.Message;
                return;
            }
            friendlyMessage = "Test completed successfully.";
        }

        public override int QueryTimeout {
            set {
                ConfigurationManagerUtils.QueryTimeout = value;
            }
        }
    }
}