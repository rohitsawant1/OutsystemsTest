/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using OutSystems.HubEdition.DatabaseProvider.Oracle.DatabaseObjects;
using OutSystems.HubEdition.Extensibility.Data;
using OutSystems.HubEdition.Extensibility.Data.DatabaseObjects;
using OutSystems.HubEdition.Extensibility.Data.DMLService;
using OutSystems.HubEdition.Extensibility.Data.IntrospectionService;
using OutSystems.RuntimeCommon;

namespace OutSystems.HubEdition.DatabaseProvider.Oracle.IntrospectionService {

    public class IntrospectionService : BaseIntrospectionService {

        protected delegate AutoNumberColumnInfo CreateAutoNumberInfo(string triggerType, string triggeringEvent, string triggerName, string triggerBody);

        protected delegate DataTypeInfo CreateDataTypeInfo(string type, int length, int precision, int scale);

        protected delegate TableSourceColumnInfo CreateColumnInfo(TableSourceInfo tableSource, string columnName, DataTypeInfo dataType, bool isMandatory,
            bool isPrimaryKey, AutoNumberColumnInfo autoNumberInfo);

        public IntrospectionService(IDatabaseServices databaseServices) : base(databaseServices) { }

        public virtual bool IncludeDatabaseLinks {
            get {
                return false;
            }
        }

        public override IEnumerable<IDatabaseInfo> ListDatabases() {
            return ListDatabases(IncludeDatabaseLinks);
        }

        protected IEnumerable<IDatabaseInfo> ListDatabases(bool includeDatabaseLinks) {
            IList<IDatabaseInfo> databases = GetLocalDatabases().ToList();
            if (includeDatabaseLinks) {
                foreach (var linkedServer in GetLinkedServers()) {
                    try {
                        foreach (var dbInfo in GetLinkedDatabases(linkedServer)) {
                            databases.Add(dbInfo);
                        }
                    } catch (Exception e) {
                        LogException(e, "Error accessing linked server: " + linkedServer);
                    }
                }
            }
            return databases;
        }

        private IEnumerable<IDatabaseInfo> GetLocalDatabases() {
            return GetDatabases( /*server*/null, /*isLinkedServer*/false);
        }

        private IEnumerable<IDatabaseInfo> GetLinkedDatabases(string server) {
            return GetDatabases(server, /*isLinkedServer*/true);
        }

        private IEnumerable<IDatabaseInfo> GetDatabases(string server, bool isLinkedServer) {
            string link = GetDatabaseLinkName(server, isLinkedServer);
            string selectTables = "(select distinct owner from all_tables" + link + ")";
            string selectViews = "(select distinct owner from all_views" + link + ")";
            string selectOwners = "select distinct owner from (" + selectTables + " union " + selectViews + ")";
            using (IDbConnection conn = DatabaseServices.TransactionService.CreateConnection()) {
                IDbCommand cmd = DatabaseServices.ExecutionService.CreateCommand(conn, selectOwners);
                cmd.CommandTimeout = QueryTimeout;
                using (IDataReader reader = DatabaseServices.ExecutionService.ExecuteReader(cmd)) {
                    while (reader.Read()) {
                        string dbName = Convert.ToString(reader["OWNER"]);
                        yield return new DatabaseInfo(DatabaseServices, dbName, server);
                    }
                }
            }
        }

        private string GetDatabaseLinkName(string server, bool isLinkedServer) {
            return (isLinkedServer ? ("@" + DatabaseServices.DMLService.Identifiers.EscapeIdentifier(server)) : "");
        }

        private IEnumerable<string> GetLinkedServers() {
            using (IDbConnection conn = DatabaseServices.TransactionService.CreateConnection()) {
                IDbCommand cmd = DatabaseServices.ExecutionService.CreateCommand(conn,
                    "select db_link from all_db_links where owner = 'PUBLIC' or owner = sys_context('USERENV', 'SESSION_USER')");
                cmd.CommandTimeout = QueryTimeout;

                using (IDataReader reader = DatabaseServices.ExecutionService.ExecuteReader(cmd)) {
                    while (reader.Read()) {
                        yield return Convert.ToString(reader["DB_LINK"]);
                    }
                }
            }
        }

        public override IEnumerable<ITableSourceInfo> ListTableSources(IDatabaseInfo database, IsTableSourceToIgnore isTableSourceToIgnore) {
            var databaseInfo = database as DatabaseInfo;
            if (databaseInfo == null) {
                yield break;
            }
            using (IDbConnection conn = DatabaseServices.TransactionService.CreateConnection()) {
                if (!OwnerExists(conn, databaseInfo)) {
                    throw new IntrospectionServiceException("Inexistent database: " + databaseInfo.Schema);
                }

                string link = GetDatabaseLinkName(databaseInfo.DatabaseLink, databaseInfo.IsDatabaseLink);
                string sql = "select OBJECT_NAME TABLE_NAME from all_objects" + link +
                             " where not (OBJECT_NAME like 'BIN$%$%') and (OBJECT_TYPE = 'TABLE' or OBJECT_TYPE = 'VIEW') and owner = "
                             + DatabaseServices.ExecutionService.ParameterPrefix + "dbName";

                IDbCommand cmd = DatabaseServices.ExecutionService.CreateCommand(conn, sql);
                cmd.CommandTimeout = QueryTimeout;
                DatabaseServices.ExecutionService.CreateParameter(cmd, DatabaseServices.ExecutionService.ParameterPrefix + "dbName",
                    DbType.String, databaseInfo.Schema);
                using (IDataReader reader = DatabaseServices.ExecutionService.ExecuteReader(cmd)) {
                    while (reader.Read()) {
                        string tableName = Convert.ToString(reader["TABLE_NAME"]);
                        if (!databaseInfo.IsDatabaseLink &&
                            (tableName.ToLowerInvariant().Equals("dual") || isTableSourceToIgnore(tableName))) {
                            continue;
                        }
                        yield return
                            new TableSourceInfo(DatabaseServices, databaseInfo, tableName, GetQualifiedTableName(databaseInfo, tableName));
                    }
                }
            }
        }

        private bool OwnerExists(IDbConnection conn, DatabaseInfo databaseInfo) {
            string queryCommonPart = GetDatabaseLinkName(databaseInfo.DatabaseLink, databaseInfo.IsDatabaseLink) +
                                     " where owner = " + DatabaseServices.ExecutionService.ParameterPrefix + "owner and rownum <= 1) ";

            IDbCommand cmd = DatabaseServices.ExecutionService.CreateCommand(conn,
                "select owner from ( " +
                "   (select owner from all_tables" + queryCommonPart +
                "   union " +
                "   (select owner from all_views" + queryCommonPart +
                ")");

            cmd.CommandTimeout = QueryTimeout;
            DatabaseServices.ExecutionService.CreateParameter(cmd, DatabaseServices.ExecutionService.ParameterPrefix + "owner",
                DbType.String, databaseInfo.Schema);
            using (IDataReader reader = DatabaseServices.ExecutionService.ExecuteReader(cmd)) {
                return reader.Read();
            }
        }

        protected string GetQualifiedTableName(DatabaseInfo databaseInfo, string tableName) {
            IDMLIdentifiers identifiers = DatabaseServices.DMLService.Identifiers;
            return string.Format("{0}.{1}{2}",
                identifiers.EscapeIdentifier(databaseInfo.Schema),
                identifiers.EscapeIdentifier(tableName),
                databaseInfo.IsDatabaseLink ? "@" + identifiers.EscapeIdentifier(databaseInfo.DatabaseLink) : "");
        }

        public override IEnumerable<ITableSourceForeignKeyInfo> GetTableSourceForeignKeys(ITableSourceInfo tableSource) {
            var ts = tableSource as TableSourceInfo;
            return (ts == null) ? null : GetForeignKeys(ts.ToEnumerable(), ts.Database);
        }

        public override IEnumerable<ITableSourceColumnInfo> GetTableSourceColumns(ITableSourceInfo tableSource) {
            var ts = tableSource as TableSourceInfo;
            return (ts == null) ? null : GetColumns(ts.ToEnumerable(), ts.Database, GetAutoNumberColumnInfoFromTrigger, GetDataTypeInfo, GetColumnInfo);
        }

        protected IEnumerable<ITableSourceColumnInfo> GetColumns(IEnumerable<TableSourceInfo> tableSources, DatabaseInfo dbInfo,
                CreateAutoNumberInfo createAutoNumber, CreateDataTypeInfo createDataType, CreateColumnInfo createColumnInfo) {
            var result = new List<ITableSourceColumnInfo>();

            using (IDbConnection conn = DatabaseServices.TransactionService.CreateConnection()) {
                var execService = DatabaseServices.ExecutionService as ExecutionService.ExecutionService;
                // #417717 - In these queries we don't want to use the CIAI settings
                if (execService != null) {
                    execService.ForceCSASSetting(conn);
                }

                IDictionary<string, AutoNumberColumnInfo> autoGeneratedColumns = new Dictionary<string, AutoNumberColumnInfo>();
                IList<TableSourceInfo> tableSourceList = tableSources.ToList();

                using (IDataReader reader = GetTriggersBulk(conn, tableSourceList, /*onlyAutoNumbers*/ true, String.Empty, dbInfo)) {
                    while (reader.Read()) {
                        string tableName = Convert.ToString(reader["TABLE_NAME"]);
                        if (autoGeneratedColumns.ContainsKey(tableName)) {
                            break;
                        }
                        string triggerName = Convert.ToString(reader["trigger_name"]).ToUpperInvariant();
                        string triggerBody = Convert.ToString(reader["trigger_body"]).ToUpperInvariant();
                        string triggerType = Convert.ToString(reader["trigger_type"]).ToUpperInvariant();
                        string triggeringEvent = Convert.ToString(reader["triggering_event"]).ToUpperInvariant();
                        var autoNumberInfo = createAutoNumber(triggerType, triggeringEvent, triggerName, triggerBody);
                        if (autoNumberInfo != null) {
                            autoGeneratedColumns[GetAutoNumberColumnKey(tableName, autoNumberInfo.ColumnName)] = autoNumberInfo;
                        }
                    }
                }

                using (IDataReader reader = GetColumnsBulk(conn, tableSourceList, dbInfo)) {
                    while (reader.Read()) {
                        string dataDefault = Convert.ToString(reader["DATA_DEFAULT"]);
                        string tableName = Convert.ToString(reader["TABLE_NAME"]);
                        string columnName = Convert.ToString(reader["COLUMN_NAME"]);
                        object constraintType = reader["CONSTRAINT_TYPE"];
                        object dataPrecision = reader["DATA_PRECISION"];
                        object dataScale = reader["DATA_SCALE"];

                        bool isMandatory = Convert.ToString(reader["NULLABLE"]).ToUpper() != "Y";
                        bool isPrimaryKey = !constraintType.Equals(DBNull.Value) && Convert.ToString(constraintType) == "P";
                        int precision = dataPrecision.Equals(DBNull.Value) ? 0 : Convert.ToInt32(dataPrecision);
                        int scale = dataScale.Equals(DBNull.Value) ? 0 : Convert.ToInt32(dataScale);

                        DataTypeInfo dataType = createDataType(Convert.ToString(reader["DATA_TYPE"]), Convert.ToInt32(reader["CHAR_LENGTH"]),
                            precision, scale);

                        AutoNumberColumnInfo autoNumberInfo;
                        autoGeneratedColumns.TryGetValue(GetAutoNumberColumnKey(tableName, columnName), out autoNumberInfo);

                        if (autoNumberInfo == null) { // For versions above 12c (12.1) autonumbers can be generated via identity or sequences
                            if (IsSequenceValue(dataDefault)) {
                                autoNumberInfo = new AutoNumberColumnInfo() {
                                    ColumnName = columnName
                                };
                            }
                        }

                        TableSourceInfo tableSource = tableSourceList.First(ts => ts.Name.EqualsIgnoreCase(tableName));
                        result.Add(createColumnInfo(tableSource, columnName, dataType, isMandatory, isPrimaryKey, autoNumberInfo));
                    }
                }
            }
            return result;
        }

        private static string GetAutoNumberColumnKey(string tableName, string columnName) {
            return tableName.ToUpperInvariant() + "." + columnName.ToUpperInvariant();
        }

        private static TableSourceColumnInfo GetColumnInfo(TableSourceInfo tableSource, string columnName, DataTypeInfo dataType, bool isMandatory,
                bool isPrimaryKey, AutoNumberColumnInfo autoNumberInfo) {

            return new TableSourceColumnInfo(tableSource, columnName, dataType, isMandatory, isPrimaryKey, autoNumberInfo != null);
        }

        protected AutoNumberColumnInfo GetAutoNumberColumnInfoFromTrigger(string triggerType, string triggeringEvent, string triggerName, string triggerBody) {
            bool isAutoNumber = triggerType == "BEFORE EACH ROW" && triggeringEvent == "INSERT";

            if (isAutoNumber) {
                string columnName = ParseColumnNameFromTrigger(triggerBody);
                if (!columnName.IsNullOrEmpty()) {
                    return new AutoNumberColumnInfo { ColumnName = columnName };
                }
            }
            return null;
        }

        private static string ParseColumnNameFromTrigger(string triggerBody) {
            if (triggerBody.IsNullOrEmpty()) {
                return null;
            }
            // This is a best guess effort
            const string prefixToFind = "INTO :NEW.";
            int newIndex = triggerBody.IndexOfIgnoreCase(prefixToFind);
            int prefixLength = prefixToFind.Length;
            if (newIndex == -1) {
                return null;
            }
            return triggerBody.Substring(newIndex + prefixLength,
                triggerBody.IndexOf(" ", newIndex + prefixLength) - newIndex - prefixToFind.Length).Trim('\"');
        }

        protected IDataReader GetColumnsBulk(IDbConnection conn, IEnumerable<TableSourceInfo> tableSources, DatabaseInfo dbInfo) {
            string link = GetDatabaseLinkName(dbInfo.DatabaseLink, dbInfo.IsDatabaseLink);
            string paramPrefix = DatabaseServices.ExecutionService.ParameterPrefix;


            string conditionParam;
            string conditionValue;
            string tableCondition = "atc.table_name " + GenerateTableCondition(tableSources, out conditionParam, out conditionValue);

            var dbSchema = string.IsNullOrEmpty(dbInfo.Schema) ? dbInfo.DatabaseServices.DatabaseConfiguration.Username : dbInfo.Schema;
            bool isCurrentSchemaUser = ((ExecutionService.ExecutionService)DatabaseServices.ExecutionService).IsConnectedUser(conn, dbSchema);
            string sql;
            if (!isCurrentSchemaUser) {
                sql = @"select atc.table_name, atc.column_name, atc.data_type, atc.char_length, atc.data_precision, atc.data_scale, atc.nullable, atc.data_default, constraint_type, column_id
                    from ALL_CONS_COLUMNS" + link + @" acc 
                    inner join all_constraints" + link +
                      @" ac on ac.CONSTRAINT_NAME = acc.CONSTRAINT_NAME and acc.owner = ac.owner and ac.CONSTRAINT_TYPE = 'P'
                    right join all_tab_columns" + link +
                      @" atc on acc.column_name=atc.column_name and acc.table_name=atc.table_name and acc.owner=atc.owner
                    where {0} and atc.owner=" + paramPrefix + @"owner 
                    order by column_id";
            } else {
                sql = @"select atc.table_name, atc.column_name, atc.data_type, atc.char_length, atc.data_precision, atc.data_scale, atc.nullable, atc.data_default, constraint_type, column_id
                    from USER_CONS_COLUMNS" + link + @" acc 
                    inner join user_constraints" + link + @" ac on ac.CONSTRAINT_NAME = acc.CONSTRAINT_NAME and ac.CONSTRAINT_TYPE = 'P'
                    right join user_tab_columns" + link + @" atc on acc.column_name=atc.column_name and acc.table_name=atc.table_name
                    where {0}
                    order by column_id";
            }
            sql = string.Format(sql, tableCondition);
            IDbCommand cmd = DatabaseServices.ExecutionService.CreateCommand(conn, sql);
            cmd.CommandTimeout = QueryTimeout;
            if (!conditionParam.IsNullOrEmpty()) {
                DatabaseServices.ExecutionService.CreateParameter(cmd, paramPrefix + conditionParam, DbType.String, conditionValue);
            }
            if (!isCurrentSchemaUser) {
                DatabaseServices.ExecutionService.CreateParameter(cmd, paramPrefix + "owner", DbType.String, dbSchema);
            }
            return DatabaseServices.ExecutionService.ExecuteReader(cmd);
        }

        protected IDataReader GetTriggersBulk(IDbConnection conn, IEnumerable<TableSourceInfo> tableSources, bool onlyAutoNumbers, string filterByPrefix,
                DatabaseInfo dbInfo) {

            string link = GetDatabaseLinkName(dbInfo.DatabaseLink, dbInfo.IsDatabaseLink);
            string paramPrefix = DatabaseServices.ExecutionService.ParameterPrefix;

            string conditionParam;
            string conditionValue;
            string tableCondition = "table_name " + GenerateTableCondition(tableSources, out conditionParam, out conditionValue);

            var dbSchema = string.IsNullOrEmpty(dbInfo.Schema) ? dbInfo.DatabaseServices.DatabaseConfiguration.Username : dbInfo.Schema;
            bool isCurrentSchemaUser = ((ExecutionService.ExecutionService)DatabaseServices.ExecutionService).IsConnectedUser(conn, dbSchema);
            string sql;
            if (!isCurrentSchemaUser) {
                sql = @"select table_name, trigger_name, trigger_body, trigger_type, triggering_event from sys.all_triggers" + link +
                      @" where {0} and table_owner=" +
                      paramPrefix + "owner and owner=" + paramPrefix + "owner";
            } else {
                sql = @"select table_name, trigger_name, trigger_body, trigger_type, triggering_event from sys.user_triggers" + link +
                      @" where {0} and table_owner=" +
                      paramPrefix + "owner";
            }

            var extraConditions = new List<string>();

            if (onlyAutoNumbers) {
                extraConditions.Add("trigger_type='BEFORE EACH ROW' and triggering_event='INSERT'");
            }

            if (!String.IsNullOrEmpty(filterByPrefix)) {
                extraConditions.Add(String.Format("UPPER(trigger_name) LIKE '{0}%'", filterByPrefix));
            }

            sql = string.Format(sql, extraConditions.Concat(tableCondition).StrCat(" AND "));
            IDbCommand cmd = DatabaseServices.ExecutionService.CreateCommand(conn, sql);
            cmd.CommandTimeout = QueryTimeout;
            if (!conditionParam.IsNullOrEmpty()) {
                DatabaseServices.ExecutionService.CreateParameter(cmd, paramPrefix + conditionParam, DbType.String, conditionValue);
            }
            DatabaseServices.ExecutionService.CreateParameter(cmd, paramPrefix + "owner", DbType.String, dbSchema);
            return DatabaseServices.ExecutionService.ExecuteReader(cmd);
        }

        private const int MAX_NUMBER_PRECISION = 38;
        private const int MAX_NUMBER_SCALE = 127;

        private static DataTypeInfo GetDataTypeInfo(string type, int length, int precision, int scale) {
            DBDataType dataType;
            int columnLength = 0, columnDecimals = 0;
            string extraInfo = "";
            string typeToCheck = type.ToLower();
            switch (typeToCheck) {
                case "blob":
                case "bfile":
                case "raw":
                case "long raw":
                    dataType = DBDataType.BINARY_DATA;
                    break;
                case "rowid":
                case "urowid":
                case "xmltype":
                case "nclob":
                case "clob":
                case "long":
                    dataType = DBDataType.TEXT;
                    columnLength = int.MaxValue;
                    break;
                case "number":
                    int virtualScale = (scale < 0) ? 0 : scale;
                    if (precision == 1 && scale == 0) {
                        dataType = DBDataType.BOOLEAN;
                        columnLength = 1;
                    } else if (precision.IsBetween(2, 9) && virtualScale == 0) {
                        dataType = DBDataType.INTEGER;
                    } else if (precision.IsBetween(10, 18) && virtualScale == 0) {
                        dataType = DBDataType.LONGINTEGER;
                    } else if (virtualScale > 8 || precision > 28) {
                        dataType = DBDataType.TEXT;
                        //Max(precision, scale) + decimal separator + minus sign + 0 (before decimal separator)
                        columnLength = Math.Max(precision, virtualScale) + 3;
                    } else if (precision == 0 && virtualScale == 0) {
                        dataType = DBDataType.TEXT;
                        //precision + decimal separator + minus sign + 0
                        columnLength = MAX_NUMBER_SCALE + MAX_NUMBER_PRECISION + 3;
                    } else {
                        dataType = DBDataType.DECIMAL;
                        columnLength = precision;
                        columnDecimals = virtualScale;
                    }
                    if (scale != 0 || precision != 0) {
                        extraInfo = "(" + precision + "," + scale + ")";
                    }
                    break;
                case "date":
                    dataType = DBDataType.DATE_TIME;
                    columnLength = 50; //Depends on database date formats, 50 should be enough
                    break;
                //doesn't appear
                //case "varchar":
                case "nvarchar2":
                case "varchar2":
                case "char":
                case "nchar":
                    extraInfo = "(" + length + ")";
                    dataType = DBDataType.TEXT;
                    columnLength = length;
                    break;
                case "binary_float":
                    dataType = DBDataType.TEXT;
                    columnLength = 55; // 50 should be the exact size, we are giving +5 just to be sure...
                    break;
                case "binary_double":
                case "float":
                    dataType = DBDataType.TEXT;
                    columnLength = 200; // 172 should be the exact size, we are giving +28 to be sure...
                    break;
                default:
                    //Matches types 'TIMESTAMP', 'TIMESTAMP WITH TIME ZONE' and 'TIMESTAMP WITH LOCAL TIME ZONE'
                    if (typeToCheck.StartsWith("timestamp")) {
                        dataType = DBDataType.DATE_TIME;
                        columnLength = 100; //Depends on database date formats, 100 should be enough
                    } else {
                        dataType = DBDataType.UNKNOWN;
                    }
                    break;
            }
            return new DataTypeInfo(dataType, type + extraInfo, columnLength, columnDecimals);
        }

        protected IEnumerable<ITableSourceForeignKeyInfo> GetForeignKeys(IEnumerable<TableSourceInfo> tableSources, DatabaseInfo dbInfo) {
            var result = new List<ITableSourceForeignKeyInfo>();
            using (IDbConnection conn = DatabaseServices.TransactionService.CreateConnection()) {
                var execService = DatabaseServices.ExecutionService as ExecutionService.ExecutionService;
                if (execService != null) {
                    execService.ForceCSASSetting(conn);
                }

                IEnumerable<TableSourceInfo> tableSourceList = tableSources.ToList();

                using (IDataReader reader = GetForeignKeysBulk(conn, tableSourceList, dbInfo)) {
                    while (reader.Read()) {
                        string foreignKeyName = Convert.ToString(reader["constraintname"]);
                        string columnName = Convert.ToString(reader["columnname"]);
                        string tableName = Convert.ToString(reader["tablename"]);
                        string referencedColumnName = Convert.ToString(reader["referencedcolumn"]);
                        string referencedTableName = Convert.ToString(reader["referencedtable"]);
                        bool isCascadeDelete = Convert.ToString(reader["delete_rule"]).EqualsIgnoreCase("CASCADE");
                        TableSourceInfo tableSource = tableSourceList.First(ts => ts.Name == tableName);

                        if (tableSource != null) {
                            ITableSourceInfo referencedTableSource = new TableSourceInfo(DatabaseServices, tableSource.Database,
                                referencedTableName, GetQualifiedTableName(tableSource.Database, referencedTableName));
                            ITableSourceForeignKeyInfo foreignKeyInfo = new TableSourceForeignKeyInfo(tableSource, foreignKeyName,
                                columnName, referencedTableSource, referencedColumnName, isCascadeDelete);
                            result.Add(foreignKeyInfo);
                        }
                    }
                }
            }
            return result;
        }

        protected IDataReader GetForeignKeysBulk(IDbConnection conn, IEnumerable<TableSourceInfo> tableSources, DatabaseInfo dbInfo) {
            string link = GetDatabaseLinkName(dbInfo.DatabaseLink, dbInfo.IsDatabaseLink);
            string paramPrefix = DatabaseServices.ExecutionService.ParameterPrefix;

            string conditionParam;
            string conditionValue;
            string tableCondition = "c.table_name " + GenerateTableCondition(tableSources, out conditionParam, out conditionValue);

            var dbSchema = string.IsNullOrEmpty(dbInfo.Schema) ? dbInfo.DatabaseServices.DatabaseConfiguration.Username : dbInfo.Schema;
            bool isCurrentSchemaUser = ((ExecutionService.ExecutionService)DatabaseServices.ExecutionService).IsConnectedUser(conn, dbSchema);
            string sql;
            if (!isCurrentSchemaUser) {
                sql = @"
                    SELECT c.constraint_name constraintname, c.table_name tablename, cc.column_name columnname, p.table_name referencedtable, 
                        pp.column_name referencedcolumn, c.delete_rule delete_rule 
                    FROM all_cons_columns" + link + @" cc, all_constraints" + link + @" p, all_constraints" + link + @" c, all_cons_columns" + link +
                      @" pp 
                    WHERE {0}
                    AND c.owner = " + paramPrefix +
                      @"owner AND c.constraint_type = 'R' AND p.owner = c.r_owner AND p.constraint_name = c.r_constraint_name 
                    AND cc.owner = c.owner AND cc.constraint_name = c.constraint_name 
                    AND cc.table_name = c.table_name AND pp.owner = p.owner AND pp.constraint_name = p.constraint_name 
                    AND pp.table_name = p.table_name";
            } else {
                sql = @"
                    SELECT c.constraint_name constraintname, c.table_name tablename, cc.column_name columnname, p.table_name referencedtable, 
                        pp.column_name referencedcolumn, c.delete_rule delete_rule 
                    FROM user_cons_columns" + link + @" cc, all_constraints" + link + @" p, user_constraints" + link + @" c, all_cons_columns" + link +
                      @" pp 
                    WHERE {0}
                    AND c.constraint_type = 'R' AND p.owner = c.r_owner AND p.constraint_name = c.r_constraint_name 
                    AND cc.owner = c.owner AND cc.constraint_name = c.constraint_name 
                    AND cc.table_name = c.table_name AND pp.owner = p.owner AND pp.constraint_name = p.constraint_name 
                    AND pp.table_name = p.table_name";
            }
            sql = string.Format(sql, tableCondition);

            IDbCommand cmd = DatabaseServices.ExecutionService.CreateCommand(conn, sql);
            cmd.CommandTimeout = QueryTimeout;
            if (!conditionParam.IsNullOrEmpty()) {
                DatabaseServices.ExecutionService.CreateParameter(cmd, paramPrefix + conditionParam, DbType.String, conditionValue);
            }
            if (!isCurrentSchemaUser) {
                DatabaseServices.ExecutionService.CreateParameter(cmd, paramPrefix + "owner", DbType.String, dbSchema);
            }
            return DatabaseServices.ExecutionService.ExecuteReader(cmd);
        }

        private string GenerateTableCondition(IEnumerable<TableSourceInfo> tableSourceList, out string conditionParameter, out string conditionValue) {
            return GenerateTableCondition(tableSourceList.Select(ts => ts.Name), out conditionParameter, out conditionValue);
        }

        protected string GenerateTableCondition(IEnumerable<string> tableSources, out string conditionParameter, out string conditionValue) {
            string paramPrefix = DatabaseServices.ExecutionService.ParameterPrefix;
            string tableCondition;
            conditionValue = null;
            IList<string> tableSourceList = tableSources.ToList();

            if (tableSourceList.IsSingle()) {
                conditionValue = tableSourceList.First();
                conditionParameter = "TABLENAME";
                tableCondition = "=" + paramPrefix + conditionParameter;
            } else {
                tableCondition = " IN ('" + tableSourceList.StrCat("','") + "')";
                conditionParameter = null;
            }
            return tableCondition;
        }

        private static bool IsSequenceValue(string defaultValue) { // Default value for sequences is something like "database"."some_sequence"."nextval"
            var items = defaultValue.Split('.');
            var last = items.Last().ToLowerInvariant().Replace("\"", "");
            return last.Equals("nextval") || last.Equals("currval");
        }
    }
}
