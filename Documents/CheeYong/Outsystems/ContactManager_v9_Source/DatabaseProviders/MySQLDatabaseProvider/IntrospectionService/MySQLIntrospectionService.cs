/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using OutSystems.HubEdition.DatabaseProvider.MySQL.DatabaseObjects;
using OutSystems.HubEdition.Extensibility.Data;
using OutSystems.HubEdition.Extensibility.Data.DatabaseObjects;
using OutSystems.HubEdition.Extensibility.Data.IntrospectionService;
using OutSystems.RuntimeCommon;

namespace OutSystems.HubEdition.DatabaseProvider.MySQL.IntrospectionService {
    public class MySQLIntrospectionService : BaseIntrospectionService {

        protected delegate MySQLDataTypeInfo CreateDataTypeInfo(string type, string fullTypeName, int length, int precision, int scale, int datetimePrecision, bool isUnsigned);
        
        protected delegate MySQLTableSourceColumnInfo CreateColumnInfo(ITableSourceInfo tableSource, string columnName,
            IDataTypeInfo dataType, bool isMandatory, bool isPrimaryKey, bool isAutoGenerated, bool isUnsigned);

        public MySQLIntrospectionService(IDatabaseServices databaseServices) : base(databaseServices) { }
        
        public override IEnumerable<IDatabaseInfo> ListDatabases() {
            List<IDatabaseInfo> result = new List<IDatabaseInfo>();
            using (IDbConnection conn = DatabaseServices.TransactionService.CreateConnection()) {
                IDbCommand cmd = DatabaseServices.ExecutionService.CreateCommand(conn, "SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA");
                cmd.CommandTimeout = QueryTimeout;
                using (IDataReader reader = cmd.ExecuteReader()) {
                    while (reader.Read()) {
                        string dbName = (string)reader["SCHEMA_NAME"];
                        result.Add(new MySQLDatabaseInfo(DatabaseServices, dbName));
                    }
                }
            }
            return result;
        }

        public override IEnumerable<ITableSourceInfo> ListTableSources(IDatabaseInfo database, IsTableSourceToIgnore isTableSourceToIgnore) {
            string paramPrefix = DatabaseServices.ExecutionService.ParameterPrefix;
            IList<ITableSourceInfo> tables = new List<ITableSourceInfo>();
            MySQLDatabaseInfo databaseInfo = database as MySQLDatabaseInfo;
            if (databaseInfo == null) {
                return null;
            }
            using (IDbConnection conn = DatabaseServices.TransactionService.CreateConnection()) {
                string sql = string.Format(@"SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = {0}
                                           UNION
                                           SELECT TABLE_NAME FROM INFORMATION_SCHEMA.VIEWS  WHERE TABLE_SCHEMA = {0};", paramPrefix + "schema");

                IDbCommand cmd = DatabaseServices.ExecutionService.CreateCommand(conn, sql);
                cmd.CommandTimeout = QueryTimeout;
                DatabaseServices.ExecutionService.CreateParameter(cmd, paramPrefix + "schema", DbType.String, databaseInfo.Name);
                using (IDataReader reader = cmd.ExecuteReader()) {
                    while (reader.Read()) {
                        string tableName = (string)reader["TABLE_NAME"];
                        if (!isTableSourceToIgnore(tableName)) {
                            string qualifiedTableName = GetQualifiedIdentifier(databaseInfo.Name, tableName);
                            tables.Add(new MySQLTableSourceInfo(DatabaseServices, databaseInfo, tableName, qualifiedTableName));
                        }
                    }
                }
            }
            return tables;
        }

        private string GetQualifiedIdentifier(string schema, string tableName) {
            return DatabaseServices.DMLService.Identifiers.EscapeIdentifier(schema) + "." +
                DatabaseServices.DMLService.Identifiers.EscapeIdentifier(tableName);
        }

        public override IEnumerable<ITableSourceColumnInfo> GetTableSourceColumns(ITableSourceInfo tableSource){
            var ts = tableSource as MySQLTableSourceInfo;
            return (ts == null) ? null : GetColumns(ts.ToEnumerable(), GetDataTypeInfo, GetColumnInfo);
        }

        public override IEnumerable<ITableSourceForeignKeyInfo> GetTableSourceForeignKeys(ITableSourceInfo tableSource){
            var ts = tableSource as MySQLTableSourceInfo;
            return (ts == null) ? null : GetForeignKeys(ts.ToEnumerable());
        }

        private IEnumerable<ITableSourceColumnInfo> GetColumns(IEnumerable<MySQLTableSourceInfo> tableSources){
            return GetColumns(tableSources, GetDataTypeInfo, GetColumnInfo);
        }


        protected IEnumerable<ITableSourceColumnInfo> GetColumns(IEnumerable<MySQLTableSourceInfo> tableSources, CreateDataTypeInfo createDataTypeInfo, 
                CreateColumnInfo createColumnInfo) {

            string paramPrefix = DatabaseServices.ExecutionService.ParameterPrefix;
            var columnsInfo = new List<ITableSourceColumnInfo>();

            using (IDbConnection conn = DatabaseServices.TransactionService.CreateConnection()) {
                string tableNames = "'" + tableSources.Select(t => t.Name).StrCat("','") + "'";
                string query = string.Format(@"SELECT TABLE_NAME, COLUMN_NAME, COLUMN_TYPE, DATA_TYPE, IS_NULLABLE, CHARACTER_MAXIMUM_LENGTH, NUMERIC_PRECISION, NUMERIC_SCALE, COLUMN_KEY, EXTRA , COLUMN_DEFAULT, DATETIME_PRECISION
                                               FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA= {0} AND TABLE_NAME in ("+tableNames+@")
                                               ORDER BY ORDINAL_POSITION;", paramPrefix + "schema");

                IDbCommand cmd = DatabaseServices.ExecutionService.CreateCommand(conn, query);
                DatabaseServices.ExecutionService.CreateParameter(cmd, paramPrefix + "schema", DbType.String, tableSources.First().Database.Name);
                cmd.CommandTimeout = QueryTimeout;

                using (IDataReader reader = cmd.ExecuteReader()) {
                    while (reader.Read()) {

                        string tableName = (string)reader["TABLE_NAME"];
                        string columnName = (string)reader["COLUMN_NAME"];

                        string type = (string)reader["DATA_TYPE"];
                        
                        int length;

                        //longblobs and longtext might cause overflow so we need to protect the decoding
                        Int32.TryParse(Convert.ToString(reader["CHARACTER_MAXIMUM_LENGTH"]), out length);
                        if (length == 0) { length = int.MaxValue; }
                        
                        //due to mysql bugs on metadata http://bugs.mysql.com/bug.php?id=69042
                        //will try to parse first from raw data type and fall back to numeric precision metadata
                        //numeric precision is reliable for floating point data types
                        string column_type = ((string)reader["COLUMN_TYPE"]);
                        int precision;
                        string[] pieces = column_type.Split(new[] { '(', ')' });
                        if (pieces.Length < 2 || int.TryParse(pieces[1], out precision) == false) {
                            precision = reader["NUMERIC_PRECISION"] == DBNull.Value ? 0 : Convert.ToInt32(reader["NUMERIC_PRECISION"]);
                        }

                        bool isUnsigned = column_type.Contains("unsigned");

                        int scale = reader["NUMERIC_SCALE"] == DBNull.Value ? 0 : Convert.ToInt32(reader["NUMERIC_SCALE"]);

                        int datetimePrecision = reader["DATETIME_PRECISION"] == DBNull.Value ? 0 : Convert.ToInt32(reader["DATETIME_PRECISION"]);

                        IDataTypeInfo datatype = createDataTypeInfo(type, column_type, length, precision, scale, datetimePrecision, isUnsigned);

                        bool isAutoGenerated = ((string)reader["EXTRA"]).ContainsIgnoreCase("auto_increment");
                        bool isPrimaryKey = "PRI".EqualsIgnoreCase((string)reader["COLUMN_KEY"]);

                        bool isMandatory = isAutoGenerated  ||  "NO".EqualsIgnoreCase((string)reader["IS_NULLABLE"]);

                        ITableSourceInfo tableInfo = tableSources.First(t => t.Name.EqualsIgnoreCase(tableName));

                        ITableSourceColumnInfo columnInfo = createColumnInfo(tableInfo, columnName, datatype, isMandatory, isPrimaryKey, isAutoGenerated, isUnsigned);
                        columnsInfo.Add(columnInfo);
                    }
                }
            }
            return columnsInfo;
        }

        private static MySQLTableSourceColumnInfo GetColumnInfo(ITableSourceInfo tableSource, string columnName, IDataTypeInfo dataType,
                bool isMandatory, bool isPrimaryKey, bool isAutoGenerated, bool isUnsigned) {
            return new MySQLTableSourceColumnInfo(tableSource, columnName, dataType, isMandatory, isPrimaryKey, isAutoGenerated, isUnsigned);
        }

        private MySQLDataTypeInfo GetDataTypeInfo(string type, string fullTypeName, int length, int precision, int scale, int datetimePrecision, bool isUnsigned) {
            DBDataType dataType;
            int columnLength = 0, columnDecimals = 0;
            string typeCheck = type.ToLowerInvariant();

            switch (typeCheck) {
                case "tinyint":
                    if (precision == 1) {
                        dataType = DBDataType.BOOLEAN;
                        columnLength = 1;
                    } else {
                        dataType = DBDataType.INTEGER;
                    }
                    break;
                case "smallint":
                case "mediumint":
                case "int":
                    if (isUnsigned) dataType = DBDataType.LONGINTEGER;
                    else dataType = DBDataType.INTEGER;
                    break;
                case "date":
                    dataType = DBDataType.DATE;
                    columnLength = 11; //YYYY-MM-DD
                    break;
                case "datetime":
                case "timestamp":
                    dataType = DBDataType.DATE_TIME;
                    columnLength = datetimePrecision == 0 ? 20 : datetimePrecision + 21; //YYYY-MM-DD hh:mm:ss.nnnnnn + extra character for possible string ending
                    break;
                case "time":
                    dataType = DBDataType.TEXT;
                    columnLength = datetimePrecision == 0 ? 11 : datetimePrecision + 12; //[+-]hhh:mm:ss.nnnnnn + extra character for possible string ending
                    break;
                case "char":
                case "varchar":
                case "text":
                case "tinytext":
                case "mediumtext":
                case "longtext":
                case "enum":
                case "set":
                    dataType = DBDataType.TEXT;
                    columnLength = Math.Min(int.MaxValue, length);
                    break;
                case "float":
                    dataType = DBDataType.TEXT;
                    columnLength = precision > 23 ? 340 : 65; // 327 and 57 should be enough, but we will give more to be sure...
                    break;
                case "double":
                case "real":
                    dataType = DBDataType.TEXT;
                    columnLength = 340; // 327 should be enough, but we will give +13 to be sure...
                    break;
                case "binary":
                case "varbinary":
                case "tinyblob":
                case "mediumblob":
                case "blob":
                case "longblob":
                    dataType = DBDataType.BINARY_DATA;
                    break;
                case "bigint":
                    if (isUnsigned) {
                        dataType = DBDataType.DECIMAL;
                        columnLength = 20;
                        columnDecimals = 0;
                    } else dataType = DBDataType.LONGINTEGER;
                    break;
                case "bit":
                    if (precision == 1) {
                        dataType = DBDataType.BOOLEAN;
                        columnLength = 1;
                    } else {
                        dataType = DBDataType.LONGINTEGER;
                    }
                    break;
                case "decimal":
                    if (precision > 28 || scale > 8) {
                        dataType = DBDataType.TEXT;
                        columnLength = precision + 3; // +3 ( extra space for sign, 0 and . )
                    } else if (scale == 0 && precision <= 9) {
                        dataType = DBDataType.INTEGER;
                    } else if (scale == 0 && precision >= 10 && precision <= 18) {
                        dataType = DBDataType.LONGINTEGER;
                    } else {
                        dataType = DBDataType.DECIMAL;
                        columnLength = precision;
                        columnDecimals = scale;
                    } 
                    break;
                default:
                    dataType = DBDataType.UNKNOWN;
                    break;
            }
            return new MySQLDataTypeInfo(dataType, fullTypeName, columnLength, columnDecimals);
        }

        protected IEnumerable<ITableSourceForeignKeyInfo> GetForeignKeys(IEnumerable<MySQLTableSourceInfo> tableSources){
            string tableNames = "";
            try {
                tableNames = "'" + tableSources.Select(t => t.Name).StrCat("','") + "'";
                string paramPrefix = DatabaseServices.ExecutionService.ParameterPrefix;
                IList<ITableSourceForeignKeyInfo> foreignKeys = new List<ITableSourceForeignKeyInfo>();
                //on mysql table_schema always equal to constraint_schema so we can shortcut to optimize
                string query = string.Format(@"SELECT t.TABLE_NAME, c.CONSTRAINT_NAME, c.COLUMN_NAME, c.REFERENCED_TABLE_NAME, c.REFERENCED_COLUMN_NAME, r.DELETE_RULE
                                           FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE c
                                           INNER JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS t 
                                           ON c.CONSTRAINT_NAME = t.CONSTRAINT_NAME 
                                           INNER JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r
                                           ON r.CONSTRAINT_NAME = t.CONSTRAINT_NAME
                                           WHERE t.CONSTRAINT_TYPE = 'FOREIGN KEY' AND t.TABLE_SCHEMA = {0} 
                                           AND c.CONSTRAINT_SCHEMA = {0} AND r.CONSTRAINT_SCHEMA = {0} 
                                           AND t.TABLE_NAME  IN (" + tableNames+@")", paramPrefix + "schema");

                using (IDbConnection conn = DatabaseServices.TransactionService.CreateConnection()) {
                    IDbCommand cmd = DatabaseServices.ExecutionService.CreateCommand(conn, query);
                    DatabaseServices.ExecutionService.CreateParameter(cmd, paramPrefix + "schema", DbType.String, tableSources.First().Database.Name);
                    cmd.CommandTimeout = QueryTimeout;
                    using (IDataReader reader = cmd.ExecuteReader()) {
                        while (reader.Read()) {
                            string tableName = (string)reader["TABLE_NAME"];
                            string foreignKeyName = (string)reader["CONSTRAINT_NAME"];
                            string columnName = (string)reader["COLUMN_NAME"];
                            string referencedColumnName = (string)reader["REFERENCED_COLUMN_NAME"];
                            string referencedTableName = (string)reader["REFERENCED_TABLE_NAME"];
                            bool isCascadeDelete = "CASCADE".EqualsIgnoreCase((string)reader["DELETE_RULE"]);

                            MySQLTableSourceInfo tableSource = tableSources.First(t => t.Name.EqualsIgnoreCase(tableName));

                            string qualifiedReferencedTableName = GetQualifiedIdentifier(tableSource.Database.Name, referencedTableName);
                            ITableSourceInfo referencedTableSource = new MySQLTableSourceInfo(DatabaseServices, tableSource.Database, referencedTableName, qualifiedReferencedTableName);
                            ITableSourceForeignKeyInfo foreignKeyInfo = new MySQLTableSourceForeignKeyInfo(tableSource, foreignKeyName, columnName, referencedTableSource, referencedColumnName, isCascadeDelete);
                            foreignKeys.Add(foreignKeyInfo);
                        }
                    }
                    return foreignKeys;
                }
            } catch (Exception e) {
                OSTrace.Error(string.Format("Failed to retrieve foreign key information from database. Tables: {0}", tableNames), e);
                return new List<ITableSourceForeignKeyInfo>();
            }
        }
    }
}
