/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Threading;
using OutSystems.Internal.Db;
using OutSystems.RuntimeCommon;
using OutSystems.RuntimeCommon.ObfuscationProperties;

namespace OutSystems.Scheduler.Core {

    public enum JobKind {
        TimerJob = 1,
        ActivityJob = 2,
        EventJob = 3,
        EmailJob = 4
    }
    public abstract class IJob {

        private int id;

        protected int Id {
            get { return id; }
        }

        private string sandboxKey;

        public string SandboxKey {
            get { return sandboxKey; }
        }

        protected IJob(int id, string sandboxKey) {
            this.id = id;
            this.sandboxKey = sandboxKey;
        }

        public abstract void Execute();
        public abstract void HandleError(DateTime startDatetime, Exception ex, int duration);
        public abstract string Details();
        public abstract int TimeoutInSec { get; }

        private static Type[] jobTypesOrder = new Type[] { typeof(TimerJob), typeof(ActivityJob), typeof(EventJob), typeof(LightEventJob), typeof(EmailJob) };

        public static int GetKindOrderNum(Type jobType) {
            return jobTypesOrder.IndexOf(jobType);
        }

        public override bool Equals(object obj) {
            IJob other = obj as IJob;
            if (other == null) {
                return false;
            } else {
                return Id == other.Id && SandboxKey == other.SandboxKey;
            }
        }

        public override int GetHashCode() {
            if (!SandboxKey.IsEmpty()) {
                return Id ^ SandboxKey.GetHashCode();
            }
            return Id;
        }
    }
    public class SchedulerProducerConsumer<Job> where Job : IJob {

        public delegate List<Job> PullJobsFromDatabaseDelegate();

        public delegate bool CanExecuteDelegate(Transaction trans);

        public delegate bool CanExecuteInParallelDelegate(Transaction trans);

        protected object licenceJobLock = new Object();

        protected string name;
        protected int numberOfConsumers;
        protected Thread producerThread;
        protected Thread[] consumerThreads;
        protected Queue<Job> jobQueue = new Queue<Job>();
        protected HashSet<Job> jobsBeingProcessed = new HashSet<Job>();
        protected int delayBetweenExecutionsMs;
        protected int delayBetweenErrorMs;
        protected int delayBetweenDatabasePullMs;
        protected PullJobsFromDatabaseDelegate pullJobsFromDatabase;
        protected CanExecuteDelegate canExecuteDelegate;
        protected CanExecuteInParallelDelegate canExecuteInParallelDelegate;
        protected bool isDequeuePattern = false;

        protected bool canExecute = false;
        protected bool canExecuteInParallel = false;
        protected SchedulerRunner schedulerRunner;

        public SchedulerProducerConsumer(string name, int numberOfConsumers, int delayBetweenExecutionsMs, int delayBetweenErrorMs, int delayBetweenDatabasePullMs, PullJobsFromDatabaseDelegate pullJobs, bool isDequeuePattern, CanExecuteDelegate canExecuteDelegate, CanExecuteInParallelDelegate canExecuteInParallelDelegate, SchedulerRunner schedulerRunner) {
            OSTrace.Debug("Creating Producer-Consumer (" +
                "name: " + name + ";" +
                "canExecuteDelegate: " + canExecuteDelegate + ";" +
                "canExecuteInParallelDelegate: " + canExecuteInParallelDelegate + ";" +
                "delayBetweenExecutionsMs: " + delayBetweenExecutionsMs + ";" +
                "delayBetweenDatabasePullMs: " + delayBetweenDatabasePullMs + ";" +
                "delayBetweenErrorMs: " + delayBetweenErrorMs + ";" +
                "numberOfConsumers: " + numberOfConsumers + ";" +
                "isDequeuePattern: " + isDequeuePattern + ")");

            this.canExecuteDelegate = canExecuteDelegate;
            this.canExecuteInParallelDelegate = canExecuteInParallelDelegate;
            this.pullJobsFromDatabase = pullJobs;
            this.delayBetweenExecutionsMs = delayBetweenExecutionsMs;
            this.delayBetweenDatabasePullMs = delayBetweenDatabasePullMs;
            this.delayBetweenErrorMs = delayBetweenErrorMs;
            this.schedulerRunner = schedulerRunner;
            this.numberOfConsumers = numberOfConsumers;
            this.name = name;
            this.isDequeuePattern = isDequeuePattern;
            // launch n worker threads
            consumerThreads = new Thread[numberOfConsumers];
            for (int i = 0; i < numberOfConsumers; i++) {
                consumerThreads[i] = new Thread(ExecuteConsumer);
                consumerThreads[i].Name = this.name + " Processor #" + (i + 1);
                consumerThreads[i].IsBackground = true;
                consumerThreads[i].Start(i == 0);
            }

            // launch a single producer thread
            producerThread = new Thread(ExecuteProducer);
            producerThread.Name = (name.EndsWith("y") ? name.RightCut(1) + "ie" : name) + "s Fetcher";
            producerThread.IsBackground = true;
            producerThread.Start();
        }

        protected virtual void RefreshLicense() {
            InnerRefreshLicense();
        }

        private void InnerRefreshLicense() {
            using (Transaction trans = schedulerRunner.RunningContext.DatabaseProvider.GetCommitableTransaction()) {
                lock (licenceJobLock) {
                    canExecute = canExecuteDelegate(trans);
                    canExecuteInParallel = canExecuteInParallelDelegate(trans);
                    OSTrace.Debug("[Licensing] License refreshed (" +
                        "canExecute: " + canExecute + "; " +
                        "canExecuteInParallel: " + canExecuteInParallel + ")");
                    Monitor.PulseAll(licenceJobLock);
                    trans.Commit();
                }
            }
        }

        private bool QuickCheckCanExecute(bool isFirst) {
            return canExecute && (isFirst || canExecuteInParallel);
        }

        public void WaitforLicenseConformity(SchedulerThreadStatusData myStatus, bool isFirst) {
            lock (licenceJobLock) {
                while (!schedulerRunner.Stopping && !QuickCheckCanExecute(isFirst)) {
                    var status = isFirst ? SchedulerThreadStatus.Disabled : SchedulerThreadStatus.Uncreated;
                    OSTrace.Debug("[Licensing] Setting thread status to " + status);
                    myStatus.SetStatus(status, -1);
                    OSTrace.Debug("[Licensing] Waiting for license check");
                    Monitor.Wait(licenceJobLock, SchedulerRunner.StopDelayMs);
                    OSTrace.Debug("[Licensing] License checked");
                    if (schedulerRunner.Stopping) {
                        myStatus.SetStatus(SchedulerThreadStatus.Dead, 0);
                        return;
                    }
                }
            }
        }


        public virtual void ExecuteConsumer(object isFirstObj) {
            InnerExecuteConsumer(isFirstObj);
        }
        
        private static void SetupCurrentThreadCulture() {
            Thread.CurrentThread.CurrentCulture = CultureInfo.GetCultureInfo("en-US");
            Thread.CurrentThread.CurrentUICulture = CultureInfo.GetCultureInfo("en-US");
        }

        public void InnerExecuteConsumer(object isFirstObj) {
            OSTrace.Debug("Executing consumer");
            SetupCurrentThreadCulture();
            bool isFirst = (bool)isFirstObj;
            SchedulerThreadStatusData myStatus = SchedulerThreadStatusData<Job>.AllocateThreadStatusData( /*isProducer*/false);
            myStatus.Name = name + " Processor";

            do {
                try {
                    do {
                        WaitforLicenseConformity(myStatus, isFirst);

                        Job jobToExecute;
                        myStatus.SetStatus(SchedulerThreadStatus.Idle, -1);
                        lock (jobQueue) {
                            bool needsLicenseCheck = false;
                            while (jobQueue.IsEmpty() && !needsLicenseCheck) {
                                while (!schedulerRunner.Stopping && !Monitor.Wait(jobQueue, SchedulerRunner.StopDelayMs) && jobQueue.IsEmpty() && !needsLicenseCheck) {
                                    needsLicenseCheck = !QuickCheckCanExecute(isFirst);
                                }

                                if (schedulerRunner.Stopping) {
                                    myStatus.SetStatus(SchedulerThreadStatus.Dead, 0);
                                    return;
                                }
                            }

                            lock (licenceJobLock) {
                                if (needsLicenseCheck || !QuickCheckCanExecute(isFirst)) {
                                    continue;
                                }
                            }

                            jobToExecute = jobQueue.Dequeue();
                            jobsBeingProcessed.Add(jobToExecute);

                            // Signal producer that queue is empty
                            if (isDequeuePattern && jobQueue.IsEmpty()) {
                                OSTrace.Debug("Queue is empty. Signaling producer.");
                                Monitor.PulseAll(jobQueue);
                            }
                        }

                        myStatus.SetStatus(SchedulerThreadStatus.Processing, jobToExecute.Details(), jobToExecute.TimeoutInSec);
                        try {
                            Execute(jobToExecute);
                        } finally {
                            OSTrace.Debug("Error executing job. Removing from queue.");
                            lock (jobQueue) {
                                jobsBeingProcessed.Remove(jobToExecute);
                            }
                        }
                        myStatus.SetStatus(SchedulerThreadStatus.Sleeping, 3);
                    } while (schedulerRunner.Sleep(delayBetweenExecutionsMs));
                } catch (ThreadAbortException) {
                    OSTrace.Debug("Consumer thread aborted");
                    myStatus.SetStatus(SchedulerThreadStatus.Dead, 0);
                    return;
                } catch (Exception excep) {
                    myStatus.SetStatus(SchedulerThreadStatus.Error, excep.Message, 0);
                    SchedulerUtils.LogError("Scheduler Service: Error processing a scheduled job", excep, schedulerRunner.RunningContext.InstanceKey, logToEventViewer: true);
                }

            } while (schedulerRunner.Sleep(delayBetweenErrorMs));
            myStatus.SetStatus(SchedulerThreadStatus.Dead, 0);
        }

        protected virtual void Execute(Job job) {
            OSTrace.Debug("Starting job execution");
            DateTime startDatetime = DateTime.Now;
            try {
                job.Execute();
            } catch (Exception ex) {
                int duration = (int)((TimeSpan)(DateTime.Now - startDatetime)).TotalSeconds;
                job.HandleError(startDatetime, ex, duration);
            }
        }

        protected virtual void ExecuteProducer() {
            InnerExecuteProducer();
        }

        private void InnerExecuteProducer() {
            OSTrace.Debug("Executing producer");
            SetupCurrentThreadCulture();
            SchedulerThreadStatusData myStatus = SchedulerThreadStatusData<Job>.AllocateThreadStatusData( /*isProducer*/true);
            myStatus.LicenseInvalidated += new Action(RefreshLicense);
            myStatus.Name = (name.EndsWith("y") ? name.RightCut(1) + "ie" : name) + "s Fetcher";
            bool firstTime = true;

            do {
                try {
                    if (firstTime) {
                        RefreshLicense();
                        firstTime = false;
                    }

                    do {
                        try {

                            WaitforLicenseConformity(myStatus, true);

                            lock (jobQueue) {

                                if (isDequeuePattern) {
                                    while (!jobQueue.IsEmpty()) {
                                        while (!Monitor.Wait(jobQueue, SchedulerRunner.StopDelayMs) && !jobQueue.IsEmpty() && !schedulerRunner.Stopping) { }

                                        if (schedulerRunner.Stopping) {
                                            myStatus.SetStatus(SchedulerThreadStatus.Dead, 0);
                                            return;
                                        }
                                    }
                                } else {
                                    jobQueue.Clear();
                                }

                                myStatus.SetStatus(SchedulerThreadStatus.Processing, 30);
                                foreach (var job in pullJobsFromDatabase()) {
                                    // avoid adding duplicate jobs
                                    if (!jobsBeingProcessed.Contains(job)) {
                                        jobQueue.Enqueue(job);
                                    }
                                }

                                if (!jobQueue.IsEmpty()) {
                                    OSTrace.Debug("Queue has jobs. Signaling consumers.");
                                    Monitor.PulseAll(jobQueue);
                                }
                            }
                        } catch (ThreadAbortException) {
                            throw;
                        } catch (Exception e) {
                            SchedulerUtils.LogError(String.Format("Error executing job: {0}\n{1}\n{2}", e.Message, e.StackTrace, (new StackTrace(true)).ToString()), null, schedulerRunner.RunningContext.InstanceKey, logToEventViewer: true);
                            lock (jobQueue) {
                                jobQueue.Clear();
                            }
                            throw;
                        }

                        myStatus.SetStatus(SchedulerThreadStatus.Sleeping, delayBetweenDatabasePullMs + 1000);
                    } while (schedulerRunner.Sleep(delayBetweenDatabasePullMs));
                } catch (ThreadAbortException) {
                    OSTrace.Debug("Producer thread aborted");
                    myStatus.SetStatus(SchedulerThreadStatus.Dead, 0);
                    return;
                } catch (Exception excep) {
                    myStatus.SetStatus(SchedulerThreadStatus.Error, 0);
                    SchedulerUtils.LogError("Scheduler Service: Error creating scheduled jobs list", excep, schedulerRunner.RunningContext.InstanceKey, logToEventViewer: true);
                }
            } while (schedulerRunner.Sleep(delayBetweenErrorMs));
            myStatus.SetStatus(SchedulerThreadStatus.Dead, 0);
        }

        public int CountJobsBeingProcessed {
            get { return jobsBeingProcessed.Count; }
        }

    }
}