/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections.Generic;
using System.Data;
using System.Threading;
using OutSystems.HubEdition.RuntimePlatform;
using OutSystems.HubEdition.RuntimePlatform.Log;
using OutSystems.HubEdition.RuntimePlatform.Processes;
using OutSystems.Internal.Db;
using OutSystems.ObjectKeys;
using OutSystems.RuntimeCommon;
using OutSystems.Scheduler.Core.Configuration;

namespace OutSystems.Scheduler.Core {
    public class ActivityJob : IJob {

        private int ProcessId;
        private ObjectKey SSKey;
        public string ActivityName;
        private ActivityStatus CurrentStatus;
        private readonly RunningContext context;

        private int Scheduler_AutomaticActivitiesTimeout {
            get {
                return context.SettingsProvider.Get(SchedulerSettings.Activities.AutomaticActivitiesTimeout);
            }
        }

        private int Scheduler_ActivitiesTimeout {
            get {
                return context.SettingsProvider.Get(SchedulerSettings.Activities.ActivitiesTimeout);
            }
        }

        private int timeoutInSec;

        public override int TimeoutInSec {
            get { return timeoutInSec; }
        }

        private string EspaceName;
        private bool IsMultitenant;
        private string TenantName;
        private int EspaceId;
        private int TenantId;
        private DateTime PreviousNextRun;
        private string EspaceKey;

        public string Url() {
            return $"http://{context.SettingsProvider.Get(RuntimePlatformSettings.Misc.InternalAddress)}:{context.OutboundPort}/{EspaceName}/";
        }

        public string DebuggerUrl() {
            return Debugger.DebuggerUrl(context.SettingsProvider.Get(RuntimePlatformSettings.Misc.InternalAddress), EspaceName, IsMultitenant ? TenantName : null, /*personalAreaName*/null);
        }

        public override string Details() {
            return "Activity '" + ActivityName + "', id " + Id + ", Espace '" + EspaceName + "'" + (IsMultitenant ? ", Tenant '" + TenantName + "'" : "");
        }

        public ActivityJob(string espaceKey, int id, int processId, string ActivityName, ActivityStatus CurrentStatus, ObjectKey SSKey, ActivityKind kind, string EspaceName, bool IsMultitenant, string TenantName, int TenantId, int EspaceId, DateTime PreviousNextRun, string sandboxKey, RunningContext context)
            : base(id, sandboxKey) {
            this.context = context ?? throw new ArgumentException("No context provided for ActivityJob");

            this.EspaceKey = espaceKey;
            this.ProcessId = processId;
            this.ActivityName = ActivityName;
            this.CurrentStatus = CurrentStatus;
            this.SSKey = SSKey;
            this.timeoutInSec = kind == ActivityKind.AutomaticActivity ? Scheduler_AutomaticActivitiesTimeout : Scheduler_ActivitiesTimeout;
            this.EspaceName = EspaceName;
            this.IsMultitenant = IsMultitenant;
            this.TenantName = TenantName;
            this.TenantId = TenantId;
            this.EspaceId = EspaceId;
            this.PreviousNextRun = PreviousNextRun;
        }

        public override void Execute() {

            using (ActivityHandler activityHandler = new ActivityHandler(context.SettingsProvider, Url(), TenantId, 0, SchedulerUtils.SchedulerConsumerKey, EspaceKey)) {
                var keyDatabaseValue = ObjectKeyUtils.DatabaseValue(SSKey);
                activityHandler.Timeout = (int)(1.2 * TimeoutInSec) * 1000;
                OSTrace.Debug("ACTIVITY SCHEDULER DEBUG START:" + this.ActivityName + " Going to execute activity WS (SSKey=" + keyDatabaseValue + ",Id=" + Id + ",ProcessId=" + ProcessId + ",CurrentStatus=" + CurrentStatus + ",PreviousNextRun=" + PreviousNextRun + "), Thread: " + Thread.CurrentThread.ManagedThreadId);
                bool result = activityHandler.ExecuteActivityActionv2(keyDatabaseValue, Id, ProcessId, TenantId, CurrentStatus, PreviousNextRun);
                OSTrace.Debug("ACTIVITY SCHEDULER DEBUG END:" + this.ActivityName + " activity WS (SSKey=" + keyDatabaseValue + ",Id=" + Id + ",ProcessId=" + ProcessId + ",CurrentStatus=" + CurrentStatus + ",PreviousNextRun=" + PreviousNextRun + ") executed successfully, Thread: " + Thread.CurrentThread.ManagedThreadId);
            }
        }

        public override void HandleError(DateTime startDatetime, Exception ex, int durationInSec) {
            DateTime runAt = startDatetime;
            try {
                using (Transaction privTrans = context.DatabaseProvider.GetCommitableTransaction()) {
                    // due to a request time-out update DB job entry and job log

                    string run_by;
                    DateTime run_since, next_run;

                    using (IDataReader reader = DBScheduler.Instance.GetActivityJobForUpdate(privTrans, Id)) {
                        if (!reader.Read()) {
                            throw new DataBaseException("No data returned for activiy.Id = " + Id + ", activity.Name = '" + ActivityName + "' in ServerErrorUpdateDb method. reader.Read() returned false");
                        }

                        run_by = reader.SafeGet<string>("IS_RUNNING_AT", string.Empty).Trim();
                        run_since = reader.SafeGet<DateTime>("IS_RUNNING_SINCE", BuiltInFunction.NullDate());
                        next_run = reader.SafeGet<DateTime>("NEXT_RUN", BuiltInFunction.NullDate());
                    }

                    DBRuntimePlatform.Instance.GetEspaceAppInfo(privTrans, EspaceId, out string eSpaceName, out string applicationName, out ObjectKey applicationKey);

                    // check if activity has actually started
                    // for example, there was a problem in web service invocation
                    if (run_by.IsEmpty() || run_since == BuiltInFunction.NullDate()) {
                        if (next_run.Equals(PreviousNextRun)) {
                            string errorId = ErrorLog.LogApplicationError(EspaceId, TenantId, "Scheduler Service: Error executing request " + Url() + " for Activity " + ActivityName + ". Request duration = " + durationInSec + " secs. [Will retry later]", ex.ToString(), null, "Scheduler", eSpaceName, applicationName, applicationKey);
                            DBScheduler.Instance.UpdateActivityNextRunWithError(privTrans, Id, errorId, context.SettingsProvider.Get(SchedulerSettings.Activities.ProcessBackoffConstant), context.SettingsProvider.Get(SchedulerSettings.Activities.ProcessBackoff_RetrybaseSec));
                        } else {
                            // This can happen when an exception in the activity escalates all the way to Global.aspx exception handler. 
                            // In this case, the Scheduler will receive a response with the Global.aspx error page. 
                            // For example, this happens in timeouts.
                            ErrorLog.LogApplicationError(EspaceId, TenantId, "Scheduler Service: Error executing request " + Url() + " for Activity " + ActivityName + ". Request duration = " + durationInSec + " secs. ", ex.ToString(), null, "Scheduler", eSpaceName, applicationName, applicationKey);
                        }
                    } else if (run_by.ToUpper().Equals(RuntimeEnvironment.MachineName)) {
                        // activity started, but did not finish. We "own" it
                        DBRuntimePlatform.Instance.ClearJobRunningBy(privTrans, Id);
                        string errorId = ErrorLog.LogApplicationError(EspaceId, TenantId, String.Format(@"Scheduler Service: Error executing request {0} for Activity {1}. Request duration = {2} secs.", Url(), ActivityName, durationInSec), ex.Message + Environment.NewLine + ex.StackTrace, null, "Scheduler", eSpaceName, applicationName, applicationKey);
                        DBScheduler.Instance.UpdateActivityNextRunWithError(privTrans, Id, errorId, context.SettingsProvider.Get(SchedulerSettings.Activities.ProcessBackoffConstant), context.SettingsProvider.Get(SchedulerSettings.Activities.ProcessBackoff_RetrybaseSec));
                    }
                    privTrans.Commit();
                }
            } catch (Exception e) {
                SchedulerUtils.LogError("Scheduler Service: Error updating DB job entry (activity job= " + Id.ToString() + "), ActivityName = '" + ActivityName + "'", e, SandboxKey, logToEventViewer: true);
            }
        }
    }
}