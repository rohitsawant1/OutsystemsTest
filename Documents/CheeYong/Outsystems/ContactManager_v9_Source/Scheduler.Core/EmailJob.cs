/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Data;
using OutSystems.HubEdition.RuntimePlatform;
using OutSystems.HubEdition.RuntimePlatform.Log;
using OutSystems.Internal.Db;
using OutSystems.ObjectKeys;
using OutSystems.RuntimeCommon;
using OutSystems.Scheduler.Core.Configuration;

namespace OutSystems.Scheduler.Core {

    public class EmailJob : IJob {

        private const int timeoutInSec = 30;

        public override int TimeoutInSec {
            get { return timeoutInSec; }
        }

        private void GetEspaceInfo(out int eSpaceId, out int tenantId, out string eSpaceName, out string applicationName, out ObjectKey applicationKey) {
            eSpaceId = 0;
            tenantId = 0;
            eSpaceName = null;
            applicationName = null;
            applicationKey = null;

            using (Transaction privTrans = context.DatabaseProvider.GetReadOnlyTransaction()) {
                eSpaceId = DBScheduler.Instance.GetEspaceIdFromEmailId(privTrans, Id);
                tenantId = DBScheduler.Instance.GetTenantIdFromEmailId(privTrans, Id);

                if (eSpaceId != 0) {
                    DBRuntimePlatform.Instance.GetEspaceAppInfo(privTrans, eSpaceId, out eSpaceName, out applicationName, out applicationKey);
                }
            }
        }

        public override string Details() {
            return "Email id " + Id;
        }

        public bool Expired {
            get {
                using (Transaction privTrans = context.DatabaseProvider.GetCommitableTransaction()) {
                    using (IDataReader reader = DBScheduler.Instance.GetCreatedAndCurrentDate(privTrans, Id)) {
                        reader.Read();
                        DateTime created = reader.SafeGet<DateTime>("Created", BuiltInFunction.NullDate());
                        DateTime now = reader.SafeGet<DateTime>("Now", BuiltInFunction.NullDate());
                        bool expired = (now - created).Days >= context.SettingsProvider.Get(SchedulerSettings.Emails.EmailBackoffMaxDays);
                        privTrans.Commit();
                        return expired;
                    }
                }
            }
        }
        private readonly RunningContext context;

        public EmailJob(int id, string sandboxKey, RunningContext context) : base(id, sandboxKey) {
            this.context = context ?? throw new ArgumentException("No context provided for EmailJob");
        }

        public override void Execute() {
            SendEmail();
            MarkAsSent();
            ClearContentIfNeeded();
        }

        private void SendEmail() {

            string mail, from, to, cc, bcc;
            using (Transaction privTrans = context.DatabaseProvider.GetCommitableTransaction()) {
                byte[] content;
                DBScheduler.Instance.GetEmail(privTrans, Id, out content, out from, out to, out cc, out bcc);
                if (content == null) {
                    throw new EmailException("Email content not found for email " + Id);
                }
                mail = System.Text.Encoding.UTF8.GetString(content);
                privTrans.Commit();
            }

            string username = context.SettingsProvider.Get(SchedulerSettings.Emails.Username);
            string password = context.SettingsProvider.Get(SchedulerSettings.Emails.Password);

            bool useAuthentication = context.SettingsProvider.Get(SchedulerSettings.Emails.UseAuthentication) && !username.IsEmpty() && !password.IsEmpty();

            string emailServerHost = context.SettingsProvider.Get(SchedulerSettings.Emails.Server_Host);

            if (string.IsNullOrEmpty(emailServerHost)) {
                throw new EmailException("The 'SMTP Server' must be set in Service Center Environment Configuration to send emails.");
            }

            int sendTimeout = context.SettingsProvider.Get(SchedulerSettings.Emails.SendTimeout);
            int receiveTimeout = context.SettingsProvider.Get(SchedulerSettings.Emails.ReceivedTimeout);
            SMTP.SendMail.Send(emailServerHost, context.SettingsProvider.Get(SchedulerSettings.Emails.Server_Port), useAuthentication ? SMTP.SendMail.AuthType.LOGIN : SMTP.SendMail.AuthType.NONE, useAuthentication ? username : string.Empty, useAuthentication ? password : string.Empty, mail, from, to, cc, bcc, sendTimeout, receiveTimeout);
        }

        public override void HandleError(DateTime startDatetime, Exception ex, int durationInSec) {
            GetEspaceInfo(out int eSpaceId, out int tenantId, out string eSpaceName, out string applicationName, out ObjectKey applicationKey);
            string errorId = ErrorLog.LogApplicationError(eSpaceId, tenantId, String.Format(@"Error sending email {0}: {1}", Id, ex.Message), ex, null, "Email",
                eSpaceName, applicationName, applicationKey);

            if (Expired) {
                ErrorLog.LogApplicationError(eSpaceId, tenantId, String.Format(@"Discarding email {0} because it exceeded the maximum time for retries({1} days).", Id, context.SettingsProvider.Get(SchedulerSettings.Emails.EmailBackoffMaxDays)), string.Empty, null, "Email",
                    eSpaceName, applicationName, applicationKey);

                ClearNextRun();
            } else {
                RequeueEmail(errorId);
            }

        }

        private void RequeueEmail(string errorId) {
            try {
                using (Transaction privTrans = context.DatabaseProvider.GetCommitableTransaction()) {
                    DBScheduler.Instance.RequeueEmail(privTrans, Id, errorId, context.SettingsProvider.Get(SchedulerSettings.Activities.ProcessBackoffConstant), context.SettingsProvider.Get(SchedulerSettings.Activities.ProcessBackoff_RetrybaseSec));
                    privTrans.Commit();
                }
            } catch (Exception e) {
                SchedulerUtils.LogError("Scheduler Service: Error updating email (id= " + Id.ToString() + ")", e, SandboxKey, logToEventViewer: true);
            }
        }

        private void MarkAsSent() {
            try {
                using (Transaction privTrans = context.DatabaseProvider.GetCommitableTransaction()) {
                    DBScheduler.Instance.MarkEmailAsSent(privTrans, Id);
                    privTrans.Commit();
                }
            } catch (Exception e) {
                SchedulerUtils.LogError("Scheduler Service: Error marking email as sent (id= " + Id.ToString() + ")", e, SandboxKey, logToEventViewer: true);
            }
        }

        private void ClearContentIfNeeded() {
            try {
                using (Transaction privTrans = context.DatabaseProvider.GetCommitableTransaction()) {
                    DBScheduler.Instance.DeleteEmailContentIfNeeded(privTrans, Id);
                    privTrans.Commit();
                }
            } catch (Exception e) {
                SchedulerUtils.LogError("Scheduler Service: Error deleting email content (id= " + Id.ToString() + ")", e, SandboxKey, logToEventViewer: true);
            }
        }


        private void ClearNextRun() {
            try {
                using (Transaction privTrans = context.DatabaseProvider.GetCommitableTransaction()) {
                    DBScheduler.Instance.ClearEmailNextRun(privTrans, Id);
                    privTrans.Commit();
                }
            } catch (Exception e) {
                SchedulerUtils.LogError("Scheduler Service: Error clearing next email run (id= " + Id.ToString() + ")", e, SandboxKey, logToEventViewer: true);
            }
        }
    }
}