/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Data;
using System.Threading;
using OutSystems.HubEdition.RuntimePlatform;
using OutSystems.HubEdition.RuntimePlatform.Log;
using OutSystems.Internal.Db;
using OutSystems.ObjectKeys;
using OutSystems.RuntimeCommon;
using OutSystems.RuntimeCommon.ObfuscationProperties;
using OutSystems.Scheduler.Core.Configuration;

namespace OutSystems.Scheduler.Core {
    [DoNotObfuscate]
    public class TimerJob : IJob {

        private ObjectKey SSKey;
        private ObjectKey UserProviderKey;
        private bool IsShared;
        public string TimerName;

        int timeoutInSec;

        public override int TimeoutInSec {
            get { return timeoutInSec; }
        }

        string EspaceName;
        bool IsMultitenant;
        string TenantName;
        int EspaceId;
        int TenantId;
        DateTime PreviousNextRun;
        public readonly int Priority;

        private readonly RunningContext context;

        //This should be placed inside a common. Its also in Naming.NETPageNames.WebServices.TimerJob.WebServiceFilename
        public const string WebServiceFilename = "_TimerHandler.asmx";

        public string Url() {
            return $"http://{context.SettingsProvider.Get(RuntimePlatformSettings.Misc.InternalAddress)}:{context.OutboundPort}/{EspaceName}/{WebServiceFilename}";
        }


        public override string Details() {
            return "Timer '" + TimerName + "', id " + Id + ", Module '" + EspaceName + "'" + ((IsMultitenant && !TenantName.IsEmpty()) ? ", Tenant '" + TenantName + "'" : string.Empty)
                + (string.IsNullOrEmpty(SandboxKey) ? string.Empty : ", Sandbox " + SandboxKey);
        }

        public TimerJob(int id, string TimerName, ObjectKey SSKey, ObjectKey UserProviderKey, bool IsShared, int TimeoutInSec,
            string EspaceName, bool IsMultitenant, string TenantName, int TenantId, int EspaceId,
            DateTime PreviousNextRun, int TimerPriority, string SandboxKey, RunningContext context)
            : base(id, SandboxKey) {

            this.context = context ?? throw new ArgumentException("No context provided for TimerJob");
            
            this.TimerName = TimerName;
            this.SSKey = SSKey;
            this.UserProviderKey = UserProviderKey;
            this.IsShared = IsShared;
            this.timeoutInSec = TimeoutInSec;
            this.EspaceName = EspaceName;
            this.IsMultitenant = IsMultitenant;
            this.TenantName = TenantName;
            this.TenantId = TenantId;
            this.EspaceId = EspaceId;
            this.PreviousNextRun = PreviousNextRun;
            this.Priority = TimerPriority;

        }

        public override void Execute() {
            using (TimerHandler timerHandler = new TimerHandler(Url())) {
                timerHandler.Timeout = (int)(1.2 * timeoutInSec * 1000);
                OSTrace.Debug("TIMER SCHEDULER DEBUG START:" + TimerName + " Going to execute timer WS, Thread: " + Thread.CurrentThread.ManagedThreadId);
                OSTrace.TimerStart("Timer Scheduler " + this.EspaceName + "." + this.TimerName);
                int result = timerHandler.ExecuteTimer(SSKey.ToString(ObjectKey.DatabaseFormat), timeoutInSec, TenantId);
                OSTrace.TimerEnd("Timer Scheduler " + this.EspaceName + "." + this.TimerName);
                OSTrace.Debug("TIMER SCHEDULER DEBUG END:" + TimerName + " Timer WS executed successfully, Thread: " + Thread.CurrentThread.ManagedThreadId);
            }
        }

        public override void HandleError(DateTime startDatetime, Exception ex, int durationInSec) {
            DateTime runAt = startDatetime;

            try {

                using (Transaction privTrans = context.DatabaseProvider.GetCommitableTransaction()) {
                    // due to a request time-out update DB job entry and job log
                    string run_by;
                    DateTime run_since, next_run;

                    using (IDataReader reader = DBScheduler.Instance.GetCyclicJobForUpdate(privTrans, Id, IsShared)) {
                        if (!reader.Read()) {
                            throw new DataBaseException("No data returned for " + (IsShared ? "shared " : string.Empty) + "job.Id = " + Id +
                                                        ", job.TimerName = '" + TimerName +
                                                        "' in ServerErrorUpdateDb method. reader.Read() returned false");
                        }

                        run_by = reader.SafeGet<string>("IS_RUNNING_BY", string.Empty).Trim();
                        run_since = reader.SafeGet<DateTime>("IS_RUNNING_SINCE", BuiltInFunction.NullDate());
                        next_run = reader.SafeGet<DateTime>("NEXT_RUN", BuiltInFunction.NullDate());
                    }

                    if (TenantId == 0) {
                        // Fix TenantId just to get good  error logging
                        TenantId = DBRuntimePlatform.Instance.GetDefaultTenantIdByUserProviderEspaceKey(privTrans, UserProviderKey, "-");
                    }

                    DBRuntimePlatform.Instance.GetEspaceAppInfo(privTrans, EspaceId, out string eSpaceName, out string applicationName, out ObjectKey applicationKey);

                    // check if timer has actually started
                    // for example, there was a problem in web service invocation
                    if (run_by.IsEmpty() || run_since == BuiltInFunction.NullDate()) {
                        if (((DateTime)next_run).Equals(PreviousNextRun)) {
                            ErrorLog.LogApplicationError(EspaceId, TenantId,
                                "Scheduler Service: Error executing request " + Url() + " for Timer " + TimerName + ". Request duration = " +
                                durationInSec + " secs. [Timer failed before starting: please check if there are any errors in this module]", ex, null, "Scheduler",
                                eSpaceName, applicationName, applicationKey);
                        } else {
                            // is this ever going to happen?
                            ErrorLog.LogApplicationError(EspaceId, TenantId,
                                "Scheduler Service: Error executing request " + Url() + " for Timer " + TimerName + ". Request duration = " +
                                durationInSec + " secs. [Timer failed before starting: please check if there are any errors in this module]", ex, null, "Scheduler",
                                eSpaceName, applicationName, applicationKey);
                        }

                        // Quick-win for personal environement issue. Timer of eSpace without User Provider will try to run forever,
                        // filling his limited database with system data (timer logs). This pattern is common when installing eSpace
                        // from Forge. User has no visiblity of the issue and also doesn't have a mechanism to address it. 
                        string schedule;
                        DateTime dbNow, newNextRun, currentIsRunningSince, nextRun;
                        DBRuntimePlatform.Instance.GetTimerScheduleNextRunAndDbDate(privTrans, Id, IsShared, out schedule, out dbNow, out newNextRun, out currentIsRunningSince);
                        RuntimeScheduler.NextRun(schedule, dbNow, out nextRun);
                        DBRuntimePlatform.Instance.SetTimerNextRun(privTrans, Id, IsShared, nextRun);
                    } else if (((string)run_by).ToUpper().Equals(RuntimeEnvironment.MachineName.ToUpper())) {

                        int numberOfTries = DBRuntimePlatform.Instance.GetNumberOfTries(privTrans, Id, IsShared);
                        int maxNumberOfRetries = context.SettingsProvider.Get(SchedulerSettings.Misc.NumberOfRetries);
                        // timer started, but did not finish. We "own" it

                        // lets clean running by and increment de number of tries
                        DBRuntimePlatform.Instance.ClearTimerRunningBy(privTrans, Id, IsShared);
                        DBRuntimePlatform.Instance.UpdateCyclicJob(privTrans, Id, IsShared);

                        string appendable = String.Format(" [retry {0} of {1} scheduled]", numberOfTries + 1, maxNumberOfRetries);

                        string errorId = ErrorLog.LogApplicationError(EspaceId, TenantId,
                            String.Format(
                                @"Scheduler Service: Error executing request {0} for Timer {1}. Request duration = {2} secs. {3}", 
                                    Url(), TimerName, durationInSec, appendable),
                            ex, null, "Scheduler", eSpaceName, applicationName, applicationKey);

                        CyclicJobLog.StaticWrite(runAt, durationInSec, SSKey, EspaceId, TenantId, RuntimeEnvironment.MachineName, errorId,
                            PreviousNextRun, PreviousNextRun, eSpaceName, applicationName, applicationKey, this.TimerName);
                    }
                    privTrans.Commit();
                }
            } catch (Exception e) {
                SchedulerUtils.LogError("Scheduler Service: Error updating DB job entry (cyclic job= " + Id.ToString() + "), TimerName = '" + TimerName + "'", e, SandboxKey, logToEventViewer: true);
            }
        }
    }
}

