/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections;
using System.Collections.Specialized;
using System.Globalization;
using System.IO;
using System.Net.Security;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using OutSystems.HubEdition.RuntimePlatform.Email;
using OutSystems.RuntimeCommon;

namespace OutSystems.Scheduler.Core.SMTP {

    internal class SendMail {

        public enum AuthType {
            NONE,
            PLAIN,
            LOGIN,
        }

        private static string ToAuthString(AuthType type) {
            switch (type) {
                case AuthType.PLAIN:
                    return "PLAIN";
                case AuthType.LOGIN:
                    return "LOGIN";
                default:
                    throw new InvalidOperationException("Unsupported Authentication Type specified");
            }
        }

        private static Hashtable GetHeaders(string email, int start, int maxpos) {
            Hashtable headers = CollectionsUtil.CreateCaseInsensitiveHashtable();
            while (start < maxpos) {
                int headerstart = start;
                int headerbeggining = start;
                int headerend = start;
                int lineend = -1;
                lineend = email.IndexOf("\n", headerstart, maxpos - headerstart);
                while ((email[lineend + 1] == ' ') || (email[lineend + 1] == '\t')) {
                    lineend = email.IndexOf("\n", lineend + 1, ((lineend + 1) + (maxpos - headerstart) < email.Length ? (maxpos - headerstart) : email.Length - (lineend + 1)));
                }
                headerend = lineend + 1;
                if (headerend == 0) {
                    headerend = email.Length - 1;
                }
                string headerline = email.Substring(headerstart, headerend - headerstart).Trim();
                int header_divider_pos = headerline.IndexOf(":");
                string header = headerline.Substring(0, header_divider_pos).Trim();
                string header_value = headerline.Substring(header_divider_pos + 1).Trim();
                if (headers[header] == null) {
                    headers[header] = new ArrayList();
                }
                ((ArrayList)headers[header]).Add(header_value);
                start = headerend;
            }
            return headers;
        }

        private static string GetHeaderSubfield(string headerline, string field) {
            string res = null;
            string span = null;
            if (headerline == null) return res;
            headerline = headerline.Trim();
            if (headerline.Length == 0) return res;
            headerline.Replace("\r\n", " ");
            int pos = 0;
            int state = 0;
            int start = -1;
            bool breakout = false;
            string subfield = null;
            string subvalue = null;
            while ((pos <= headerline.Length) && (!breakout)) {
                switch (state) {
                    case 0: {
                            if (pos == headerline.Length) {
                                breakout = true;
                                break;
                            }
                            // Evaluate if it's a regular token or a quoted value
                            if (headerline[pos] == '\"') {
                                start = pos;
                                state = 2;
                            } else {
                                start = pos;
                                state = 1;
                            }
                            break;
                        }
                    case 1: {
                            // It's a regular token, keep going until we hit a ';'
                            if ((pos == headerline.Length) || (headerline[pos] == ';')) {
                                span = headerline.Substring(start, pos - start);
                                state = 0;

                                if (span.IndexOf("=") > 0) {
                                    subfield = span.Substring(0, span.IndexOf("=")).Trim();
                                }
                                if (((subfield == null) && ((field == null || field.Length == 0))) || (string.Compare(subfield, field, true, CultureInfo.InvariantCulture) == 0)) {
                                    breakout = true;
                                }
                                break;
                            } else if (headerline[pos] == '\"') {
                                state = 2;
                            }
                            break;
                        }
                    case 2: {
                            // It's a quoted value, keep going until we hit a '"'
                            if (headerline[pos] == '\"') {
                                state = 1;
                            }
                            break;
                        }
                }
                pos++;
            }

            if (((subfield == null) && ((field == null || field.Length == 0))) || (string.Compare(subfield, field, true, CultureInfo.InvariantCulture) == 0)) {
                if (subfield != null) {
                    subvalue = span.Substring(span.IndexOf("=") + 1).Trim();
                } else {
                    subvalue = span.Trim();
                }
            }

            return subvalue;
        }


        public static void Send(string smtpserver, int smtpserverport, AuthType authType, string username, string password, 
            string mail, string from, string to, string cc, string bcc, int sendTimeout, int receiveTimeout) {

            // Create and instance of SMTPMail
            SMTPMail m = new SMTPMail();


            if (smtpserverport != 0) {
                m.Server = smtpserver + ":" + smtpserverport;
            } else{
                m.Server = smtpserver;
            }

            // Get email address of sender from the email
            //string from = Regex.Match(mail, "\r\nFrom: ([^\r\n]*)\r\n").Groups[1].Value;
            string mailFrom = EmailHelper.GetCleanEmailAddress(from);

            // Add the addresses in the To header to the list of addresses
            string mailTo = EmailHelper.GetCleanEmailAddresses(to + "," + cc + "," + bcc, " ");

            // Remove extra spaces
            mailTo = Regex.Replace( mailTo.Trim(), "  +", " ");

            // Fill the SMTPClient structure
            m.MailFrom = mailFrom;
            m.MailTo = mailTo;
            m.MailData = mail;

            m.AuthType = authType;
            m.Username = username;
            m.Password = password;

            m.SendMail(sendTimeout, receiveTimeout);
            
            if (m.ErrorMessage != "") {
                throw new InvalidOperationException(m.ErrorMessage);
            }
        } // 


        internal class SMTPClient : System.Net.Sockets.TcpClient {
            private SslStream sslStream;
        
            private Stream ActualStream {
                get {
                    return (Stream) sslStream?? GetStream();
                }
            }

            private bool ValidateRemoteCertificate(string hostName, SslPolicyErrors sslPolicyErrors) {
                if (sslPolicyErrors != SslPolicyErrors.None) {
                    OSTrace.Error("Certificate error while contacting server {0}: {1}", hostName, sslPolicyErrors);
                } 
                
                // Allow to procede anyway
                return true;
            }
            
            protected override void Dispose(bool disposing) {
                if (disposing && (sslStream != null)) {
                    sslStream.Dispose();
                    sslStream = null;
                }
                            
                base.Dispose(disposing);
            }
            
            public void InitializeTLS(string hostName) { 
                sslStream = new SslStream(GetStream(), true, 
                    (sender, certificate, chain, sslPolicyErrors) => ValidateRemoteCertificate(hostName, sslPolicyErrors));

                sslStream.AuthenticateAsClient(hostName);
            }
        
            public bool isConnected() {
                return Active;
            }

            public void SendCommandToServer(string Command) {
                Stream ns = ActualStream;
                byte[] WriteBuffer;
                WriteBuffer = new byte[1024];
                System.Text.ASCIIEncoding en = new System.Text.ASCIIEncoding();
                WriteBuffer = en.GetBytes(Command);
                var ShortCommand = Command.Substring(0, Command.Length < 100 ? Command.Length : 100 );
                OSTrace.Debug("Sending Command To Server - Thread: " + Thread.CurrentThread.ManagedThreadId + " - command: '" + ShortCommand + "'");
                ns.Write(WriteBuffer, 0, WriteBuffer.Length);
                OSTrace.Debug("Just Sent Command To Server - Thread: " + Thread.CurrentThread.ManagedThreadId + " - command: '" + ShortCommand + "'");
                return;
            }

            /* regex to capture the final codes - the space in the end is important! */
            private readonly Regex finalCodeRegex = new Regex("[1-9][0-9][0-9] ");
            private const int NumberOfRetries = 10;

            public string GetServerResponse() {
                string returnValue = "";
                Stream ns = ActualStream;
                byte[] readBuffer = new byte[1024];
                ns.Read(readBuffer, 0, readBuffer.Length);
                System.Text.ASCIIEncoding en = new System.Text.ASCIIEncoding();
                int countIterations = 0;
                while (true) {
                    countIterations++;
                    /* the .Replace("\0", "") is necessary to be able to do the += */
                    returnValue += en.GetString(readBuffer).Replace("\0", "");

                    if (finalCodeRegex.Match(returnValue).Success) {
                        break;
                    } else if (countIterations >= NumberOfRetries) {
                        // #1025190 will break after NumberOfRetries tries:
                        // we are noticing that when opening a new connection, after a sucessful QUIT, server is sending us empty characters
                        // and causing the scheduler to get stuck
                        // caller methods will handle a missing code correctly (as a connection error)
                        break;
                    }

                    // only log first NumberOfRetries-1 iterations
                    if (countIterations < NumberOfRetries) {
                        OSTrace.Debug("Get Response from Server - Thread:" + Thread.CurrentThread.ManagedThreadId
                            + " - iteration: " + countIterations + " - returnValue: '" + returnValue + "'");
                    }

                    /* sleep so the server can return more content */
                    Thread.Sleep(100);
                    ns.Read(readBuffer, 0, readBuffer.Length);
                }
                OSTrace.Debug("Get Response from Server - Finished reading from stream - Thread:" + Thread.CurrentThread.ManagedThreadId);

                return returnValue;
            }

            public bool DoesStringContainSMTPCode(System.String s, System.String SMTPCode) {
                return (s.IndexOf(SMTPCode, 0, (10 > s.Length ? s.Length : 10)) == -1) ? false : true;
            }
        }// end of class SMTPClient

        internal class SMTPMail {
            private static readonly String[] SuccessResponseCodes = { "220", "250", "251", "354", "221", "334", "235" };   // success codes from SMTP server
            
            // Don't add to errormsg the send instruction codes for these errors (usernames, pwds etc)
            private static readonly String[] HideFromErrorReportResponseCodes = { "535" };

            //we can use 127.0.0.1 because email is not supported in sandbox mode
            private System.String _ServerHost = "127.0.0.1";
            private int _ServerPort = 25;
            private System.String _errmsg = "";
            private System.String _ServerResponse = "";
            private System.String _Identity = "outsystems";
            private System.String _MailFrom = "";
            private System.String _MailTo = "";
            private System.String _MailData = "";
            private System.String _Username = "";
            private System.String _Password = "";
            private AuthType _AuthType = AuthType.NONE;
            private bool supportTLS = false;

            private bool SendCommand(SMTPClient tcp, String command, bool ignoreError) {
                tcp.SendCommandToServer(command);
                String serverResponse = tcp.GetServerResponse();

                for (int j = 0; j < SuccessResponseCodes.Length; j++) {
                    if (tcp.DoesStringContainSMTPCode(serverResponse, SuccessResponseCodes[j])) {
                        _ServerResponse += serverResponse;
                        _ServerResponse += "<br>";
                        break;
                    } else {
                        if (j == SuccessResponseCodes.Length - 1) {
                            if (!ignoreError) {
                                _errmsg += serverResponse;
                                
                                bool dumpSendBuffer = true;
                                for (int k = 0; k < HideFromErrorReportResponseCodes.Length; k++) {
                                    if (tcp.DoesStringContainSMTPCode(serverResponse, HideFromErrorReportResponseCodes[k])) {
                                        dumpSendBuffer = false;
                                        break;
                                    }
                                }

                                if (dumpSendBuffer) {
                                    _errmsg += command;
                                }
                            }
                            
                            return false;
                        }
                    }
                }
                
                return true;
            }
            
            private bool SendCommand(SMTPClient tcp, String command) {
                return SendCommand(tcp, command, false);
            }
            
            private string EhloCommand {
                get {
                    string result = System.String.Concat("EHLO ", _Identity);
                    result = System.String.Concat(result, "\r\n");
                    return result;
                }
            }
            
            public System.String Identity {  // This property contains Sender's Identity
                set { _Identity = value; }
            }

            public System.String MailFrom {   // This property contains sender's email address
                set { _MailFrom = value; }
            }

            public System.String MailTo {  // This property contains recepient's email address
                set { _MailTo = value; }
            }

            public System.String MailData {  // This property contains email message
                set { _MailData = value; }
            }

            public System.String Username {  // This property contains username (for SMTP)
                private get { return _Username ?? string.Empty; } //paranoia check
                set { _Username = value; }
            }

            public System.String Password {  // This property contains password (for SMTP)
                private get { return _Password ?? string.Empty; } //paranoia check
                set { _Password = value; }
            }

            public AuthType AuthType {  // This property contains authentication kind
                get { return _AuthType; }
                set { _AuthType = value; }
            }

            public System.String Server {
                get {
                    if (_ServerPort != 25) {
                        return _ServerHost;
                    } else {
                        return _ServerHost + ":" + _ServerPort;
                    }
                }
                set {
                    string[] hostvals = value.Split(':');
                    _ServerHost = hostvals[0];
                    if (hostvals.Length > 1) {
                        _ServerPort = Convert.ToInt32(hostvals[1]);
                    }
                }
            }


            public System.String ErrorMessage {  // This property contais error message
                get {
                    return _errmsg;
                }
            }


            public System.String ServerResponse {  // This property contains SMTP server response
                get {
                    return _ServerResponse;
                }
            }
            
            public bool ServerSupportsTLS {
                get {
                    return supportTLS;
                }
            }
            
            public void SendMail(int sendTimeout, int receiveTimeout) {

                try {
                    System.String ServerResponse;
                    System.Text.Encoding encoding = System.Text.Encoding.UTF8;

                    using (SMTPClient tcp = new SMTPClient()) {
                        tcp.SendTimeout = sendTimeout;
                        tcp.ReceiveTimeout = receiveTimeout;
                        tcp.Connect(_ServerHost, _ServerPort);            // first connect to smtp server
                        bool blnConnect = tcp.isConnected();

                        // test for successful connection
                        if (!blnConnect) {
                            //  System.Console.WriteLine("connection failed...");
                            _errmsg = "Connetion Failed...";
                            return;
                        }

                        //read response of the server
                        ServerResponse = tcp.GetServerResponse();
                        if (tcp.DoesStringContainSMTPCode(ServerResponse, "220")) {
                            _ServerResponse += ServerResponse;
                        } else {
                            _errmsg = "connection failed" + ServerResponse;
                            return;
                        }

                        //String[] SendBuffer = {"HELO thravindras\r\n","MAIL FROM: megha@thravindras\r\n","RCPT TO: ravindras@expowin2k\r\n","DATA \r\n"," Blah Blah Blah This is test mail from ravindra\r\n.\r\n","QUIT\r\n"};
                        string[] sendTo = _MailTo.Split(' ');
                        int bufferSize = sendTo.Length + 8;
                        System.String[] SendBuffer = new System.String[bufferSize];
                        
                        int count = 0;
                        System.String StrTemp = "";
                                            
                        // See if the ServerResponse to the EHLO command contains the STARTTLS
                        String startTTLSCommand = "STARTTLS";
                        bool helloCommandIssued = false;
                        
                        if (SendCommand(tcp, EhloCommand, true)) {
                            helloCommandIssued = true;
                            
                            if (_ServerResponse.Contains(startTTLSCommand) && SendCommand(tcp, startTTLSCommand + "\r\n", true)) {
                                // Proceed with the SSL
                                tcp.InitializeTLS(_ServerHost);
                                supportTLS = true;
                                helloCommandIssued = false; // We need to send another EHLO command after the STARTTLS
                            }
                        }
                        
                        OSTrace.Info("The email server {0} {1} TLS.", _ServerHost, supportTLS? "supports": "does not support");
                        
                        // Include authentication if needed
                        if (AuthType != AuthType.NONE) {
                            if (!helloCommandIssued) {
                                SendBuffer[count++] = EhloCommand;
                            }

                            StrTemp = System.String.Concat("AUTH ", ToAuthString(AuthType));
                            StrTemp = System.String.Concat(StrTemp, "\r\n");
                            SendBuffer[count++] = StrTemp;

                            switch (AuthType) {
                                case AuthType.PLAIN:
                                    string usernameAndPassword;
                                    usernameAndPassword = "" + '\x00' + Username + '\x00' + Password;
                                    usernameAndPassword = System.Convert.ToBase64String(encoding.GetBytes(usernameAndPassword)) + "\r\n";
                                    SendBuffer[count++] = usernameAndPassword;
                                    break;

                                case AuthType.LOGIN:
                                    string username;
                                    string password;
                                    username = System.Convert.ToBase64String(encoding.GetBytes(Username)) + "\r\n";
                                    SendBuffer[count++] = username;
                                    password = System.Convert.ToBase64String(encoding.GetBytes(Password)) + "\r\n";
                                    SendBuffer[count++] = password;
                                    break;

                                default:
                                    _errmsg = "Unsupported Authentication Type specified";
                                    return;
                            }
                        } else if (!helloCommandIssued) {
                            // Simple HELO will do
                            StrTemp = System.String.Concat("HELO ", _Identity);
                            StrTemp = System.String.Concat(StrTemp, "\r\n");
                            SendBuffer[count++] = StrTemp;
                        }

                        StrTemp = "";
                        StrTemp = System.String.Concat("MAIL FROM: ", EncodeMail(_MailFrom));
                        StrTemp = System.String.Concat(StrTemp, "\r\n");
                        SendBuffer[count++] = StrTemp;

                        foreach (string mailAddr in sendTo) {
                            StrTemp = "";
                            StrTemp = System.String.Concat("RCPT TO: ", EncodeMail(mailAddr));
                            StrTemp = System.String.Concat(StrTemp, "\r\n");
                            SendBuffer[count] = StrTemp;
                            count++;
                        }

                        StrTemp = "";
                        StrTemp = System.String.Concat("DATA", "\r\n");
                        SendBuffer[count] = StrTemp;
                        count++;

                        StrTemp = "";
                        StrTemp = System.String.Concat(StrTemp, _MailData);
                        StrTemp = System.String.Concat(StrTemp, "\r\n.\r\n");
                        SendBuffer[count] = StrTemp;
                        count++;

                        StrTemp = "";
                        StrTemp = System.String.Concat(StrTemp, "QUIT\r\n");
                        SendBuffer[count] = StrTemp;
                        count++;

                        int i = 0;
                        /*  for debugging
                                      _errmsg = "" ;
                                      for(i=0;i<5;i++)
                                      {
                                            _errmsg += SendBuffer[i] ;
                                          _errmsg += "<br>" ;
                                      }
                                      return ;
                                      end of debugging
                                    */
                        while (i < count) {
                            if (!SendCommand(tcp, SendBuffer[i])) {
                                return;
                            }
                            
                            i++;
                        } // end of while loop ;
                    }   // end of the using
                } catch (System.Net.Sockets.SocketException se) {
                    _errmsg += se.Message + " " + se.StackTrace;
                } catch (System.Exception e) {
                    _errmsg += e.Message + " " + e.StackTrace;
                }
            } // end of  SendMail method
            
            private static string EncodeMail(string mail) {
                return EmailFunctions.Compose(Encoding.ASCII, String.Empty, mail);
            }
        } // end of class client

    }
}

